[{"id":"/notes#开发者的自我修养","title":"开发者的自我修养","titles":[],"content":"在数字化时代，软件开发已成为推动社会进步的重要力量。作为软件开发者，我们不仅要关注技术层面的提升，更要注重自我修养的全面提高。本文将从多个维度探讨开发者的自我修养，以期帮助大家在技术道路上走得更远、更稳。","level":1},{"id":"/notes#一技术专精与持续学习","title":"一、技术专精与持续学习","titles":["开发者的自我修养"],"content":"作为开发者，技术是我们的立身之本。不断精进自己的专业技能，保持对新技术的好奇心和探索欲，是提升自我修养的基础。我们应该：深入掌握至少一门编程语言，并了解其他相关语言的特点。  熟悉软件开发流程，能够独立完成项目需求分析、设计、编码和测试。  定期参加技术培训和研讨会，与同行交流经验，拓宽视野。  利用业余时间学习新技术，关注行业动态，保持与时俱进。","level":2},{"id":"/notes#二严谨态度与高质量追求","title":"二、严谨态度与高质量追求","titles":["开发者的自我修养"],"content":"软件开发是一项需要严谨思维和高质量标准的工作。我们应该养成以下习惯：对待每一个项目都认真负责，不因项目大小或难易程度而有所懈怠。  在编码过程中保持清晰的逻辑和简洁的代码风格，遵循最佳实践。  重视测试环节，确保软件的质量和稳定性达到预期标准。  勇于承认和改正自己的错误，不断追求更高的技术水平。","level":2},{"id":"/notes#三团队协作与沟通能力","title":"三、团队协作与沟通能力","titles":["开发者的自我修养"],"content":"在软件开发过程中，团队协作是不可或缺的。我们应该努力提升自己在团队中的协作能力：学会倾听他人的意见，尊重团队成员的多样性和差异性。  能够准确表达自己的想法和观点，避免沟通障碍和误解。  积极参与团队讨论和决策，为团队目标贡献自己的力量。  在遇到困难时及时向团队求助，共同寻找解决方案。","level":2},{"id":"/notes#四职业操守与责任意识","title":"四、职业操守与责任意识","titles":["开发者的自我修养"],"content":"作为开发者，我们肩负着重要的职业操守和社会责任。我们应该时刻牢记：遵守法律法规，不利用技术从事违法活动。  保护用户隐私和数据安全，不泄露敏感信息。  关注软件的可维护性和可扩展性，为用户提供长期稳定的支持。  倡导开源精神，为行业发展贡献力量。","level":2},{"id":"/notes#五健康生活与平衡发展","title":"五、健康生活与平衡发展","titles":["开发者的自我修养"],"content":"在追求技术进步的同时，我们也不能忽视自己的身心健康。以下是一些建议：合理安排工作时间，避免过度劳累和熬夜。  积极参加体育锻炼，保持良好的身体素质。  培养兴趣爱好，丰富自己的生活圈子，拓宽人生视野。  关注心理健康，学会调节情绪和压力，保持积极乐观的心态。综上所述，开发者的自我修养涉及技术、态度、协作、职业操守和健康生活等多个方面。只有全面发展自己，我们才能在这个日新月异的行业中立足并取得长足进步。","level":2},{"id":"/notes#个人链接","title":"个人链接","titles":["开发者的自我修养"],"content":"工欲善其事，必先利其器","level":2},{"id":"/notes/dev/dev#开发笔记","title":"开发笔记","titles":[],"content":"nofollow 标签 - ggghttps://www.tailwindcss.cn/docs/installation引入了   ，其中    中有一个    机制，它会注入一些全局样式，来统一不同浏览器的默认标签样式。比如像   ,  ,   这类标签，原先编写后，浏览器默认会给它们不同的字体大小。引入    后，浏览器给的样式被覆盖和统一，所以这些标签就都一样大了，我们称之为   。浏览器呈现后，发现字都是一样大的，这样就看不出文章标题的层级。此时你就需要一些专门为文章展示场景设计     了。接下来让我开始安装：接着在    中注册它:此时你就可以使用    相关的原子化    来美化你的文章内容了，它会给你编写的文章内容添加预设的样式。只需在我们的    添加属性:    即可呈现效果。作者：icebreaker\n链接：  https://juejin.cn/post/7117806971226423304 \n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","level":1},{"id":"/notes/dev/dev#vue3-开发笔记","title":"Vue3 开发笔记","titles":[],"content":"Default slot text   This will be rendered inside the    slot.current: 1content tab-contentdefault content tab-content   index0 1  index1 1  index2 1This will be rendered inside the    slot.","level":1},{"id":"/notes/dev/vscode-extension#vscode-插件","title":"VSCode 插件","titles":[],"content":"","level":1},{"id":"/notes/dev/vscode-extension#插件","title":"插件","titles":["VSCode 插件"],"content":"","level":2},{"id":"/notes/dev/vscode-extension#iconify","title":"Iconify","titles":["VSCode 插件","插件"],"content":"https://marketplace.visualstudio.com/items?itemName=antfu.iconifyInline display corresponding icons  Auto-completion for icon-sets  Hover  Snippets","level":3},{"id":"/notes/dev/vscode-extension#bradlcvscode-tailwindcss","title":"bradlc.vscode-tailwindcss","titles":["VSCode 插件"],"content":"https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss","level":2},{"id":"/notes/dev/vscode-extension#features","title":"Features","titles":["VSCode 插件"],"content":"","level":2},{"id":"/notes/dev/vscode-extension#autocomplete","title":"Autocomplete","titles":["VSCode 插件","Features"],"content":"Intelligent suggestions for class names, as well as   CSS functions and directives .","level":3},{"id":"/notes/dev/vscode-extension#linting","title":"Linting","titles":["VSCode 插件","Features"],"content":"Highlights errors and potential bugs in both your CSS and your markup.","level":3},{"id":"/notes/dev/vscode-extension#hover-preview","title":"Hover Preview","titles":["VSCode 插件","Features"],"content":"See the complete CSS for a Tailwind class name by hovering over it.","level":3},{"id":"/notes/vue#vue","title":"Vue","titles":[],"content":"vue","level":1},{"id":"/notes/vue#usevue","title":"Usevue","titles":["Vue"],"content":"https://vueuse.org/guide/","level":2},{"id":"/notes/vue#demos","title":"Demos","titles":["Vue"],"content":"Vite + Vue 3   Nuxt 3 + Vue 3   Webpack + Vue 3   Nuxt 2 + Vue 2   Vue CLI + Vue 2","level":2},{"id":"/notes/css/aaa#在实用程序类前添加hoverbg-sky-700","title":"在实用程序类前添加  hover:bg-sky-700","titles":[],"content":"","level":1},{"id":"/notes/css/aaa#修饰符堆叠","title":"修饰符堆叠","titles":["在实用程序类前添加  hover:bg-sky-700"],"content":"以下为修饰符","level":2},{"id":"/notes/css/aaa#伪类伪元素","title":"伪类伪元素","titles":["在实用程序类前添加  hover:bg-sky-700"],"content":"使用方法：\n   在实用程序类前添加   伪类\n   hover  focus  focus-within 用来选择和样式化一个元素或者它的任何后代元素获得焦点的情况  focus-visible 用来选择和样式化一个元素或者它的任何后代元素获得焦点的情况，用非指针方法获得焦点时  active 伪类选择器是用来选择和样式化被激活的元素，比如被点击的链接或按钮  visited 用来选择和样式化用户已经访问过的链接  target 元素的 ID 与当前 URL 片段匹配  first 如果元素是第一个使用修饰符的子元素  last 如果元素是最后一个使用修饰符的子元素  only 如果元素是唯一使用修饰符的子元素  odd 如果元素是奇数编号的子元素  even 如果元素是偶数编号的子元素  first-of-type 如果元素是其类型的第一个子元素  last-of-type 如果元素是其类型的最后一个子元素  only-of-type 如果元素是其类型中唯一的子元素  empty 如果元素没有内容  disabled 在禁用输入时设置输入样式  enabled 在元素未禁用时应用另一种样式时  checked 选中复选框或单选按钮时  indeterminate 不确定状态的复选框或单选按钮的样式  default 这些选项、复选框或单选按钮是最初使用修饰符加载页面时的默认值  required 可以选择和样式化任何带有required属性的  、  或  元素  valid 输入有效时的样式  invalid 输入无效时的样式  in-range 当输入的值在指定的范围限制内时  out-of-range 当输入的值超出指定范围限制时  placeholder-shown 显示占位符时设置输入样式  autofill 自动填充输入时，用户未编辑过  read-only 在输入为只读时  伪元素\n   before 创建一个元素作为当前元素的第一个子元素  after  placeholder  file 代表 type=\"file\" 的    的按钮 ::file-selector-button  marker: 匹配当前标签下 列表的标记框（通常为一个符号或数字）。它作用在任何设置了 display: list-item 的元素或伪元素上，例如    和    元素  selection 是一个CSS伪元素选择器，它可以用来给用户选中的文本添加样式  first-line 首行  first-letter 首字  backdrop ::backdrop在任何处于全屏模式的元素下的即刻渲染的盒子（并且在所有其他在堆中的层级更低的元素之上）","level":2},{"id":"/notes/css/aaa#媒体查询","title":"媒体查询","titles":["在实用程序类前添加  hover:bg-sky-700"],"content":"使用方法：\n   在实用程序类前添加   媒体查询\n   sm @media (min-width: 640px)  md @media (min-width: 768px)  lg @media (min-width: 1024px)  xl @media (min-width: 1280px)  2xl @media (min-width: 1536px)  min-  …  自定义 @media (min-width: …)   max-sm @media not all and (min-width: 640px)  max-md @media not all and (min-width: 768px)  max-lg @media not all and (min-width: 1024px)  max-xl @media not all and (min-width: 1280px)  max-2xl @media not all and (min-width: 1536px)  max-  …  自定义@media (max-width: …)  portrait 竖屏，@media (orientation: portrait)  landscape 横屏  dark @media (prefers-color-scheme: dark)  motion-reduce 一个CSS媒体查询，它可以用来检测用户是否在设备上启用了减少非必要动画或运动的设置  motion-safe 当用户没有设置 prefers-reduced-motion 时才添加样式  contrast-more 用户请求更多对比度时，@media (prefers-contrast: more)  print 打印样式  supports-  ...  特性查询，用来判断浏览器是否支持某些 css 特性，例如：@supports (display: grid) { ... }","level":2},{"id":"/notes/css/aaa#其他","title":"其他","titles":["在实用程序类前添加  hover:bg-sky-700"],"content":"","level":2},{"id":"/notes/css/aaa#属性选择器","title":"属性选择器","titles":["在实用程序类前添加  hover:bg-sky-700","其他"],"content":"aria-* 属性选择器\n       和 group 和 peer 配合使用   data-* 属性选择器\n     open 具有 open 属性的元素\n     details 和 dialog 标签具有 open 属性","level":3},{"id":"/notes/css/aaa#后代选择器","title":"后代选择器","titles":["在实用程序类前添加  hover:bg-sky-700","其他"],"content":"ltr、rtl 不同文本展示方式下设置样式，html 中设置    才能够生效     根据父元素状态设置元素样式时，在父元素绑定group，在子元素绑定group-*来定义根据特定父元素状态来设置元素样式，在父元素绑定group/{name}，在子元素绑定group-hover/{name}来定义可以在 group-   的方括号内传入任意选择器来指定特定的父元素& 用来作为 group 的占位符，空格用 _ 代替  是  的简写https://www.tailwindcss.cn/docs/configuration","level":3},{"id":"/notes/css/aaa#安装略","title":"安装（略）","titles":[],"content":"","level":1},{"id":"/notes/css/aaa#编辑器设置略","title":"编辑器设置（略）","titles":[],"content":"","level":1},{"id":"/notes/css/aaa#using-with-preprocessors-与预处理器一起使用略","title":"Using with Preprocessors 与预处理器一起使用（略）","titles":[],"content":"","level":1},{"id":"/notes/css/aaa#optimizing-for-production-针对生产进行优化略","title":"Optimizing for Production 针对生产进行优化（略）","titles":[],"content":"","level":1},{"id":"/notes/css/aaa#browser-support-浏览器支持略","title":"Browser Support 浏览器支持（略）","titles":[],"content":"","level":1},{"id":"/notes/css/aaa#upgrade-guide-升级指南略","title":"Upgrade Guide 升级指南（略）","titles":[],"content":"","level":1},{"id":"/notes/css/aaa#utility-first-fundamentals-效用优先基础知识","title":"Utility-First Fundamentals 效用优先基础知识","titles":[],"content":"好处\n   You aren’t wasting energy inventing class names. 你不是在浪费精力发明类名\n   注释：一个自定义类有什么作用？  Your CSS stops growing 您的 CSS 停止增长  Making changes feels safer 进行更改感觉更安全\n   注释：只影响当前标签  Why not just use inline styles? 为什么不直接使用内联样式？\n   Designing with constraints.有约束的设计。\n   注释：使用 tailwindcss 的值有一定的范围，并不是可任意定义的  Responsive design 响应式设计  Hover, focus, and other states. 悬停、焦点和其他状态","level":1},{"id":"/notes/css/aaa#hover-focus-and-other-states-悬停焦点和其他状态","title":"Hover, Focus, and Other States 悬停、焦点和其他状态","titles":[],"content":"Every utility class in Tailwind can be applied conditionally by adding a modifier to the beginning of the class name that describes the condition you want to target.\n   Tailwind 中的每个实用程序类都可以有条件地应用，方法是在描述要面向的条件的类名的开头添加一个修饰符。  注释：实用程序类 是指 Tailwind 提供的基础类Pseudo-classes, like   ,   ,   , and     伪类  hover  focus  focus-within 用来选择和样式化一个元素或者它的任何后代元素获得焦点的情况  focus-visible 用来选择和样式化一个元素或者它的任何后代元素获得焦点的情况，用非指针方法获得焦点时  active 伪类选择器是用来选择和样式化被激活的元素，比如被点击的链接或按钮  visited 用来选择和样式化用户已经访问过的链接  target 元素的 ID 与当前 URL 片段匹配  first 如果元素是第一个使用修饰符的子元素  last 如果元素是最后一个使用修饰符的子元素  only 如果元素是唯一使用修饰符的子元素  odd 如果元素是奇数编号的子元素  even 如果元素是偶数编号的子元素  first-of-type 如果元素是其类型的第一个子元素  last-of-type 如果元素是其类型的最后一个子元素  only-of-type 如果元素是其类型中唯一的子元素  empty 如果元素没有内容  disabled 在禁用输入时设置输入样式  enabled 在元素未禁用时应用另一种样式时  checked 选中复选框或单选按钮时  indeterminate 不确定状态的复选框或单选按钮的样式  default 这些选项、复选框或单选按钮是最初使用修饰符加载页面时的默认值  required 可以选择和样式化任何带有required属性的  、  或  元素  valid 输入有效时的样式  invalid 输入无效时的样式  in-range 当输入的值在指定的范围限制内时  out-of-range 当输入的值超出指定范围限制时  placeholder-shown 显示占位符时设置输入样式  autofill 自动填充输入时，用户未编辑过  read-only 在输入为只读时  Pseudo-elements, like ::before, ::after, ::placeholder, and ::selection\n   伪元素  before 创建一个元素作为当前元素的第一个子元素  after  Note that if you’ve disabled our preflight base styles, the content property will not be set to an empty string by default, and you will need to include content-  ''  any time you use the before and after modifiers.\n   如果没有  引入基本样式，那么 before 等为元素不会自动 content 一个空字符串，需要  手动实现  placeholder  file 代表 type=\"file\" 的    的按钮 ::file-selector-button\n   Note that Tailwind’s border reset is not applied to file input buttons. This means that to add a border to a file input button, you need to explicitly set the border-style using a class like alongside any border-width utility:file:border-solid\n    中对于边框的样式重置不会影响 file input，如果需要边框的话，需要手动设置   We’ve designed the marker modifier to be inheritable, so although you can use it directly on an    element, you can also use it on a parent to avoid repeating yourself.\n   marker: 匹配当前标签下 列表的标记框（通常为一个符号或数字）。它作用在任何设置了 display: list-item 的元素或伪元素上，例如    和    元素  注意后代选择器样式影响范围问题接上面   selection 是一个CSS伪元素选择器，它可以用来给用户选中的文本添加样式\n   We’ve designed the selection modifier to be inheritable, so you can add it anywhere in the tree and it will be applied to all descendant elements.\n   selection 可以用于给所有选中的子孙文件添加样式，  对应的 css 应该是   注释：注意后代选择器导致的影响范围不明确问题  first-line 首行  first-letter 首字  backdrop\n   ::backdrop 在任何处于全屏模式的元素下的即刻渲染的盒子（并且在所有其他在堆中的层级更低的元素之上）  注释：原生 dialog 标签就是一个全屏模式的元素，可以用这个类来修改它的容器的样式  Media and feature queries, like responsive breakpoints, dark mode, and prefers-reduced-motion   响应   媒体查询 @media：屏幕宽度、分辨率、方向\n   屏幕宽度 md、lg 等\n   sm @media (min-width: 640px)  md @media (min-width: 768px)  lg @media (min-width: 1024px)  xl @media (min-width: 1280px)  2xl @media (min-width: 1536px)  min-  …  @media (min-width: …)  max-sm @media not all and (min-width: 640px)  max-md @media not all and (min-width: 768px)  max-lg @media not all and (min-width: 1024px)  max-xl @media not all and (min-width: 1280px)  max-2xl @media not all and (min-width: 1536px)  max-  …  @media (max-width: …)  方向\n   portrait 竖屏，   landscape 横屏  流式布局：百分比、flex  响应图片：根据分辨率加载不同大小图片  黑暗：   媒体查询        和   使用 CSS 中的过滤器（filter），利用 invert 和 hue-rotate 两个函数来反转和调整页面元素的颜色   filter 属性来给元素（通常是图片）添加一些视觉效果（类似于 Photoshop 中的滤镜）。CSS filter 属性可以让您实现一些预定义的效果，例如模糊、亮度、对比度、阴影、灰度、色相、反转、透明度、饱和度和棕褐色等。您也可以使用 url () 函数来引用 SVG 文件中定义的滤镜效果。   invert() 函数是一种滤镜函数，可以用来给元素（通常是图片）添加反色的效果。invert() 函数的作用是将输入图像中的每个颜色样本反转，即用 255 减去原来的颜色值。可以传入参数表示反转的程度  hue-rotate() 函数是一种滤镜函数，可以用来给元素（通常是图片）添加色相旋转的效果。色相旋转的意思是将输入图像中的每个颜色样本沿着色环（色彩模型中的一个圆形区域，表示不同的色相）旋转一定的角度，从而改变图像的色调。  注释：invert 使图片的颜色趋于中和然后反向，hue-rotate 使图片中的颜色变成其他颜色  使用 CSS 中的混合模式（mix-blend-mode），让页面元素的颜色与背景色相互影响，产生不同的视觉效果   mix-blend-mode 是一种 CSS 属性，它定义了一个元素的内容如何与其父元素的内容和元素的背景如何混合。它允许你创建令人惊艳的视觉效果，可以用于创建半透明效果、添加阴影、制作图片蒙版和很多其他效果。具体来说，mix-blend-mode 定义了两个元素之间的颜色混合模式。  motion-reduce   prefers-reduced-motion 是一个CSS媒体查询，它可以用来检测用户是否在设备上启用了减少非必要动画或运动的设置   motion-safe 当用户没有设置 prefers-reduced-motion 时才添加样式   contrast-more 用户请求更多对比度时，     contrast-less 用户要求降低对比度时  print 打印样式  Use the supports-  ...  modifier to style things based on whether a certain feature is supported in the user’s browser.   特性查询，用来判断浏览器是否支持某些 css 特性，例如：     Under the hood the supports-  ...  modifier generates @supports rules and takes anything you’d use with @supports (...) between the square brackets, like a property/value pair, and even expressions using and and or.\n   方括号内支持 @supports () 内的所有语法  For terseness, if you only need to check if a property is supported (and not a specific value), you can just specify the property name:\n   为了简洁起见可以直接用属性名判断是否支持该属性   backdrop-filter 是一种 CSS 属性，它可以让你对一个元素的背景或背景区域应用图形效果，比如模糊、色彩变换等。它和 filter 属性的效果类似，但是 filter 属性是对元素的内容应用效果，而 backdrop-filter 属性是对元素的背景应用效果。  You can configure shortcuts for common @supports rules you’re using in your project in the theme.supports section of your tailwind.config.js file:\n   可以在配置文件中为  内内容配置快捷方式，注意：快捷方式不是通过  传入Attribute selectors, like   dir=\"rtl\"  and   open   Use the aria-* modifier to conditionally style things based on ARIA attributes.   根据是否有 aria-* 属性来控制     ARIA 用于修改无障碍树中定义的元素的状态和属性，例如：把 aria-hidden=\"true\" 加到元素上会把该元素和它的所有子元素从无障碍树上移除。这样做可以通过隐藏下列内容来提升使用辅助技术的用户体验  By default we’ve included modifiers for the most common boolean ARIA attributes:   为  常用 的 aria 属性提供了快捷方式   原生所有的 aria 属性  If you need to use a one-off aria modifier that doesn’t make sense to include in your theme, or for more complex ARIA attributes that take specific values, use square brackets to generate a property on the fly using any arbitrary value.   使用    可以使用任意 aria 属性，例如：   ARIA state modifiers can also target parent and sibling elements using the group-aria-* and peer-aria-* modifiers:   可以和 group 和 peer 配合使用，  标识父组件具有  属性时 svg 的样式  You can customize which aria-* modifiers are available by editing theme.aria or theme.extend.aria in your tailwind.config.js file   可以在配置中为  内内容配置快捷方式，注意：快捷方式不是通过  传入接上面\n   Since there are no standard data-* attributes by definition, by default we only support arbitrary values out of the box, for example:\n   data- 没有官方默认属性，所以默认只支持  传入任意值，例如   You can configure shortcuts for common data attribute selectors you’re using in your project in the theme.data section of your tailwind.config.js file:\n   可以在配置文件中配置快捷方式  ~= 是一种 CSS 属性选择器，它用来选择具有指定属性和值的元素，其中值是一个由空格分隔的列表，且列表中包含指定的值。接上面   Use the rtl and ltr modifiers to conditionally add styles in right-to-left and left-to-right modes respectively when building multi-directional layouts:   使用 rtl 和 ltr 在不同文本展示方式下设置样式   Note that the ltr modifier will not take effect unless the dir attribute is explicitly set to ltr, so if you are building a multi-directional site make sure to always set a direction, not just in rtl mode.  必须在 html 中设置  才能够生效  Use the open modifier to conditionally add styles when a    or    element is in an open state:   details 和 dialog 标签具有 open 属性     details 折叠框标签  These modifiers can even be stacked to target more specific situations, for example changing the background color in dark mode, at the medium breakpoint, on hover:   这些修饰符甚至可以堆叠When you need to style an element based on the state of some parent element, mark the parent with the group class, and use group-* modifiers like group-hover to style the target element:\n   根据父元素状态设置元素样式时，在父元素绑定  ，在子元素绑定  来定义  注释：嵌套容易导致影响范围不明确  下例：当    hover 时，svg、h3、p 改变字体颜色   适用于每个伪类  注释：group不是通过原生css的伪类实现的，文档的归类会导致误导When nesting groups, you can style something based on the state of a specific parent group by giving that parent a unique group name using a group/{name} class, and including that name in modifiers using classes like group-hover/{name}:\n   根据特定父元素状态来设置元素样式，在父元素绑定  ，在子元素绑定  来定义     You can create one-off group-* modifiers on the fly by providing your own selector as an arbitrary value between square brackets:\n   可以在 group-   的方括号内传入任意选择器来指定特定的父元素     For more control, you can use the & character to mark where .group should end up in the final selector relative to the selector you are passing in:\n   & 用来作为 group 的占位符，空格用 _ 代替     When you need to style an element based on the state of a sibling element, mark the sibling with the peer class, and use peer-* modifiers like peer-invalid to style the target element:\n   根据同级元素来设置之后元素，  用来标记需要观察的同级元素，  用来标记之后元素在同级元素处于 * 状态时的样式  注释：p ~ span 只能选中 p 之后同个父级的 span 并不能选中之前的  注释：peer不是通过 css原生伪类实现的，文档的分类具有误导     When using multiple peers, you can style something on the state of a specific peer by giving that peer a unique name using a peer/{name} class, and including that name in modifiers using classes like peer-checked/{name}:\n   根据特定同级元素来设置之后元素，  用来标记需要观察的同级元素，  用来标记之后元素在同级元素处于 * 状态时的样式     You can create one-off peer-* modifiers on the fly by providing your own selector as an arbitrary value between square brackets:\n   可以在 pree-   的方括号内传入任意选择器来指定特定的同级元素  注释：pree-   和 pree-* 可以同时使用，应该和 peer-*/{name} 也能同时使用，group 应该也一样     For more control, you can use the & character to mark where .peer should end up in the final selector relative to the selector you are passing in:\n   & 用来作为 .peer 的占位符，空格用 _ 代替，  最终被解析为      Arbitrary variants are just format strings that represent the selector, wrapped in square brackets. For example, this arbitrary modifier selects an element only when it is the third child:\n   可以使用    定义任意的选择器   Arbitrary variants can be stacked with built-in modifiers or with each other, just like the rest of the modifiers in Tailwind:\n   []可以和其他内置类名共同使用   You can also use at-rules like @media or @supports in arbitrary variants:\n   可以在  中使用 @media or @supports   You can even combine at-rules and regular selector modifiers by including the selector modifier within curly braces after the at-rule:\n   在    可以使用 {} 包含选择器，例如：    当前设备有输入机制可以实现 hover 效果  If you find yourself using the same arbitrary modifier multiple times in your project, it might be worth extracting it to a plugin using the addVariant API:\n可以把    定义的任意选择器配置为插件     All of Tailwind’s modifiers are available to use with your own custom classes as long as you’ve defined them in one of Tailwind’s layers or added them using a plugin:\n   所有修饰符都可以和自定义类一起使用     For the most part this doesn’t actually matter, but there are a few situations where the order you use actually generates meaningfully different CSS.\n   修饰符的绑定顺序会导致结果的不同  dark: 在 tailwind 中可选择实现方法，一种是通过 @media 另一种是通过 html 中添加 .dark，当以 class 方式实现时，第二种顺序会导致错误     For example, if you have darkMode configured to class, combining the dark and group-hover modifiers generates a different result depending on the order you use:\n   例如：使用 prose-headings 时需要注意顺序  prose-headings 是官方插件中提供的修饰符，会影响 h1, h2, h3, h4, th 这些元素的样式，你可以在它后面加上任何 Tailwind 的工具类，来改变标题的字体、颜色、大小、对齐等属性   () 是 CSS 中的一个伪类函数，它可以接受一个选择器列表作为参数，并选择该列表中任何一个选择器可以选择的元素。这对于以更紧凑的形式编写复杂的选择器非常有用。    和    的功能一样，但是 is 匹配中的化等于静态选择器的优先级，而 where 匹配中的化只等于其余选择器的优先级，例如：  的优先级只计算   注释：伪类会修饰随后的实体，如果没有则修饰自身，例如：  这里的  修饰的是     Responsive Design 响应式设计   What this means is that unprefixed utilities (like uppercase) take effect on all screen sizes, while prefixed utilities (like md:uppercase) only take effect at the specified breakpoint and above.\n   移动优先，不带前缀所有尺寸适用，加了前缀，指定断点及以上适用  If you’d like to apply a utility only when a specific breakpoint range is active, stack a responsive modifier like md with a max-* modifier to limit that style to a specific range:\n   可以堆叠断点以设置一个区间类使用的样式   You can completely customize your breakpoints in your tailwind.config.js file:\n   可以自定义断点     If you need to use a one-off breakpoint that doesn’t make sense to include in your theme, use the min or max modifiers to generate a custom breakpoint on the fly using any arbitrary value.\n   可以使用  自定义断点    Dark Mode 暗黑模式   If you want to support toggling dark mode manually instead of relying on the operating system preference, use the class strategy instead of the media strategy:\n   如果要手动切换暗黑模式，需要使用 class 实现方式  Window 的 matchMedia() 方法返回一个新的 MediaQueryList 对象，表示指定的媒体查询字符串解析后的结果。返回的 MediaQueryList 可被用于判定 Document 是否匹配媒体查询，或者监控一个 document 来判定它匹配了或者停止匹配了此媒体查询。  You can customize the dark mode selector name by setting darkMode to an array with your custom selector as the second item:\n   'class'表示使用类（class）策略来切换暗黑模式，也就是说，当HTML元素上存在dark类时，就会启用暗黑模式。  '  data-mode=\"dark\" '表示使用自定义的属性选择器来切换暗黑模式，也就是说，当HTML元素上存在data-mode=\"dark\"属性时，就会启用暗黑模式。    Reusing Styles 重用样式   不建议这么做  While it’s highly recommended that you create proper template partials for more complex components, you can use Tailwind’s @apply directive to extract repeated utility patterns to custom CSS classes when a template partial feels heavy-handed.\n   使用 @apply 将实用程序类整合成重用样式     If you’re going to use @apply, use it for very small, highly reusable things like buttons and form controls — and even then only if you’re not using a framework like React where a component would be a better choice.\n   只有当只有单个 html 标签时才尝试使用 @apply 整合重用样式，其他情况组件会是更好的选择  Adding Custom Styles 添加自定义样式     When you find yourself really needing something like top: 117px to get a background image in just the right spot, use Tailwind’s square bracket notation to generate a class on the fly with any arbitrary value:\n   可以使用    来突破 Tailwind 给出的限定值     This is basically like inline styles, with the major benefit that you can combine it with interactive modifiers like hover and responsive modifiers like lg:\n   [] 可以和装饰符一起实用     It’s even possible to use the theme function to reference the design tokens in your tailwind.config.js file:\n   在    中可以使用 theme 函数应用 配置 中定义的变量  fit-content(max-content)是一个CSS属性，它可以用来调整元素的大小，使其适应内容的尺寸。\n   这意味着盒子会使用可用的空间，但永远不会超过max-content。  当fit-content用于设置元素的width、height、min-width、min-height、max-width和max-height时，最大和最小尺寸将基于元素的内容尺寸计算     When using a CSS variable as an arbitrary value, wrapping your variable in var(...) isn’t needed — just providing the actual variable name is enough:\n   当使用 css 原生变量时不需要使用 var() 包裹，只需要直接使用变量名     If you ever need to use a CSS property that Tailwind doesn’t include a utility for out of the box, you can also use square bracket notation to write completely arbitrary CSS:\n   [] 同样可以用来，完全自定义 css  This is really like inline styles, but again with the benefit that you can use modifiers:\n   依然可以使用修饰符  mask-type:luminance是一个CSS属性，它表示SVG   元素是用作亮度掩码还是alpha掩码。\n   掩码是一串二进制代码，用于对目标字段进行位与运算，屏蔽或选择当前的输入位。  alpha掩码是一种CSS属性，它可以用来指定一个颜色的透明度或不透明度。  div 元素可以使用 mask-type 属性，但是需要满足以下条件：\n   div 元素必须有一个 mask-image 属性，用于指定遮罩图片的路径。   遮罩图片必须是一个 SVG 图形，且包含一个 id 属性，用于在 mask-image 中引用。     This can be useful for things like CSS variables as well, especially when they need to change under different conditions:\n   还可以用来修改css原生变量的值     Arbitrary variants are like arbitrary values but for doing on-the-fly selector modification, like you can with built-in pseudo-class variants like hover:{utility} or responsive variants like md:{utility} but using square bracket notation directly in your HTML.\n   []和：配合使用还可以用来实现任意变体     In situations where underscores are common but spaces are invalid, Tailwind will preserve the underscore instead of converting it to a space, for example in URLs:\n   在  中并不是所有_都表示空格，在 空格 无效的情况下_保持原样，例如在url()中     In the rare case that you actually need to use an underscore but it’s ambiguous because a space is valid as well, escape the underscore with a backslash and Tailwind won’t convert it to a space:\n   当明确不转换_为空格的地方可以使用\\标识     If you’re using something like JSX where the backslash is stripped from the rendered HTML, use String.raw() so the backslash isn’t treated as a JavaScript escape character:\n   在 jsx 中    会被编译为   ，这和 tailwind 生成的 css 类名就会有出入导致样式无效，使用 String.raw() 包裹这个类名来解决  String.raw() 用来处理模板字符串，会计算插值的结果并获取HTML转义序列中的字符的原始字符串形式，例如      Many utilities in Tailwind share a common namespace but map to different CSS properties. For example text-lg and text-black both share the text- namespace, but one is for font-size and the other is for color.\n   当使用  作为任意属性时会面临命名空间的问题  When using arbitrary values, Tailwind can generally handle this ambiguity automatically based on the value you pass in:\n   一般 tailwind 会根据传入值来自动判断In these situations, you can “hint” the underlying type to Tailwind by adding a CSS data type before the value:\n     当参数是个变量时无法进行自动判断，可以在参数前添加  css数据类型 来进行区别For more power, you can also use the @layer directive to add styles to Tailwind’s base, components, and utilities layers:\n   可以使用 @layer 把自定义样式添加到 base, components, and utilities 中  components 是一些预定义的组件样式，用于创建一些常见的 UI 元素，例如按钮，卡片，表单等。utilities 是一些功能性的样式，用于控制一些细节的样式属性，例如颜色，边框，定位，布局等。  utilities 中定义得类的优先级应该高于其他  The @layer directive helps you control declaration order by automatically relocating your styles to the corresponding @tailwind directive, and also enables features like modifiers and tree-shaking for your own custom CSS.\n   自定义的类能够和修饰符一起使用，会被按顺序归纳到各自分类中保证优先级，并且如果没有使用会从最终打包结果中树摇掉Use the theme function or @apply directive when adding custom base styles if you want to refer to any of the values defined in your theme.\n   如果要引用主题中定义的值可以使用 @apply 和 themeIf you want to add some custom CSS that should always be included, add it to your stylesheet without using the @layer directive:\n   没有使用 @layer 的类不会被树摇掉  Make sure to put your custom styles where they need to go to get the precedence behavior you want. In the example above, we’ve added the .card class before @tailwind utilities to make sure utilities can still override it.\n   需要注意没有使用 @layer 的类的引用顺序，建议如下，保证 utilities 类型的优先级最高","level":1},{"id":"/notes/css/css-backdrop-filter#css-背景模糊毛玻璃效果-backdrop-filter","title":"CSS 背景模糊（毛玻璃效果） backdrop-  filter","titles":[],"content":"毛玻璃效果","level":1},{"id":"/notes/css/css-backdrop-filter#效果图","title":"效果图","titles":["CSS 背景模糊（毛玻璃效果） backdrop-  filter"],"content":"","level":2},{"id":"/notes/css/css-backdrop-filter#效果图-1","title":"效果图","titles":["CSS 背景模糊（毛玻璃效果） backdrop-  filter","效果图"],"content":"","level":3},{"id":"/notes/css/css-backdrop-filter#毛玻璃效果","title":"毛玻璃效果","titles":["CSS 背景模糊（毛玻璃效果） backdrop-  filter","效果图","效果图"],"content":"","level":4},{"id":"/notes/css/css-backdrop-filter#代码","title":"代码","titles":["CSS 背景模糊（毛玻璃效果） backdrop-  filter"],"content":"","level":2},{"id":"/notes/css/css-backdrop-filter#tailwindcss","title":"TailwindCSS","titles":["CSS 背景模糊（毛玻璃效果） backdrop-  filter"],"content":"backdrop-blur-*","level":2},{"id":"/notes/css/css-backdrop-filter#代码-1","title":"代码","titles":["CSS 背景模糊（毛玻璃效果） backdrop-  filter","TailwindCSS"],"content":"","level":3},{"id":"/notes/css/flex-layout#flex-排版","title":"flex 排版","titles":[],"content":"","level":1},{"id":"/notes/css/flex-layout#flex-flow","title":"flex-flow","titles":["flex 排版"],"content":"复合属性。flex-direction flex-wrap","level":2},{"id":"/notes/css/flex-layout#flex-direction","title":"flex-direction","titles":["flex 排版"],"content":"该属性通过定义 flex 容器的主轴方向来决定 felx 子项在 flex 容器中的位置。  默认值：row  属性值：\n   row：从左到右为主轴  row-reverse：从右到做为主轴  column：从上到下为主轴  column-reverse：从下到上为主轴","level":2},{"id":"/notes/css/flex-layout#flex-wrap","title":"flex-wrap","titles":["flex 排版"],"content":"该属性控制flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。  默认值：nowrap  属性值：\n   nowrap：单行  wrap：多行，副轴从上到下  wrap-reverse：多行，副轴从下到上","level":2},{"id":"/notes/css/flex-layout#justify-content","title":"justify-content","titles":["flex 排版"],"content":"设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。  默认值：\n   flex-start：行内的项目集中在行的开始位置  flex-end：行内的项目集中在行的结束位置  center：行内的项目集中在行的中间位置  space-between：行内的项目，第一列在开始位置，最后一列在结束位置，其他都在中间位置  space-around：行内的项目，每一列都在中间位置","level":2},{"id":"/notes/css/flex-layout#align-items","title":"align-items","titles":["flex 排版"],"content":"定义 flex 子项在 flex 容器的当前行的侧轴（纵轴）方向上的对齐方式。  默认值：stretch  属性值：\n   stretch：行内的项目占满整行  center：行内的项目位于该行的正中，不再占满整行  flex-start：行内的项目位于该行的开始，不再占满整行  flex-end：行内的项目位于该行的结尾，不再占满整行  baseline：行内的项目位于该行的基线（好像就是开始位置），不再占满整行","level":2},{"id":"/notes/css/flex-layout#align-content","title":"align-content","titles":["flex 排版"],"content":"行和行之间的位置关系，除了stretch其他都要求行有固定高度  默认值：stretch  属性值：\n   center:所有行集中在中间，  flex-start：所有行集中在开始位置  flex-end：所有行集中在结束位置  stretch：每一行的项占满整行的空间  space-between:第一行内的项目在开始位置，最后一行内的项目在结束位置，其他行内的项目都在中间位置  space-around：所有行内的项目都在中间位置","level":2},{"id":"/notes/css/flex-layout#子元素","title":"子元素","titles":[],"content":"","level":1},{"id":"/notes/css/flex-layout#flex","title":"flex","titles":["子元素"],"content":"复合属性flex-grow、flex-shrink、flex-basis","level":2},{"id":"/notes/css/flex-layout#flex-grow","title":"flex-grow","titles":["子元素"],"content":"设置或检索弹性盒的扩展比率。  默认值：0  属性值:number","level":2},{"id":"/notes/css/flex-layout#flex-shrink","title":"flex-shrink","titles":["子元素"],"content":"设置或检索弹性盒的收缩比率。  默认值：1  属性值：number","level":2},{"id":"/notes/css/flex-layout#flex-basis","title":"flex-basis","titles":["子元素"],"content":"设置或检索弹性盒伸缩基准值。  默认值：auton  属性值：\n   一个长度单位或百分比  auto  注释：即使设置为确定的长度单位，当元素内容溢出时，该元素依然会被扩展已保证内部元素被正确显示","level":2},{"id":"/notes/css/flex-layout#align-self","title":"align-self","titles":["子元素"],"content":"定义 flex 子项单独在侧轴（纵轴）方向上的对齐方式。  默认值：auot  属性值：\n   stretch：该项目占满整行  center：该项目位于该行的正中，不再占满整行  flex-start：该项目位于该行的开始，不再占满整行  flex-end：该项目位于该行的结尾，不再占满整行  baseline：该项目位于该行的基线（好像就是开始位置），不再占满整行","level":2},{"id":"/notes/css/flex-layout#order","title":"order","titles":["子元素"],"content":"设置或检索弹性盒模型对象的子元素出现的順序  默认值：0  属性值：number","level":2},{"id":"/notes/css/name#一些建议的-css-类命名规范","title":"一些建议的 CSS 类命名规范","titles":[],"content":"在为网站命名 CSS 类时，建议遵循一些最佳实践，以确保清晰、一致和易于维护。以下是一些建议的 CSS 类命名规范：使用有意义的名称 ：选择能准确描述所样式化元素用途或内容的类名。避免使用模糊的通用名称，如“box”或“content”。   使用 BEM 方法论 ：考虑使用块元素修饰符（Block Element Modifier，BEM）方法论来命名类。这有助于为 CSS 类创建清晰和结构化的命名约定。   保持一致性 ：在整个项目中保持命名约定的一致性，以便更容易理解和维护代码库。   避免表现性名称 ：避免根据视觉样式或表现方面命名类。而是专注于元素的目的或功能。   使用连字符分隔多词名称 ：使用连字符来分隔类名中的单词，以提高可读性（例如  、  ）。   简洁且描述性 ：力求类名简洁，同时又能清楚描述其目的，避免过于冗长。   避免缩写 ：尽管短名称很好，但避免过度缩写，以免对他人或未来自己不清晰。   语义化命名 ：考虑使用反映元素内容或结构的语义类名，以便更容易理解 HTML 结构。   避免内联样式 ：尽量避免内联样式，使用类来进行样式设置，以分离结构（HTML）、表现（CSS）和行为（JavaScript）。遵循这些建议，您可以为网站创建一个结构良好、易于维护的 CSS 代码库。针对名称如 \"layout\", \"header\", \"banner\", \"sider\"，以下是一些建议的中文 CSS 类命名：布局（layout） ：  、  、  、    页眉（header） ：  、  、  、    横幅（banner） ：  、  、  、    侧边栏（sider） ：  、  、  、这些类名旨在描述元素的用途或内容，同时保持简洁和易于理解。您可以根据具体情况选择适合您项目的类名。如果命名难受，何不尝试一下   Tailwind CssTailwind CSS 的工作原理是扫描所有 HTML 文件、JavaScript 组件和任何其他类名称模板，生成相应的样式，然后将它们写入静态 CSS 文件。它快速、灵活且可靠 — 具有零运行时间。","level":1},{"id":"/notes/css/selector/index1#css-选择器","title":"CSS 选择器","titles":[],"content":"CSS 选择器用于选择要样式化的 HTML 元素。以下是一些常见的 CSS 选择器：","level":1},{"id":"/notes/css/selector/index1#_1-元素选择器","title":"1.    元素选择器","titles":["CSS 选择器"],"content":"通过元素名称选择元素。","level":2},{"id":"/notes/css/selector/index1#_2-类选择器","title":"2.    类选择器","titles":["CSS 选择器"],"content":"通过类名选择元素。","level":2},{"id":"/notes/css/selector/index1#_3-id-选择器","title":"3.    ID 选择器","titles":["CSS 选择器"],"content":"通过 ID 选择元素。","level":2},{"id":"/notes/css/selector/index1#_4-后代选择器","title":"4.    后代选择器","titles":["CSS 选择器"],"content":"选择嵌套在另一个元素内部的元素。","level":2},{"id":"/notes/css/selector/index1#_5-子元素选择器","title":"5.    子元素选择器","titles":["CSS 选择器"],"content":"选择作为另一个元素的直接子元素的元素。","level":2},{"id":"/notes/css/selector/index1#_6-属性选择器","title":"6.    属性选择器","titles":["CSS 选择器"],"content":"根据元素的属性值选择元素。","level":2},{"id":"/notes/css/selector/index1#_7-伪类选择器","title":"7.    伪类选择器","titles":["CSS 选择器"],"content":"根据元素的状态或位置选择元素。这些是一些常见的 CSS 选择器，可以帮助您精确地选择和样式化 HTML 元素。","level":2},{"id":"/notes/css/selector/index1#好-css-选择器","title":"好 CSS 选择器","titles":["CSS 选择器"],"content":"要学好 CSS 选择器并熟练应用它们，可以遵循以下建议：理解基本选择器 ：从元素选择器、类选择器和 ID 选择器开始学习。掌握这些基本选择器是建立更复杂选择器的基础。   学习组合选择器 ：了解如何结合使用选择器，如后代选择器、子元素选择器和相邻兄弟选择器，以便更精确地定位目标元素。   掌握属性选择器 ：学习如何使用属性选择器根据元素的属性值选择元素，这对于样式化特定类型的元素很有用。   熟悉伪类和伪元素 ：了解伪类和伪元素的用法，如  、  和  、  ，以实现更丰富的样式效果。   练习实践 ：通过练习编写 CSS 样式表并应用各种选择器，加深对选择器的理解和熟练度。   阅读文档和教程 ：查阅 CSS 选择器的官方文档和在线教程，了解更多选择器的用法和示例。   参考示例和项目 ：阅读其他人的 CSS 代码，参与开源项目或构建自己的项目，从中学习不同选择器的实际应用。   尝试挑战 ：参加 CSS 选择器挑战或练习，如编写特定样式效果的代码，以提升技能和创造力。   保持更新 ：随着 CSS 的发展，了解新的选择器和技术，保持学习和实践的态度。通过持续练习、阅读文档和参与项目，您将逐渐掌握各种 CSS 选择器的用法，并能够熟练地应用它们来创建各种样式效果。","level":2},{"id":"/notes/css/selector/element#元素选择器","title":"元素选择器","titles":[],"content":"","level":1},{"id":"/notes/css/selector/element#示例","title":"示例：","titles":["元素选择器"],"content":"单个元素选择器 ：    这个选择器会选择所有    元素，并将它们的文本颜色设置为蓝色。   多个元素选择器 ：    这个选择器会选择所有   ,   ,    元素，并将它们的字体设置为Arial或sans-serif。","level":3},{"id":"/notes/css/selector/element#组合选择器示例","title":"组合选择器示例：","titles":["元素选择器"],"content":"后代选择器 ：    这个选择器会选择所有在    元素内部的    元素，并将它们的字体加粗。   子元素选择器 ：    这个选择器会选择所有作为    元素直接子元素的    元素，并将它们的列表样式设置为方块。","level":3},{"id":"/notes/css/selector/element#注意事项","title":"注意事项：","titles":["元素选择器"],"content":"使用元素选择器和组合选择器时，要注意选择器的特定性，以避免样式冲突和意外覆盖。  组合选择器可以帮助您更精确地选择目标元素，但要谨慎使用，以避免选择器过于复杂和难以维护。","level":3},{"id":"/notes/css/selector/element#浏览器支持情况","title":"浏览器支持情况：","titles":["元素选择器"],"content":"元素选择器和组合选择器是CSS的基本功能，几乎所有现代浏览器都支持它们。以下是一些常见浏览器对这些选择器的支持情况：Chrome：支持  Firefox：支持  Safari：支持  Edge：支持  Internet Explorer：支持由于这些选择器是CSS的基本功能，几乎所有浏览器都能正确解析和应用它们。","level":3},{"id":"/notes/css/selector/class#类选择器","title":"类选择器","titles":[],"content":"它选择具有指定类的元素。类选择器以点（  ）开头。","level":1},{"id":"/notes/css/selector/class#类选择器示例","title":"类选择器示例：","titles":["类选择器"],"content":"单个类选择器 ：    这个选择器会选择所有具有    类的元素，并将它们的背景颜色设置为黄色。   多个类选择器 ：    这个选择器会选择所有具有    或    类的元素，并将它们的文本颜色设置为白色。","level":3},{"id":"/notes/css/selector/class#组合选择器示例","title":"组合选择器示例：","titles":["类选择器"],"content":"类选择器与元素选择器组合 ：    这个选择器会选择所有    元素且具有    类的元素，并将它们的背景颜色设置为蓝色。   类选择器与伪类组合 ：    这个选择器会选择所有具有    类的元素在鼠标悬停时添加下划线。","level":3},{"id":"/notes/css/selector/class#注意事项","title":"注意事项：","titles":["类选择器"],"content":"类选择器以  开头，用于选择具有特定类的元素，可以为元素添加多个类。  组合选择器可以帮助您更精确地选择目标元素，但要注意选择器的特定性，以避免样式冲突和意外覆盖。","level":3},{"id":"/notes/css/selector/class#浏览器支持情况","title":"浏览器支持情况：","titles":["类选择器"],"content":"类选择器和组合选择器是CSS的基本功能，几乎所有现代浏览器都支持它们。以下是一些常见浏览器对这些选择器的支持情况：Chrome：支持  Firefox：支持  Safari：支持  Edge：支持  Internet Explorer：支持由于这些选择器是CSS的基本功能，几乎所有浏览器都能正确解析和应用它们。","level":3},{"id":"/notes/css/selector/id#元素选择器","title":"元素选择器","titles":[],"content":"","level":1},{"id":"/notes/css/selector/id#id选择器示例","title":"ID选择器示例：","titles":["元素选择器"],"content":"单个ID选择器 ：    这个选择器会选择具有    ID 的元素，并将它们的背景颜色设置为浅灰色。   多个ID选择器 （不推荐，ID应该是唯一的）：    这个选择器会选择具有    或    ID 的元素，并为它们添加黑色边框。","level":3},{"id":"/notes/css/selector/id#组合选择器示例","title":"组合选择器示例：","titles":["元素选择器"],"content":"ID选择器与元素选择器组合 ：    这个选择器会选择具有    ID 的元素内部的    元素，并移除其默认列表样式。   ID选择器与类选择器组合 ：    这个选择器会选择具有    ID 内部的具有    类的元素，并将它们的文本颜色设置为红色。","level":3},{"id":"/notes/css/selector/id#注意事项","title":"注意事项：","titles":["元素选择器"],"content":"ID选择器以  开头，用于选择具有特定ID的元素，每个页面中ID应该是唯一的。  避免在CSS中过度使用ID选择器，因为它们的特定性很高，可能会导致样式冲突和难以维护的代码。","level":3},{"id":"/notes/css/selector/id#浏览器支持情况","title":"浏览器支持情况：","titles":["元素选择器"],"content":"ID选择器和组合选择器是CSS的基本功能，几乎所有现代浏览器都支持它们。以下是一些常见浏览器对这些选择器的支持情况：Chrome：支持  Firefox：支持  Safari：支持  Edge：支持  Internet Explorer：支持由于这些选择器是CSS的基本功能，几乎所有浏览器都能正确解析和应用它们。","level":3},{"id":"/notes/css/selector/descendant#后代选择器","title":"后代选择器","titles":[],"content":"","level":1},{"id":"/notes/css/selector/descendant#示例","title":"示例：","titles":["后代选择器"],"content":"基本后代选择器 ：    这个选择器会选择所有在    元素内部的    元素，并将它们的文本颜色设置为蓝色。   多层后代选择器 ：    这个选择器会选择所有在类为    的元素内部的    元素内部的    元素，并将它们的字体加粗。","level":3},{"id":"/notes/css/selector/descendant#组合选择器示例","title":"组合选择器示例：","titles":["后代选择器"],"content":"后代选择器与类选择器组合 ：    这个选择器会选择所有作为类为    的    元素的直接子元素中具有    类的    元素，并将它们的背景颜色设置为黄色。   后代选择器与伪类组合 ：    这个选择器会选择所有在    元素内部的第一个    元素，并将它们的字体加粗。","level":3},{"id":"/notes/css/selector/descendant#注意事项","title":"注意事项：","titles":["后代选择器"],"content":"后代选择器用于选择嵌套在其他元素内部的元素，可以通过多层嵌套来选择更具体的元素。  组合选择器可以帮助您更精确地选择目标元素，但要注意选择器的特定性，以避免样式冲突和意外覆盖。","level":3},{"id":"/notes/css/selector/descendant#复杂的应用场景","title":"复杂的应用场景：","titles":["后代选择器"],"content":"一个复杂的应用场景可能涉及多个层次的嵌套和选择器组合，例如选择特定类型的表格中的单元格，并对其进行样式化。这种情况下，您可以结合使用后代选择器、类选择器和伪类选择器来实现所需的样式效果。例如：这个选择器会选择自定义表格中偶数行的具有    类的单元格，并将它们的背景颜色设置为浅灰色，文本颜色设置为蓝色。在复杂的应用场景中，合理使用后代选择器和组合选择器可以帮助您精确地定位目标元素并应用所需的样式。","level":3},{"id":"/notes/css/selector/child#子选择器","title":"子选择器","titles":[],"content":"","level":1},{"id":"/notes/css/selector/child#子选择器示例","title":"子选择器示例：","titles":["子选择器"],"content":"子元素选择器 ：    这个选择器会选择所有作为    元素直接子元素的    元素，并将它们的列表样式设置为方块。   子选择器与类选择器组合 ：    这个选择器会选择所有作为    元素直接子元素且具有    类的元素，并将它们的字体加粗。","level":3},{"id":"/notes/css/selector/child#组合选择器示例","title":"组合选择器示例：","titles":["子选择器"],"content":"子选择器与伪类组合 ：    这个选择器会选择所有作为    元素直接子元素中的第一个    元素，并将它的字体加粗。   子选择器与后代选择器组合 ：    这个选择器会选择所有作为    元素直接子元素内的    元素，并将它们的文本颜色设置为红色。","level":3},{"id":"/notes/css/selector/child#注意事项","title":"注意事项：","titles":["子选择器"],"content":"子选择器（  ）用于选择作为指定元素的直接子元素，而不是后代元素。  组合选择器可以帮助您更精确地选择目标元素，但要注意选择器的特定性，以避免样式冲突和意外覆盖。","level":3},{"id":"/notes/css/selector/child#浏览器支持情况","title":"浏览器支持情况：","titles":["子选择器"],"content":"子选择器和组合选择器是CSS的基本功能，几乎所有现代浏览器都支持它们。以下是一些常见浏览器对这些选择器的支持情况：Chrome：支持  Firefox：支持  Safari：支持  Edge：支持  Internet Explorer：支持由于这些选择器是CSS的基本功能，几乎所有浏览器都能正确解析和应用它们。","level":3},{"id":"/notes/css/selector/property#属性选择器","title":"属性选择器","titles":[],"content":"","level":1},{"id":"/notes/css/selector/property#示例","title":"示例：","titles":["属性选择器"],"content":"存在属性选择器 ：    这个选择器会选择所有具有    属性的    元素，并将它们的边框设置为灰色。   属性值选择器 ：    这个选择器会选择所有    属性值为    的    元素，并将它们的文本颜色设置为蓝色。","level":3},{"id":"/notes/css/selector/property#组合选择器示例","title":"组合选择器示例：","titles":["属性选择器"],"content":"属性选择器与类选择器组合 ：    这个选择器会选择所有    属性值为    且具有    类的    元素，并将它们的边框颜色设置为红色。   属性选择器与伪类组合 ：    这个选择器会选择所有    属性值以    开头的    元素，在鼠标悬停时添加下划线。","level":3},{"id":"/notes/css/selector/property#注意事项","title":"注意事项：","titles":["属性选择器"],"content":"属性选择器用于根据元素的属性值选择元素，可以根据属性的存在、值的匹配等条件进行选择。  组合选择器可以帮助您更精确地选择目标元素，但要注意选择器的特定性，以避免样式冲突和意外覆盖。","level":3},{"id":"/notes/css/selector/property#复杂的应用场景","title":"复杂的应用场景：","titles":["属性选择器"],"content":"一个复杂的应用场景是根据不同属性值为元素应用不同的样式，例如根据不同的链接类型为链接添加不同的样式：这个示例会根据链接的协议类型为链接元素应用不同的文本颜色，使用户能够快速识别链接的类型。在实际开发中，属性选择器和组合选择器可以帮助您根据元素的属性值和其他条件选择目标元素，并为其应用特定的样式，从而实现更灵活和精确的样式控制。","level":3},{"id":"/notes/css/selector/pseudo-class#伪类选择器","title":"伪类选择器","titles":[],"content":"以下是一些常用的CSS伪类选择器：：鼠标悬停在元素上时应用样式。    ：元素被激活时（例如被点击）应用样式。    ：元素获得焦点时应用样式。    ：已访问链接的样式。    ：选择父元素的第一个子元素。    ：选择父元素的最后一个子元素。    ：选择父元素的指定位置的子元素。    ：选择父元素的指定类型的子元素。    ：选择不匹配指定选择器的元素。    ：选择没有子元素的空元素。    ：选择被选中的表单元素。    ：选择被禁用的表单元素。    ：选择必填字段的表单元素。    ：选择通过验证的表单元素。    ：选择未通过验证的表单元素。这些伪类选择器可以帮助您根据元素的状态、位置或属性选择特定的元素，并为其应用样式。通过灵活运用这些伪类选择器，可以实现丰富多彩的样式效果和交互体验。","level":1},{"id":"/notes/css/selector/pseudo-class#伪类选择器示例","title":"伪类选择器示例：","titles":["伪类选择器"],"content":"伪类 ：    这个选择器会选择所有鼠标悬停在    元素上的情况，并为它们添加下划线。     伪类 ：    这个选择器会选择每个    元素中的奇数项，并将它们的背景颜色设置为浅灰色。","level":3},{"id":"/notes/css/selector/pseudo-class#组合选择器示例","title":"组合选择器示例：","titles":["伪类选择器"],"content":"类选择器与伪类组合 ：    这个选择器会选择所有具有    类的元素在鼠标悬停时将背景颜色设置为浅蓝色。   元素选择器与伪类组合 ：    这个选择器会选择每个    元素中的第一个    元素，并将它们的字体加粗。","level":3},{"id":"/notes/css/selector/pseudo-class#注意事项","title":"注意事项：","titles":["伪类选择器"],"content":"伪类选择器用于选择元素的特定状态或位置，如鼠标悬停、第一个子元素等。  组合选择器可以结合不同类型的选择器，以实现更精确的样式控制。","level":3},{"id":"/notes/css/selector/pseudo-class#复杂的应用场景","title":"复杂的应用场景：","titles":["伪类选择器"],"content":"一个复杂的应用场景是创建响应式设计，其中可以结合使用伪类选择器和媒体查询来根据不同设备的屏幕尺寸和方向应用不同的样式。例如：在这个示例中，当屏幕宽度小于768px时，隐藏菜单（  ）并显示菜单切换按钮（  ），以实现响应式设计。这种复杂的应用场景需要结合多种选择器和媒体查询来实现特定的样式效果。","level":3},{"id":"/notes/css/selector/pseudo/hover#hover-类","title":":hover 类","titles":[],"content":"","level":1},{"id":"/notes/css/tailwind/nuxt-tailwindcss#nuxt-中使用-tailwindcss","title":"Nuxt 中使用 tailwindcss","titles":[],"content":"","level":1},{"id":"/notes/css/tailwind/nuxt-tailwindcss#nuxt-中使用-tailwindcss-1","title":"Nuxt 中使用 tailwindcss","titles":["Nuxt 中使用 tailwindcss"],"content":"","level":2},{"id":"/notes/css/tailwind/nuxt-tailwindcss#安装","title":"安装","titles":["Nuxt 中使用 tailwindcss"],"content":"将依赖项安装  到您的项目中：如果尚未完成，请将其添加到您的  部分  ：就这样！你现在可以在 Nuxt 应用中使用 Tailwind 类了 ✨使用Tailwind 查看器 根据您的 Tailwind 配置发现您的调色板。","level":2},{"id":"/notes/css/tailwind/nuxt-tailwindcss#visual-studio-code-的扩展","title":"Visual Studio Code 的扩展","titles":["Nuxt 中使用 tailwindcss"],"content":"Tailwind 提供了  Visual Studio Code 的扩展 ，它提供了自动完成、语法突出显示和 linting 等高级功能。您可以  通过 Visual Studio Code Marketplace 安装它 。将以下配置添加到您的  文件中，以便 Tailwind 指令具有正确的自动完成、语法突出显示和 linting：.vscode/settings.json如果您使用 pnpm，请确保 tailwindcss 安装在您的顶层 node_modules 文件夹中。","level":2},{"id":"/notes/css/tailwind/nuxt-tailwindcss#字符串类自动完成","title":"字符串类自动完成","titles":["Nuxt 中使用 tailwindcss"],"content":"使用 Tailwind 类的字符串时，您可以使用选项启用 IntelliSense 建议。您必须添加以下 VSCode 设置：.vscode/settings.json添加后，可以按如下方式使用新的实用程序函数，在编写 Tailwind 类时提供 IntelliSense 建议：索引.vue","level":2},{"id":"/notes/css/tailwind/nuxt-tailwindcss#配置智能感知","title":"配置智能感知","titles":["Nuxt 中使用 tailwindcss"],"content":"自 Tailwind CSS v3.3 以来，  ESM/TS 配置已得到支持， 因此您的编辑器应根据您的配置自动配置自动完成  。如果您有一个复杂的 Nuxt 项目，其中包含多个 Tailwind 配置，这些配置位于层内、从钩子传递或内联  ，并且想要使用合并的配置，则模块会生成它，  您可以通过添加以下 VSCode 设置来使用它：.vscode/settings.json如果您需要对 IntelliSense 扩展读取的配置进行更多自定义，则可以利用挂钩，尤其是  运行配置以提供完整配置对象的挂钩。模块/tw-cjs-config.ts这个钩子允许您通过模块以不同的方式（例如，不同的文件名、内容等）自定义生成的模板。请注意，使用  将从您的配置中删除插件。","level":2},{"id":"/notes/css/tailwind/override-prose#tailwind-css-override-prose重写prose","title":"tailwind css override prose(重写prose)","titles":[],"content":"Tailwind CSS 的 Prose 类是用于快速创建排版样式的一种类。如果您想修改这些样式以适应您的项目需求，可以使用 Tailwind CSS 的自定义功能来实现。首先，您需要在    文件中将    类的样式定义提取出来，然后对这些样式进行修改。您可以使用    指令将您的样式应用到    类上。以下是一个示例：然后，您可以在自己的 CSS 文件中定义要覆盖 Prose 类中的样式，然后使用    指令将其应用到    类上。以下是一个示例：在这个示例中，我们创建了一个名为    的新类，用于修改 Prose 类中的样式。然后，我们将    类应用到    类上，以覆盖默认的样式。","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#归纳","title":"归纳","titles":[],"content":"","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#修饰符堆叠","title":"修饰符堆叠","titles":["归纳"],"content":"以下为修饰符","level":2},{"id":"/notes/css/tailwind/tailwindcss-1#伪类伪元素","title":"伪类伪元素","titles":["归纳"],"content":"使用方法：\n   在实用程序类前添加   伪类\n   hover  focus  focus-within 用来选择和样式化一个元素或者它的任何后代元素获得焦点的情况  focus-visible 用来选择和样式化一个元素或者它的任何后代元素获得焦点的情况，用非指针方法获得焦点时  active 伪类选择器是用来选择和样式化被激活的元素，比如被点击的链接或按钮  visited 用来选择和样式化用户已经访问过的链接  target 元素的 ID 与当前 URL 片段匹配  first 如果元素是第一个使用修饰符的子元素  last 如果元素是最后一个使用修饰符的子元素  only 如果元素是唯一使用修饰符的子元素  odd 如果元素是奇数编号的子元素  even 如果元素是偶数编号的子元素  first-of-type 如果元素是其类型的第一个子元素  last-of-type 如果元素是其类型的最后一个子元素  only-of-type 如果元素是其类型中唯一的子元素  empty 如果元素没有内容  disabled 在禁用输入时设置输入样式  enabled 在元素未禁用时应用另一种样式时  checked 选中复选框或单选按钮时  indeterminate 不确定状态的复选框或单选按钮的样式  default 这些选项、复选框或单选按钮是最初使用修饰符加载页面时的默认值  required 可以选择和样式化任何带有required属性的  、  或  元素  valid 输入有效时的样式  invalid 输入无效时的样式  in-range 当输入的值在指定的范围限制内时  out-of-range 当输入的值超出指定范围限制时  placeholder-shown 显示占位符时设置输入样式  autofill 自动填充输入时，用户未编辑过  read-only 在输入为只读时  伪元素\n   before 创建一个元素作为当前元素的第一个子元素  after  placeholder  file 代表 type=\"file\" 的    的按钮 ::file-selector-button  marker: 匹配当前标签下 列表的标记框（通常为一个符号或数字）。它作用在任何设置了 display: list-item 的元素或伪元素上，例如    和    元素  selection 是一个CSS伪元素选择器，它可以用来给用户选中的文本添加样式  first-line 首行  first-letter 首字  backdrop ::backdrop在任何处于全屏模式的元素下的即刻渲染的盒子（并且在所有其他在堆中的层级更低的元素之上）","level":2},{"id":"/notes/css/tailwind/tailwindcss-1#媒体查询","title":"媒体查询","titles":["归纳"],"content":"使用方法：\n   在实用程序类前添加   媒体查询\n   sm @media (min-width: 640px)  md @media (min-width: 768px)  lg @media (min-width: 1024px)  xl @media (min-width: 1280px)  2xl @media (min-width: 1536px)  min-  …  自定义 @media (min-width: …)   max-sm @media not all and (min-width: 640px)  max-md @media not all and (min-width: 768px)  max-lg @media not all and (min-width: 1024px)  max-xl @media not all and (min-width: 1280px)  max-2xl @media not all and (min-width: 1536px)  max-  …  自定义@media (max-width: …)  portrait 竖屏，@media (orientation: portrait)  landscape 横屏  dark @media (prefers-color-scheme: dark)  motion-reduce 一个CSS媒体查询，它可以用来检测用户是否在设备上启用了减少非必要动画或运动的设置  motion-safe 当用户没有设置 prefers-reduced-motion 时才添加样式  contrast-more 用户请求更多对比度时，@media (prefers-contrast: more)  print 打印样式  supports-  ...  特性查询，用来判断浏览器是否支持某些 css 特性，例如：@supports (display: grid) { ... }","level":2},{"id":"/notes/css/tailwind/tailwindcss-1#其他","title":"其他","titles":["归纳"],"content":"","level":2},{"id":"/notes/css/tailwind/tailwindcss-1#属性选择器","title":"属性选择器","titles":["归纳","其他"],"content":"aria-* 属性选择器\n       和 group 和 peer 配合使用   data-* 属性选择器\n     open 具有 open 属性的元素\n     details 和 dialog 标签具有 open 属性","level":3},{"id":"/notes/css/tailwind/tailwindcss-1#后代选择器","title":"后代选择器","titles":["归纳","其他"],"content":"ltr、rtl 不同文本展示方式下设置样式，html 中设置    才能够生效     根据父元素状态设置元素样式时，在父元素绑定group，在子元素绑定group-*来定义根据特定父元素状态来设置元素样式，在父元素绑定group/{name}，在子元素绑定group-hover/{name}来定义可以在 group-   的方括号内传入任意选择器来指定特定的父元素& 用来作为 group 的占位符，空格用 _ 代替  是  的简写https://www.tailwindcss.cn/docs/configuration","level":3},{"id":"/notes/css/tailwind/tailwindcss-1#安装略","title":"安装（略）","titles":[],"content":"","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#编辑器设置略","title":"编辑器设置（略）","titles":[],"content":"","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#using-with-preprocessors-与预处理器一起使用略","title":"Using with Preprocessors 与预处理器一起使用（略）","titles":[],"content":"","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#optimizing-for-production-针对生产进行优化略","title":"Optimizing for Production 针对生产进行优化（略）","titles":[],"content":"","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#browser-support-浏览器支持略","title":"Browser Support 浏览器支持（略）","titles":[],"content":"","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#upgrade-guide-升级指南略","title":"Upgrade Guide 升级指南（略）","titles":[],"content":"","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#utility-first-fundamentals-效用优先基础知识","title":"Utility-First Fundamentals 效用优先基础知识","titles":[],"content":"好处\n   You aren’t wasting energy inventing class names. 你不是在浪费精力发明类名\n   注释：一个自定义类有什么作用？  Your CSS stops growing 您的 CSS 停止增长  Making changes feels safer 进行更改感觉更安全\n   注释：只影响当前标签  Why not just use inline styles? 为什么不直接使用内联样式？\n   Designing with constraints.有约束的设计。\n   注释：使用 tailwindcss 的值有一定的范围，并不是可任意定义的  Responsive design 响应式设计  Hover, focus, and other states. 悬停、焦点和其他状态","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#hover-focus-and-other-states-悬停焦点和其他状态","title":"Hover, Focus, and Other States 悬停、焦点和其他状态","titles":[],"content":"Every utility class in Tailwind can be applied conditionally by adding a modifier to the beginning of the class name that describes the condition you want to target.\n   Tailwind 中的每个实用程序类都可以有条件地应用，方法是在描述要面向的条件的类名的开头添加一个修饰符。  注释：实用程序类 是指 Tailwind 提供的基础类Pseudo-classes, like   ,   ,   , and:required\n   伪类  hover  focus  focus-within 用来选择和样式化一个元素或者它的任何后代元素获得焦点的情况  focus-visible 用来选择和样式化一个元素或者它的任何后代元素获得焦点的情况，用非指针方法获得焦点时  active 伪类选择器是用来选择和样式化被激活的元素，比如被点击的链接或按钮  visited 用来选择和样式化用户已经访问过的链接  target 元素的 ID 与当前 URL 片段匹配  first 如果元素是第一个使用修饰符的子元素  last 如果元素是最后一个使用修饰符的子元素  only 如果元素是唯一使用修饰符的子元素  odd 如果元素是奇数编号的子元素  even 如果元素是偶数编号的子元素  first-of-type 如果元素是其类型的第一个子元素  last-of-type 如果元素是其类型的最后一个子元素  only-of-type 如果元素是其类型中唯一的子元素  empty 如果元素没有内容  disabled 在禁用输入时设置输入样式  enabled 在元素未禁用时应用另一种样式时  checked 选中复选框或单选按钮时  indeterminate 不确定状态的复选框或单选按钮的样式  default 这些选项、复选框或单选按钮是最初使用修饰符加载页面时的默认值  required 可以选择和样式化任何带有required属性的  、  或  元素  valid 输入有效时的样式  invalid 输入无效时的样式  in-range 当输入的值在指定的范围限制内时  out-of-range 当输入的值超出指定范围限制时  placeholder-shown 显示占位符时设置输入样式  autofill 自动填充输入时，用户未编辑过  read-only 在输入为只读时  Pseudo-elements, like ::before, ::after, ::placeholder, and ::selection\n   伪元素  before 创建一个元素作为当前元素的第一个子元素  after  Note that if you’ve disabled our preflight base styles, the content property will not be set to an empty string by default, and you will need to include content-  ''  any time you use the before and after modifiers.\n   如果没有  引入基本样式，那么 before 等为元素不会自动 content 一个空字符串，需要  手动实现  placeholder  file 代表 type=\"file\" 的    的按钮 ::file-selector-button\n   Note that Tailwind’s border reset is not applied to file input buttons. This means that to add a border to a file input button, you need to explicitly set the border-style using a class like alongside any border-width utility:file:border-solid\n    中对于边框的样式重置不会影响 file input，如果需要边框的话，需要手动设置   We’ve designed the marker modifier to be inheritable, so although you can use it directly on an    element, you can also use it on a parent to avoid repeating yourself.\n   marker: 匹配当前标签下 列表的标记框（通常为一个符号或数字）。它作用在任何设置了 display: list-item 的元素或伪元素上，例如    和    元素  注意后代选择器样式影响范围问题接上面   selection 是一个CSS伪元素选择器，它可以用来给用户选中的文本添加样式\n   We’ve designed the selection modifier to be inheritable, so you can add it anywhere in the tree and it will be applied to all descendant elements.\n   selection 可以用于给所有选中的子孙文件添加样式，  对应的 css 应该是   注释：注意后代选择器导致的影响范围不明确问题  first-line 首行  first-letter 首字  backdrop\n   ::backdrop 在任何处于全屏模式的元素下的即刻渲染的盒子（并且在所有其他在堆中的层级更低的元素之上）  注释：原生 dialog 标签就是一个全屏模式的元素，可以用这个类来修改它的容器的样式  Media and feature queries, like responsive breakpoints, dark mode, and prefers-reduced-motion   响应   媒体查询 @media：屏幕宽度、分辨率、方向\n   屏幕宽度 md、lg 等\n   sm @media (min-width: 640px)  md @media (min-width: 768px)  lg @media (min-width: 1024px)  xl @media (min-width: 1280px)  2xl @media (min-width: 1536px)  min-  …  @media (min-width: …)  max-sm @media not all and (min-width: 640px)  max-md @media not all and (min-width: 768px)  max-lg @media not all and (min-width: 1024px)  max-xl @media not all and (min-width: 1280px)  max-2xl @media not all and (min-width: 1536px)  max-  …  @media (max-width: …)  方向\n   portrait 竖屏，   landscape 横屏  流式布局：百分比、flex  响应图片：根据分辨率加载不同大小图片  黑暗：   媒体查询        和   使用 CSS 中的过滤器（filter），利用 invert 和 hue-rotate 两个函数来反转和调整页面元素的颜色   filter 属性来给元素（通常是图片）添加一些视觉效果（类似于 Photoshop 中的滤镜）。CSS filter 属性可以让您实现一些预定义的效果，例如模糊、亮度、对比度、阴影、灰度、色相、反转、透明度、饱和度和棕褐色等。您也可以使用 url () 函数来引用 SVG 文件中定义的滤镜效果。   invert() 函数是一种滤镜函数，可以用来给元素（通常是图片）添加反色的效果。invert() 函数的作用是将输入图像中的每个颜色样本反转，即用 255 减去原来的颜色值。可以传入参数表示反转的程度  hue-rotate() 函数是一种滤镜函数，可以用来给元素（通常是图片）添加色相旋转的效果。色相旋转的意思是将输入图像中的每个颜色样本沿着色环（色彩模型中的一个圆形区域，表示不同的色相）旋转一定的角度，从而改变图像的色调。  注释：invert 使图片的颜色趋于中和然后反向，hue-rotate 使图片中的颜色变成其他颜色  使用 CSS 中的混合模式（mix-blend-mode），让页面元素的颜色与背景色相互影响，产生不同的视觉效果   mix-blend-mode 是一种 CSS 属性，它定义了一个元素的内容如何与其父元素的内容和元素的背景如何混合。它允许你创建令人惊艳的视觉效果，可以用于创建半透明效果、添加阴影、制作图片蒙版和很多其他效果。具体来说，mix-blend-mode 定义了两个元素之间的颜色混合模式。  motion-reduce   prefers-reduced-motion 是一个CSS媒体查询，它可以用来检测用户是否在设备上启用了减少非必要动画或运动的设置   motion-safe 当用户没有设置 prefers-reduced-motion 时才添加样式   contrast-more 用户请求更多对比度时，     contrast-less 用户要求降低对比度时  print 打印样式  Use the supports-  ...  modifier to style things based on whether a certain feature is supported in the user’s browser.   特性查询，用来判断浏览器是否支持某些 css 特性，例如：     Under the hood the supports-  ...  modifier generates @supports rules and takes anything you’d use with @supports (...) between the square brackets, like a property/value pair, and even expressions using and and or.\n   方括号内支持 @supports () 内的所有语法  For terseness, if you only need to check if a property is supported (and not a specific value), you can just specify the property name:\n   为了简洁起见可以直接用属性名判断是否支持该属性   backdrop-filter 是一种 CSS 属性，它可以让你对一个元素的背景或背景区域应用图形效果，比如模糊、色彩变换等。它和 filter 属性的效果类似，但是 filter 属性是对元素的内容应用效果，而 backdrop-filter 属性是对元素的背景应用效果。  You can configure shortcuts for common @supports rules you’re using in your project in the theme.supports section of your tailwind.config.js file:\n   可以在配置文件中为  内内容配置快捷方式，注意：快捷方式不是通过  传入Attribute selectors, like   dir=\"rtl\"  and   open   Use the aria-* modifier to conditionally style things based on ARIA attributes.   根据是否有 aria-* 属性来控制     ARIA 用于修改无障碍树中定义的元素的状态和属性，例如：把 aria-hidden=\"true\" 加到元素上会把该元素和它的所有子元素从无障碍树上移除。这样做可以通过隐藏下列内容来提升使用辅助技术的用户体验  By default we’ve included modifiers for the most common boolean ARIA attributes:   为  常用 的 aria 属性提供了快捷方式   原生所有的 aria 属性  If you need to use a one-off aria modifier that doesn’t make sense to include in your theme, or for more complex ARIA attributes that take specific values, use square brackets to generate a property on the fly using any arbitrary value.   使用    可以使用任意 aria 属性，例如：   ARIA state modifiers can also target parent and sibling elements using the group-aria-* and peer-aria-* modifiers:   可以和 group 和 peer 配合使用，  标识父组件具有  属性时 svg 的样式  You can customize which aria-* modifiers are available by editing theme.aria or theme.extend.aria in your tailwind.config.js file   可以在配置中为  内内容配置快捷方式，注意：快捷方式不是通过  传入接上面\n   Since there are no standard data-* attributes by definition, by default we only support arbitrary values out of the box, for example:\n   data- 没有官方默认属性，所以默认只支持  传入任意值，例如   You can configure shortcuts for common data attribute selectors you’re using in your project in the theme.data section of your tailwind.config.js file:\n   可以在配置文件中配置快捷方式  ~= 是一种 CSS 属性选择器，它用来选择具有指定属性和值的元素，其中值是一个由空格分隔的列表，且列表中包含指定的值。接上面   Use the rtl and ltr modifiers to conditionally add styles in right-to-left and left-to-right modes respectively when building multi-directional layouts:   使用 rtl 和 ltr 在不同文本展示方式下设置样式   Note that the ltr modifier will not take effect unless the dir attribute is explicitly set to ltr, so if you are building a multi-directional site make sure to always set a direction, not just in rtl mode.  必须在 html 中设置  才能够生效  Use the open modifier to conditionally add styles when a    or    element is in an open state:   details 和 dialog 标签具有 open 属性     details 折叠框标签  These modifiers can even be stacked to target more specific situations, for example changing the background color in dark mode, at the medium breakpoint, on hover:   这些修饰符甚至可以堆叠When you need to style an element based on the state of some parent element, mark the parent with the group class, and use group-* modifiers like group-hover to style the target element:\n   根据父元素状态设置元素样式时，在父元素绑定  ，在子元素绑定  来定义  注释：嵌套容易导致影响范围不明确  下例：当    hover 时，svg、h3、p 改变字体颜色   适用于每个伪类  注释：group不是通过原生css的伪类实现的，文档的归类会导致误导When nesting groups, you can style something based on the state of a specific parent group by giving that parent a unique group name using a group/{name} class, and including that name in modifiers using classes like group-hover/{name}:\n   根据特定父元素状态来设置元素样式，在父元素绑定  ，在子元素绑定  来定义     You can create one-off group-* modifiers on the fly by providing your own selector as an arbitrary value between square brackets:\n   可以在 group-   的方括号内传入任意选择器来指定特定的父元素    生成的 css     For more control, you can use the & character to mark where .group should end up in the final selector relative to the selector you are passing in:\n   & 用来作为 group 的占位符，空格用 _ 代替     When you need to style an element based on the state of a sibling element, mark the sibling with the peer class, and use peer-* modifiers like peer-invalid to style the target element:\n   根据同级元素来设置之后元素，  用来标记需要观察的同级元素，  用来标记之后元素在同级元素处于 * 状态时的样式  注释：p ~ span 只能选中 p 之后同个父级的 span 并不能选中之前的  注释：peer不是通过 css原生伪类实现的，文档的分类具有误导     When using multiple peers, you can style something on the state of a specific peer by giving that peer a unique name using a peer/{name} class, and including that name in modifiers using classes like peer-checked/{name}:\n   根据特定同级元素来设置之后元素，  用来标记需要观察的同级元素，  用来标记之后元素在同级元素处于 * 状态时的样式     You can create one-off peer-* modifiers on the fly by providing your own selector as an arbitrary value between square brackets:\n   可以在 pree-   的方括号内传入任意选择器来指定特定的同级元素  注释：pree-   和 pree-* 可以同时使用，应该和 peer-*/{name} 也能同时使用，group 应该也一样     For more control, you can use the & character to mark where .peer should end up in the final selector relative to the selector you are passing in:\n   & 用来作为 .peer 的占位符，空格用 _ 代替，  最终被解析为      Arbitrary variants are just format strings that represent the selector, wrapped in square brackets. For example, this arbitrary modifier selects an element only when it is the third child:\n   可以使用    定义任意的选择器   Arbitrary variants can be stacked with built-in modifiers or with each other, just like the rest of the modifiers in Tailwind:\n   []可以和其他内置类名共同使用   You can also use at-rules like @media or @supports in arbitrary variants:\n   可以在  中使用 @media or @supports   You can even combine at-rules and regular selector modifiers by including the selector modifier within curly braces after the at-rule:\n   在    可以使用 {} 包含选择器，例如：    当前设备有输入机制可以实现 hover 效果  If you find yourself using the same arbitrary modifier multiple times in your project, it might be worth extracting it to a plugin using the addVariant API:\n可以把    定义的任意选择器配置为插件     All of Tailwind’s modifiers are available to use with your own custom classes as long as you’ve defined them in one of Tailwind’s layers or added them using a plugin:\n   所有修饰符都可以和自定义类一起使用     For the most part this doesn’t actually matter, but there are a few situations where the order you use actually generates meaningfully different CSS.\n   修饰符的绑定顺序会导致结果的不同  dark: 在 tailwind 中可选择实现方法，一种是通过 @media 另一种是通过 html 中添加 .dark，当以 class 方式实现时，第二种顺序会导致错误     For example, if you have darkMode configured to class, combining the dark and group-hover modifiers generates a different result depending on the order you use:\n   例如：使用 prose-headings 时需要注意顺序  prose-headings 是官方插件中提供的修饰符，会影响 h1, h2, h3, h4, th 这些元素的样式，你可以在它后面加上任何 Tailwind 的工具类，来改变标题的字体、颜色、大小、对齐等属性   () 是 CSS 中的一个伪类函数，它可以接受一个选择器列表作为参数，并选择该列表中任何一个选择器可以选择的元素。这对于以更紧凑的形式编写复杂的选择器非常有用。  :where 和 `:Is  :where(.foo) .bar {}  .bar部分`  注释：伪类会修饰随后的实体，如果没有则修饰自身，例如：  这里的  修饰的是     Responsive Design 响应式设计   What this means is that unprefixed utilities (like uppercase) take effect on all screen sizes, while prefixed utilities (like md:uppercase) only take effect at the specified breakpoint and above.\n   移动优先，不带前缀所有尺寸适用，加了前缀，指定断点及以上适用  If you’d like to apply a utility only when a specific breakpoint range is active, stack a responsive modifier like md with a max-* modifier to limit that style to a specific range:\n   可以堆叠断点以设置一个区间类使用的样式   You can completely customize your breakpoints in your tailwind.config.js file:\n   可以自定义断点     If you need to use a one-off breakpoint that doesn’t make sense to include in your theme, use the min or max modifiers to generate a custom breakpoint on the fly using any arbitrary value.\n   可以使用  自定义断点    Dark Mode 暗黑模式   If you want to support toggling dark mode manually instead of relying on the operating system preference, use the class strategy instead of the media strategy:\n   如果要手动切换暗黑模式，需要使用 class 实现方式  Window 的 matchMedia() 方法返回一个新的 MediaQueryList 对象，表示指定的媒体查询字符串解析后的结果。返回的 MediaQueryList 可被用于判定 Document 是否匹配媒体查询，或者监控一个 document 来判定它匹配了或者停止匹配了此媒体查询。  You can customize the dark mode selector name by setting darkMode to an array with your custom selector as the second item:\n   'class'表示使用类（class）策略来切换暗黑模式，也就是说，当HTML元素上存在dark类时，就会启用暗黑模式。  '  data-mode=\"dark\" '表示使用自定义的属性选择器来切换暗黑模式，也就是说，当HTML元素上存在data-mode=\"dark\"属性时，就会启用暗黑模式。    Reusing Styles 重用样式   不建议这么做  While it’s highly recommended that you create proper template partials for more complex components, you can use Tailwind’s @apply directive to extract repeated utility patterns to custom CSS classes when a template partial feels heavy-handed.\n   使用 @apply 将实用程序类整合成重用样式     If you’re going to use @apply, use it for very small, highly reusable things like buttons and form controls — and even then only if you’re not using a framework like React where a component would be a better choice.\n   只有当只有单个 html 标签时才尝试使用 @apply 整合重用样式，其他情况组件会是更好的选择  Adding Custom Styles 添加自定义样式     When you find yourself really needing something like top: 117px to get a background image in just the right spot, use Tailwind’s square bracket notation to generate a class on the fly with any arbitrary value:\n   可以使用    来突破 Tailwind 给出的限定值     This is basically like inline styles, with the major benefit that you can combine it with interactive modifiers like hover and responsive modifiers like lg:\n   [] 可以和装饰符一起实用     It’s even possible to use the theme function to reference the design tokens in your tailwind.config.js file:\n   在    中可以使用 theme 函数应用 配置 中定义的变量  fit-content(max-content)是一个CSS属性，它可以用来调整元素的大小，使其适应内容的尺寸。\n   这意味着盒子会使用可用的空间，但永远不会超过max-content。  当fit-content用于设置元素的width、height、min-width、min-height、max-width和max-height时，最大和最小尺寸将基于元素的内容尺寸计算     When using a CSS variable as an arbitrary value, wrapping your variable in var(...) isn’t needed — just providing the actual variable name is enough:\n   当使用 css 原生变量时不需要使用 var() 包裹，只需要直接使用变量名     If you ever need to use a CSS property that Tailwind doesn’t include a utility for out of the box, you can also use square bracket notation to write completely arbitrary CSS:\n   [] 同样可以用来，完全自定义 css  This is really like inline styles, but again with the benefit that you can use modifiers:\n   依然可以使用修饰符  mask-type:luminance是一个CSS属性，它表示SVG   元素是用作亮度掩码还是alpha掩码。\n   掩码是一串二进制代码，用于对目标字段进行位与运算，屏蔽或选择当前的输入位。  alpha掩码是一种CSS属性，它可以用来指定一个颜色的透明度或不透明度。  div 元素可以使用 mask-type 属性，但是需要满足以下条件：\n   div 元素必须有一个 mask-image 属性，用于指定遮罩图片的路径。   遮罩图片必须是一个 SVG 图形，且包含一个 id 属性，用于在 mask-image 中引用。     This can be useful for things like CSS variables as well, especially when they need to change under different conditions:\n   还可以用来修改css原生变量的值     Arbitrary variants are like arbitrary values but for doing on-the-fly selector modification, like you can with built-in pseudo-class variants like hover:{utility} or responsive variants like md:{utility} but using square bracket notation directly in your HTML.\n   []和：配合使用还可以用来实现任意变体     In situations where underscores are common but spaces are invalid, Tailwind will preserve the underscore instead of converting it to a space, for example in URLs:\n   在  中并不是所有_都表示空格，在 空格 无效的情况下_保持原样，例如在url()中     In the rare case that you actually need to use an underscore but it’s ambiguous because a space is valid as well, escape the underscore with a backslash and Tailwind won’t convert it to a space:\n   当明确不转换_为空格的地方可以使用\\标识     If you’re using something like JSX where the backslash is stripped from the rendered HTML, use String.raw() so the backslash isn’t treated as a JavaScript escape character:\n   在 jsx 中    会被编译为   ，这和 tailwind 生成的 css 类名就会有出入导致样式无效，使用 String.raw() 包裹这个类名来解决  String.raw() 用来处理模板字符串，会计算插值的结果并获取HTML转义序列中的字符的原始字符串形式，例如      Many utilities in Tailwind share a common namespace but map to different CSS properties. For example text-lg and text-black both share the text- namespace, but one is for font-size and the other is for color.\n   当使用  作为任意属性时会面临命名空间的问题  When using arbitrary values, Tailwind can generally handle this ambiguity automatically based on the value you pass in:\n   一般 tailwind 会根据传入值来自动判断In these situations, you can “hint” the underlying type to Tailwind by adding a CSS data type before the value:\n     当参数是个变量时无法进行自动判断，可以在参数前添加  css数据类型 来进行区别For more power, you can also use the @layer directive to add styles to Tailwind’s base, components, and utilities layers:\n   可以使用 @layer 把自定义样式添加到 base, components, and utilities 中  components 是一些预定义的组件样式，用于创建一些常见的 UI 元素，例如按钮，卡片，表单等。utilities 是一些功能性的样式，用于控制一些细节的样式属性，例如颜色，边框，定位，布局等。  utilities 中定义得类的优先级应该高于其他  The @layer directive helps you control declaration order by automatically relocating your styles to the corresponding @tailwind directive, and also enables features like modifiers and tree-shaking for your own custom CSS.\n   自定义的类能够和修饰符一起使用，会被按顺序归纳到各自分类中保证优先级，并且如果没有使用会从最终打包结果中树摇掉Use the theme function or @apply directive when adding custom base styles if you want to refer to any of the values defined in your theme.\n   如果要引用主题中定义的值可以使用 @apply 和 themeIf you want to add some custom CSS that should always be included, add it to your stylesheet without using the @layer directive:\n   没有使用 @layer 的类不会被树摇掉  Make sure to put your custom styles where they need to go to get the precedence behavior you want. In the example above, we’ve added the .card class before @tailwind utilities to make sure utilities can still override it.\n   需要注意没有使用 @layer 的类的引用顺序，建议如下，保证 utilities 类型的优先级最高If you are writing a lot of CSS and organizing it into multiple files, make sure those files are combined into a single stylesheet before processing them with Tailwind, or you’ll see errors about using @layer without the corresponding @tailwind directive.\n   如果 css 分散在多个文件中，且包含 @layer 或 @tailwind，那么必须在 tailwind 处理前将这些文件合并成一个  The easiest way to do this is using the postcss-import plugin:\n   使用 postcss-import 插件能根据 css 的 @import 方法将多个 css 文件在打包时合并成一个  While you can use features like @apply and theme inside component styles like this, the @layer directive will not work and you’ll see an error about @layer being used without a matching @tailwind directive:\n   在 vue 这样的框架的样式中，可以使用 @apply 和 theme，但是不能使用 @layer  注释：但是这里的 @apply 和 theme 只能引用到配置文件定义的类和主题，不能引用到 css 中定义的类  This is because under-the-hood, frameworks like Vue and Svelte are processing every single    参考：  https://tailwindcss.com/docs/using-with-preprocessors#writing-custom-styles","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#functions-directives-功能与指令","title":"Functions & Directives 功能与指令","titles":[],"content":"Directives are custom Tailwind-specific at-rules you can use in your CSS that offer special functionality for Tailwind CSS projects.\n   指令参考 css 原生   at-rules ，能够直接在 css 文件中使用，为tailwind 扩展功能  @tailwind\n   原生 css 没有Use the @layer directive to tell Tailwind which “bucket” a set of custom styles belong to. Valid layers are base, components, and utilities.\n   @layer 只能用来定义 base, components, and utilities  原生 css 有相同的  Any rules inlined with @apply will have !important removed by default to avoid specificity issues:\n   任何使用 @apply 内联来的样式都将会删除其中的 !importantIf you’d like to @apply an existing class and make it !important, simply add !important to the end of the declaration:\n   如果你想要让生成的样式的属性都添加上 !important，只需要在 @apply 的末尾加上他就行Note that if you’re using Sass/SCSS, you’ll need to use Sass’ interpolation feature to get this to work:\n   和 sass/scss 预处理器一起使用时，!important 要以 sass 的插值语法加入，才能正常工作If you try to @apply a custom class you’ve defined in your global CSS in one of these per-component    The solution to this problem is to define any custom styles you want to @apply in your components using the plugin system instead:\n   这个问题的解决方法是使用插件的形式将类添加到样式中Use the @config directive to specify which config file Tailwind should use when compiling that CSS file. This is useful for projects that need to use different configuration files for different CSS entry points.\n   @config 可以用来设置当前 css 使用的配置文件  注释：可以为每个css文件指定不同的配置文件  The path you provide to the @config directive is relative to that CSS file, and will take precedence over a path defined in your PostCSS configuration or in the Tailwind CLI.\n   配置文件的路径相对于当前文件  Note that if you’re using postcss-import, your @import statements need to come before @config for things to work correctly, as postcss-import is strict about following the CSS spec which requires @import statements to precede any other rules in the file.\n   和 @import 一起使用时，根据 css 规则，@import 要放在最前面  If you need to access a value that contains a dot (like the 2.5 value in the spacing scale), you can use square bracket notation:\n   如果 theme 获取的属性的名称包含点的化，使用  包裹Since Tailwind uses a nested object syntax to define its default color palette, make sure to use dot notation to access the nested colors.\n   tailwind用嵌套语法定义颜色，因此必须使用.来访问颜色  注释：嵌套语法是指颜色在配置时可以直接配置一个色号，也可以配置为一个对象，里面包含多个色号To adjust the opacity of a color retrieved with theme, use a slash followed by the opacity value you want to use:\n   使用 them 获取色号时可传入  来设置透明度The screen function allows you to create media queries that reference your breakpoints by name instead of duplicating their values in your own CSS.\n   screen() 用来根据配置的断点生成对应的媒体查询","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#configuration-配置","title":"Configuration 配置","titles":[],"content":"Every section of the config file is optional, so you only have to specify what you’d like to change. Any missing sections will fall back to Tailwind’s default configuration.\n    默认配置  Generate a Tailwind config file for your project using the Tailwind CLI utility included when you install the tailwindcss npm package:\n   生成配置文件   This will create a minimal tailwind.config.js file at the root of your project:\n   指定配置文件名称   When you use a custom file name, you will need to specify it as a command-line argument when compiling your CSS with the Tailwind CLI tool:\n   命令行方式指定编译时使用的配置文件   If you’re using Tailwind as a PostCSS plugin, you will need to specify your custom configuration path in your PostCSS configuration:\n   tailwind 作为 postcss 插件使用时，在 postcss.config.js 中配置 tailwind 的配置文件路径You can also configure Tailwind CSS in ESM or even TypeScript:\n   配置项支持 ts  satisfies 是一个 TypeScript 4.9 中引入的新的操作符，保证声明的值满足类型When you run npx tailwindcss init, we’ll detect if your project is an ES Module and automatically generate your config file with the right syntax.\n   生成配置文件时会自动检测是生成 es 模块类型的还是 ts 类型的  You can also generate an ESM config file explicitly by using the --esm flag:\n   也可以显示的声明你要生成哪种类型的文件  或   Use the -p flag if you’d like to also generate a basic postcss.config.js file alongside your tailwind.config.js file:\n   -p 用来生成具有 tailwindcss 插件的 postcss.config.js 配置文件  If you’d rather scaffold a complete configuration file that includes all of Tailwind’s default configuration, use the --full option:\n   --full 生成一个包含所有默认配置的 tailwind 配置文件，不建议这么干  The content section is where you configure the paths to all of your HTML templates, JS components, and any other files that contain Tailwind class names.\n   content 用来配置需要检查是否包含 tailwind 类名的文件The theme section is where you define your color palette, fonts, type scale, border sizes, breakpoints — anything related to the visual design of your site.\n   theme 下用来配置 颜色、字体、字体比例、边框、间距、断点  The plugins section allows you to register plugins with Tailwind that can be used to generate extra utilities, components, base styles, or custom variants.\n   plugins 用来引入插件  插件可以实现 utilities, components, base 和 variantsThe presets section allows you to specify your own custom base configuration instead of using Tailwind’s default base configuration.\n   presets 用来引入预设  预设应该就是一套配置项The prefix option allows you to add a custom prefix to all of Tailwind’s generated utility classes. This can be really useful when layering Tailwind on top of existing CSS where there might be naming conflicts.\n   为所有实用类增加前缀It’s important to understand that this prefix is added after any variant modifiers. That means that classes with responsive or state modifiers like sm: or hover: will still have the responsive or state modifier first, with your custom prefix appearing after the colon:\n   前缀是加在实用类上的和修饰符无关   The dash modifier for negative values should be added before your prefix, so -mt-8 would become -tw-mt-8 if you’ve configured tw- as your prefix:\n   前缀也和负值标识无关   Prefixes are only added to classes generated by Tailwind; no prefix will be added to your own custom classes.\n   前缀只和 tailwind 提供的实用类有关，和自定义无关  The important option lets you control whether or not Tailwind’s utilities should be marked with !important. This can be really useful when using Tailwind with existing CSS that has high specificity selectors.\n   important 用于配置实用类所有属性是否都带有!important  Now all of Tailwind’s utility classes will be generated as !important:\n   适用于使用 @layer utilities 自定义的类To get around this, you can set important to an ID selector like #app instead:\n   可以把 important 设置为 css 选择器，用来提高 tailwind 类的权重  When using the selector strategy, be sure that the template file that includes your root selector is included in your content configuration, otherwise all of your CSS will be removed when building for production.\n   当使用选择器时，content 必须包含引用该选择器的元素所在的文件，不然其他类都会被视为没有使用而被树摇掉Alternatively, you can make any utility important by adding a ! character to the beginning:\n   可以在类名前加入！来标明这个类属性需要加 !important  The ! always goes at the beginning of the utility name, after any variants, but before any prefix:\n   !对于实用类生效，在修饰符之后，在前缀之前The separator option lets you customize which character should be used to separate modifiers (screen sizes, hover, focus, etc.) from utility names (text-center, items-end, etc.).\n   separator 用于定义修饰符的分隔符，默认为   有些模板语言把  作为保留字符   The corePlugins section lets you completely disable classes that Tailwind would normally generate by default if you don’t need them for your project.\n   corePlugins 用于禁用默认生成的实用类  If you’d like to safelist which core plugins should be enabled, provide an array that includes a list of the core plugins you’d like to use:\n   可以通过传入数组来声明只实用哪些实用类  核心插件及对应实用类  对照表To make this easy, Tailwind provides a resolveConfig helper you can use to generate a fully merged version of your configuration object:\n   resolveConfig 用于获取配置文件合并后的内容  Note that this will transitively pull in a lot of our build-time dependencies, resulting in bigger client-side bundle size. To avoid this, we recommend using a tool like babel-plugin-preval to generate a static version of your configuration at build-time.\n   这种方式会导致 resolveConfig 中的很多依赖被打包到项目中，使得打包后的体积变大，但实际上我们只需要 tailwindConfig 的最终结果不需要过程，可以使用 babel-plugin-preval 解决这个问题   babel-plugin-preval  可以让你在编译时运行一些代码，并把结果替换到JavaScript文件中。","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#content-内容","title":"Content 内容","titles":[],"content":"Paths are configured as glob patterns, making it easy to match all of the content files in your project without a ton of configuration:\n   content 配置的路径为 glob patterns 模式  glob patterns是一种用于指定文件名或字符串的通配符模式。\n   Use * to match anything except slashes and hidden files\n    通配符，除了/以外的字符串  Use ** to match zero or more directories\n    匹配1个或多个目录  Use comma separate values between {} to match against a list of options\n   匹配 {} 提供的选项之一  Tailwind uses the fast-glob library under-the-hood — check out their documentation for other supported pattern features.\n   Tailwind 使用   fast-glob  查找匹配的文件，上面的列表没有包含全部的使用方法  Paths are relative to your project root, not your tailwind.config.js file, so if your tailwind.config.js file is in a custom location, you should still write your paths relative to the root of your project.\n   文件的路径相对于 tailwind 命令运行时的目录，而不是相对于 tailwind.config.js 文件  It’s also important that you don’t scan any CSS files — configure Tailwind to scan your templates where your class names are being used, never the CSS file that Tailwind is generating.\n   content 不要包含任何 css 文件If you use string interpolation or concatenate partial class names together, Tailwind will not find them and therefore will not generate the corresponding CSS:\n   动态拼接的类名将不被 tailwind 正确识别，将会被树摇掉If you’ve created your own reusable set of components that are styled with Tailwind and are importing them in multiple projects, make sure to configure Tailwind to scan those components for class names:\n   如果外部组件通过 Tailwind 实现了样式，应该把外部组件的代码包含进来  注释：前缀会造成问题  require.resolve获取模块的绝对路径  path.dirname获取路径的目录名To always resolve paths relative to the tailwind.config.js file, use the object notation for your content configuration and set the relative property to true:\n   设置 content.relative 可以使解析 files 时相对于配置文件的路径，而不是命令运行的当前工作目录If for whatever reason you need to configure Tailwind to scan some raw content rather than the contents of a file, use an object with a raw key instead of a path:\n   content 可以直接指定要扫描的文本内容If you need to make sure Tailwind generates certain class names that don’t exist in your content files, use the safelist option:\n   某些类无法通过扫描被保留下来，可以使用 safelist 显示声明哪些要保留Tailwind supports pattern-based safelisting for situations where you need to safelist a lot of classes:\n   safelist 中支持正则匹配哪些类需要被保留If you want to force Tailwind to generate variants for any matched classes, include them using the variants option:\n   safelist 中使用正则匹配时只会保留能够匹配的类，不会自动包括修饰符，可以通过 variants 指定该正则的哪些修饰符应该被保留In these situations, you can use the blocklist option to tell Tailwind to ignore specific classes that it detects in your content:\n   可以使用 blocklist 声明哪些类不被包含  Unlike safelist, the blocklist option only supports strings, and you cannot block classes using regular expressions.\n   只能使用字符串模式Use the content.transform option to transform any content matching a specific file extension before extracting classes:\n   使用 transform 可以在文件被检查前对其进行处理  注释：下例中将 md 文件转换为 html 文本，然后才交由 tailwind 去提取使用的 classUse the extract option to override the logic Tailwind uses to detect class names for specific file extensions:\n   extract 用于定义对某类文件的检查方法If your CSS seems to be rebuilding in an infinite loop, there’s a good chance it’s because your build tool doesn’t support the glob option when registering PostCSS dependencies.   在构建过程中，如果发现 css 无限循环更新，可能是因为注册 PostCSS 依赖项时不支持 glob  glob 是文件路径通配符  Many build tools (such as webpack) don’t support this option, and as a result we can only tell them to watch specific files or entire directories. We can’t tell webpack to only watch *.html files in a directory for example.\n   webpack 不支持通过 glob 的 *.html 方式注入某个文件类型的依赖项，所以 tailwind 注入的整个文件夹下的所有文件，如果生成的文件包含在这个文件夹中，那么会导致无限循环的产生  If you are experiencing weird, hard to describe issues with the output, or things just don’t seem like they are working at all, there’s a good chance it’s due to your build tool not supporting PostCSS dependency messages properly (or at all). One known example of this currently is  Stencil  .   Stencil这个构建工具不支持 PostCSS 注入依赖项，当文件变化时不会重新打包  注释：tailwind cli 支持 watch 的，可以直接用来打包 css 不需要继承到打包工具中","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#theme-主题","title":"Theme 主题","titles":[],"content":"By default, these colors are inherited by all color-related core plugins, like backgroundColor, borderColor, textColor, and others.\n   默认情况下 config.theme.colors 配置的颜色会被和颜色相关的实用类继承，例如：backgroundColor, borderColor, textColor  The spacing key allows you to customize the global spacing and sizing scale for your project.\n   theme.spacing 用来配置距离数值  By default, these values are inherited by the padding, margin, width, height, maxHeight, flex-basis, gap, inset, space, translate, scrollMargin, scrollPadding, and textIndent core plugins.\n   默认情况距离数值会被 padding, margin, width, height, maxHeight, flex-basis, gap, inset, space, translate, scrollMargin, scrollPadding, and textIndent 继承，还会被核心插件继承  You’ll notice that using a key of DEFAULT in the theme configuration created the class rounded with no suffix. This is a common convention in Tailwind and is supported by all core plugins.\n   DEFAULT 是特殊的配置 key，可以用来配置没有后缀的实用类，例如   If you’d like to preserve the default values for a theme option but also add new values, add your extensions under the theme.extend key in your configuration file. Values under this key are merged with existing theme values and automatically become available as new classes that you can use.\n   theme.extend 用来保留默认配置的情况下添加新的配置  注释：theme中的配置即有全局 css 变量（theme.color），又有允许实用的类(theme.fontFamily.display => font-display)，还有运用于所有实用类的装饰（theme.screens）  If you need to reference another value in your theme, you can do so by providing a closure instead of a static value. The closure will receive an object that includes a theme() function that you can use to look up other values in your theme using dot notation.\n   可以传入一个函数，函数的参数将接收 theme 对象，可以用来引用配置中的其他选项  注释：好像会尝试递归去寻找引用的 theme 配置项的值If you’d like to reference a value in the default theme for any reason, you can import it from tailwindcss/defaultTheme.\n   可以从  引入默认值Except for screens, colors, and spacing, all of the keys in the theme object map to one of Tailwind’s core plugins.\n   除了 screens, colors, and spacing 其他实用类是以核心插件的方式实现的   核心插件配置对照表","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#screens-屏幕","title":"Screens 屏幕","titles":[],"content":"This will replace the default screens value with the same name, without changing the order of your breakpoints.\n   直接定义  会根据顺序生成断点样式，注意优先级  使用  修改原有断点的值不会修改顺序，添加新值会添加到所有断点的最后  If you want to add an additional small breakpoint, you can’t use extend because the small breakpoint would be added to the end of the breakpoint list, and breakpoints need to be sorted from smallest to largest in order to work as expected with a min-width breakpoint system.\n   要在最前面添加断点样式，需要重写整个  ，这个时候  提供的默认值非常有用If you want to work with max-width breakpoints instead of min-width, you can specify your screens as objects with a max key:\n   max 可以用来设置 @media (max-width: 1535px) 的媒体查询If you want your breakpoints to specify both a min-width and a max-width, use the min and max keys together:\n   同时使用 min 和 max 可以设置一个区间的媒体查询For example, say you have a sidebar and want your breakpoints to be based on the content-area width rather than the entire viewport. You can simulate this by having one of your breakpoints fall back to a smaller breakpoint when the sidebar becomes visible and shrinks the content area:\n   可以使用数组设置多段的断点区间If you want full control over the generated media query, use the raw key:\n   使用 raw key 可以自定义 @media() 中的媒体查询条件","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#colors-颜色","title":"Colors 颜色","titles":[],"content":"所有预设颜色  Don’t forget to include values like transparent and currentColor if you want to use them in your project.\n   自定义颜色时不要忘记 transparent 和 currentColor 两个值  currentColor 代表当前元素的文本颜色  transparent表示完全透明的颜色  If you are creating your own custom color palette and don’t feel confident doing it by hand, UI Colors is a great tool that can give you a good starting point based on any custom color.\n   tailwind提供的  颜色生成器 ，用来帮助你选择颜色  Two other useful tools we recommend for building your own palettes are Palettte and ColorBox — they won’t do the work for you but their interfaces are well-designed for doing this sort of work.\n   另外两个颜色生成器   Palettte  and   ColorBox  If you don’t have a set of completely custom colors in mind for your project, you can curate your colors from our default palette by importing tailwindcss/colors in your configuration file and choosing the colors you want to use:\n   可以通过  访问默认的颜色配置注释：暗黑模式最好是支持单页面应用的，便于用户切换  注释：主题可以是刷新后生效，通过切换不同 css 文件实现  注释：tailwind 的 color 并不是通过 cssVar 实现的   If you’d like to define your colors as CSS variables, you’ll need to define those variables as just the color channels if you want them to work with the opacity modifier syntax:\n   当通过 cssVar 定义 color 时，且希望同透明修饰符  共同使用时，需要把颜色定义为如下  When defining your colors this way, make sure that the format of your CSS variables is correct for the color function you are using. You’ll want to use spaces if using the modern space-separated syntax, and commas if using legacy functions like rgba or hsla:\n   当 config 中不是采用 var() 拼接值时，定义的 cssVar 要符合目标 value 的格式，例如  =>   注释：cassVar 本质上是个字符串，被用来在 config 中拼接成正确的 css 属性，也可以相同方式用于其他属性值","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#spacing-间距","title":"Spacing 间距","titles":[],"content":"所有默认间距  注释：间距单位是 rem，html font-size 默认是 32，间距 0.5 对应 0.125rem 即 2px","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#plugins-插件","title":"Plugins 插件","titles":[],"content":"To get started with your first plugin, import Tailwind’s plugin function from tailwindcss/plugin. Then inside your plugins array, call the imported plugin function with an anonymous function as the first argument.\n   如何使用插件  Plugin functions receive a single object argument that can be destructured into several helper functions:\n   传入 plugin 的函数的参数可以解构为多个方法  addUtilities(), for registering new static utility styles\n   addUtilities() 用于注册静态实用类  addUtilities 添加的所有类默认可以和所有修饰符一起实用  matchUtilities(), for registering new dynamic utility styles\n   matchUtilities 用于注册动态实用类，和 addUtilities 的区别主要在于，而 matchUtilities 接收的参数的 value 允许是个函数（见例子）  matchUtilities 支持    的方式接收参数，在下例中    中的值将作为 skew 的参数 modifier 传入  addComponents(), for registering new static component styles\n   addComponents()，用于注册新的静态组件样式  matchComponents(), for registering new dynamic component styles\n   matchComponents()，用于注册新的动态组件样式  addBase(), for registering new base styles\n   addBase()，用于注册新的基本样式  注释：可以用来注册 cssVar，从而实现对外部库 cssVar 的覆盖和配置统一  addVariant(), for registering custom static variants\n   addVariant()，用于注册自定义静态变体  matchVariant(), for registering custom dynamic variants\n   matchVariant()，用于注册自定义动态变体  theme(), for looking up values in the user’s theme configuration\n   theme()，用于在用户的主题配置中查找值  config(), for looking up values in the user’s Tailwind configuration\n   config()，用于在用户的顺风配置中查找值  corePlugins(), for checking if a core plugin is enabled\n   corePlugins()，用于检查是否启用了核心插件  e(), for manually escaping strings meant to be used in class names\n   e()，用于手动转义要在类名中使用的字符串，例如将  =>Official plugins\n   官方插件  The @tailwindcss/typography plugin adds a set of prose classes that can be used to quickly add sensible typographic styles to content blocks that come from sources like markdown or a CMS database.\n   @tailwindcss/typography 用于向无法直接修改标签 class 的 html 添加样式的插件，例如：vuepress 把 md 生成 html 插入到模板中，你可以在模板的容器标签中实用这个插件提供的 class  The @tailwindcss/forms plugin adds an opinionated form reset layer that makes it easier to style form elements with utility classes.\n   @tailwindcss/forms 提供了应用于表单元素的 class  The @tailwindcss/aspect-ratio plugin is an alternative to native aspect-ratio support that works in older browsers, and adds aspect-w-{n} and aspect-h-{n} classes that can be combined to give an element a fixed aspect ratio.\n   @tailwindcss/aspect-ratio 是 aspect-ratio 的替代方案  aspect-ratio 是一个用于设置元素纵横比的属性，即宽度变化后，高度会根据 aspect-ratio 的值得处结果  The @tailwindcss/container-queries plugin adds new @{size} variants like @sm and @md that let you style an element based on the dimensions of a parent marked with @container instead of the viewport.\n   @tailwindcss/container-queries 允许根据父元素的尺寸来设置当前元素的样式  @container 是 css 的新特性，用于定义绑定它的标签内部的标签是独立的布局上下文，和媒体查询类似，支持设置尺寸断点，当元素达到不同断点时实用不同断点下的样式  By default, plugin utilities automatically respect the user’s prefix and important preferences.\n   插件生成的类依然遵守 prefix and important 配置的结果  By default, component classes automatically respect the user’s prefix preference, but they are not affected by the user’s important preference.\n   通过 addComponents 创建的类遵循 prefix 的配置，但不遵循 important 的配置  All classes in a selector will be prefixed by default, so if you add a more complex style like:\n   addComponents 生成的所有选择器都会根据 prefix 添加前缀Since base styles are meant to target bare selectors like div or h1, they do not respect the user’s prefix or important configuration.\n   通过 addBase 添加的类不支持 prefix or important 配置  Use the addVariant function for simple custom variants, passing in the name of your custom variant, and a format string that represents how the selector should be modified.\n   addVariant 用来定义简单的装饰器  注释：inverted-colors 是 CSS 中的一个媒体特性，用于检测用户代理或底层操作系统是否反转了所有颜色  注释：:optional 是一个 CSS 的伪类选择器，用于匹配表单元素中的可选项，即没有 required 属性的元素Use the matchVariant function to register new parameterized variants like the built-in supports-  , data-  , and aria-* variants:   matchVariant 用于定义动态的装饰器  Use the sort option to control the source order of the generated CSS if needed to avoid precedence issues with other values that come from the same variant:\n   动态定义都支持  接收参数，可以实用 sort 选项控制生成的 class 的顺序Your custom modifiers won’t automatically work with Tailwind’s parent and sibling state modifiers.\n   自定义装饰器无法同 group 和 peer 这两个状态共同使用  To support the group-* and peer-* versions of your own custom modifiers, register them as separate variants using the special    directive to ensure the .group and .peer classes only appear once in the final selector.\n   需要支持化需要使用   显示的实现  注释：  应该是为了支持作用域而存在的，例如：Sometimes it makes sense for a plugin to be configurable in a way that doesn’t really belong under theme, like perhaps you want users to be able to customize the class name your plugin uses.\n   插件允许定义为可接收参数得形式The user can also register plugins created this way normally without invoking them if they don’t need to pass in any custom options:\n   用户还可以直接引用需要参数得插件函数，而不需要调用它CSS in-JS 语法\n   Tailwind’s plugin system expects CSS rules written as JavaScript objects, using the same sort of syntax you might recognize from CSS-in-JS libraries like Emotion, powered by postcss-js under-the-hood.\n   tailwind 在配置中把 js 对象编译为 css 文本，是通过 postcss-js 这个库实现  注释：  postcss-js  它可以把CSS代码转换成抽象语法树（AST），然后用API来分析和修改它。postcss-js提供了一个方便的方法，让你可以用CSS-in-JS的风格来写CSS，然后用PostCSS的插件来优化和转换它。  For convenience, property names can also be written in camelCase and will be automatically translated to dash-case:\n   属性名可以用驼峰形式  Nesting is also supported (powered by postcss-nested), using the same syntax you might be familiar with from Sass or Less:\n   支持&嵌套、媒体查询、伪元素、伪类，由   postcss-nested  提供支持…or as an array of objects in case you need to repeat the same key:\n   addComponents 等方法支持传入对象数组，以方便需要定义重复 key 的样式","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#presets-预设","title":"Presets 预设","titles":[],"content":"By default, presets themselves extend Tailwind’s default configuration just like your own configuration would. If you’d like to create a preset that completely replaces the default configuration, include an empty presets key in the preset itself:\n   默认情况下预设是对默认配置的扩展，即使是不使用 theme.extend，要覆盖默认配置需要在预设中配置 presets 为空数组  注释：因为预设中的 theme.extend 是用来扩展 plugin 提供的默认配置的The following options in tailwind.config.js simply replace the same option if present in a preset:\n   以下预设项会被直接替换  content  darkMode  prefix  important  variantOrder 能够使用的装饰符  separator 修饰符的分割符好  safelist 手动声明需要保留的类  The theme object is merged shallowly, with top-level keys in tailwind.config.js replacing the same top-level keys in any presets. The exception to this is the extend key, which is collected across all configurations and applied on top of the rest of the theme configuration.\n   theme 配置中除了 extend 外，其他都是浅层合并  The plugins array is merged across configurations to make it possible for a preset to register plugins while also allowing you to add additional plugins at the project-level.\n   插件会跨预设合并，所以无法禁用预设中的插件  The corePlugins option behaves differently depending on whether you configure it as an object or as an array.\n   corePlugins 的合并规则取决于主配置中值的类型  If you configure corePlugins as an object, it is merged across configurations.\n   如果值是对象，预设和主配置会合并为一个  If you configure corePlugins as an array, it replaces any corePlugins configuration provided by your configured preset(s).\n   如果是数组，主配置会覆盖预设中的值","level":1},{"id":"/notes/css/tailwind/tailwindcss-1#preflight-浏览器样式重置","title":"Preflight 浏览器样式重置","titles":[],"content":"Built on top of modern-normalize, Preflight is a set of base styles for Tailwind projects that are designed to smooth over cross-browser inconsistencies and make it easier for you to work within the constraints of your design system.\n   tailwind 基于   modern-normalize  生成浏览器重置样式  For a complete reference of all the styles applied by Preflight, see the stylesheet.\n    完整被重置的样式  Tailwind automatically injects these styles when you include @tailwind base in your CSS:\n   @tailwind base 会被自动注入到样式文件的顶部  Preflight removes all of the default margins from elements like headings, blockquotes, paragraphs, etc.\n   标题、块引号、段落等元素外据为 0  blockquote 代表其中的文字是引用内容，块级  dl 包含术语定义以及描述的列表，通常用于展示词汇表或者元数据 (键 - 值对列表)  dd 用来指明一个描述列表 (  ) 元素中一个术语的描述。  h1-h6、hr（分割线）、pre（保留格式的文本）  figure 代表一段独立的内容，可能包含    元素定义的说明元素。该插图、标题和其中的内容通常作为一个独立的引用单元\n   figure元素的内容应该与主内容相关，但如果被删除，不会影响主内容的流程  插入文档中的图像、插图、图表等  插入文档中的代码片段、公式、引用等  插入文档中的诗歌、歌词、对话等  All heading elements are completely unstyled by default, and have the same font-size and font-weight as normal text.\n   h1-h6 没有 font-size、font-weight 样式  If you’d like to selectively introduce sensible default heading styles into article-style parts of a page, we recommend the @tailwindcss/typography plugin.\n   @tailwindcss/typography 插件提供了 h1-h6、ol、ul 的默认样式  Ordered and unordered lists are unstyled by default, with no bullets/numbers and no margin or padding.\n   ol、ul 没有 list-style:none、margin、padding  Unstyled lists are not announced as lists by VoiceOver. If your content is truly a list but you would like to keep it unstyled, add a “list” role to the element:\n   没有样式的 ol、ul 不会被屏幕阅读器识别为列表，可以通过  显示声明它是一个列表  注释：屏幕阅读器可能是通过 list-style 识别的  注释：role属性为内容提供了语义，允许屏幕阅读器和其他工具与对象类型的用户预期一致的方式进行呈现并支持交互。  Images and other replaced elements (like svg, video, canvas, and others) are display: block by default.\n   图像和其他多媒体元素是块级的   img,svg,video,canvas,audio,iframe,  embed 将外部内容嵌入文档中的指定位置。此内容由外部应用程序或其他交互式内容源（如浏览器插件）提供。（不建议使用)  object 表示引入一个外部资源，这个资源可能是一张图片，一个嵌入的浏览上下文，亦或是一个插件所使用的资源\n   注释：可以通过data属性来指定资源的URL，也可以通过type属性来指定资源的MIME类型，object标签的内容是透明的，也就是说，如果浏览器不能显示或者加载object标签指定的资源，就会显示object标签内部的内容，作为替代或者提示。是 embed 的替代  Images and videos are constrained to the parent width in a way that preserves their intrinsic aspect ratio.\n   img、video 被设置了   In order to make it easy to add a border by simply adding the border class, Tailwind overrides the default border styles for all elements with the following rules:\n   为了便于实用类能快速生效，定了了  的样式为   注释：theme 的第二个参数是指参数一找不到对应配置时回退的默认值   https://www.tailwindcss.cn/docs/adding-base-styles   You can use the same approach to add your @font-face rules for any custom fonts you’re using:\n   实用 @font-face 添加自定义字体If you’d like to completely disable Preflight — perhaps because you’re integrating Tailwind into an existing project or because you’d like to provide your own base styles — all you need to do is set preflight to false in the corePlugins section of your tailwind.config.js file:\n   corePlugins.preflight:false 用于设置禁用样式重置","level":1},{"id":"/notes/css/tailwind/tailwindcss-init#nuxt-installation-tailwindcss","title":"Nuxt Installation tailwindcss","titles":[],"content":"","level":1},{"id":"/notes/css/tailwind/tailwindcss#tailwindcss","title":"tailwindcss","titles":[],"content":"在开发中，我们经常需要使用一些样式，而这些样式通常都是重复的，比如 margin、padding 等等。在屎山上堆屎的感觉https://github.com/tailwindlabs/tailwindcss","level":1},{"id":"/notes/db/edgedb/edage#edagedb","title":"EdageDB","titles":[],"content":"","level":1},{"id":"/notes/flutter/book#flutter实战第二版","title":"《Flutter实战·第二版》","titles":[],"content":"","level":1},{"id":"/notes/flutter/book#入门书箱","title":"入门书箱","titles":["《Flutter实战·第二版》"],"content":"1.   入门书箱","level":2},{"id":"/notes/front-end#前端开发推荐-front-end-recommendation","title":"前端开发推荐 Front end recommendation","titles":[],"content":"","level":1},{"id":"/notes/front-end#css","title":"CSS","titles":["前端开发推荐 Front end recommendation"],"content":"","level":2},{"id":"/notes/front-end#tailwindcss","title":"tailwindcss","titles":["前端开发推荐 Front end recommendation","CSS"],"content":"","level":3},{"id":"/notes/html/nofollow#一什么是nofollow标签","title":"一、什么是  nofollow标签","titles":[],"content":"nofollow标签是HTML页面中    标签的一个属性值。这个标签的意义是告诉搜索引擎不要追踪此网页上的链接或不要追踪此特定链接。它可以被看作是一个指示牌，告诉搜索引擎这个链接不是经过作者信任的，因此不应该被视为一个信任票。当搜索引擎看到nofollow标签时，它可能会减少或完全取消该链接的投票权重。nofollow标签一般指Nofollow，是HTML页面中A标签的属性，故又称为nofollow属性。该标签告诉搜索引擎这个链接不是作者推荐的，不要追踪此网页上的链接和传递权重，以减少垃圾链接，分散网站权重。nofollow标签最初被设计用来应对垃圾链接（Spam），它的作用主要是两方面：   一是不给链接投票，降低此链接的权重；  二是使添加nofollow的部分内容不参与网站排名，这样可以集中网站权重，减少权重的分散。这种方式可以帮助网站管理员更好地控制搜索引擎对其网页的追踪和评估，从而改善搜索结果的质量，并防止垃圾链接的蔓延。![什么是nofollow标签]nofollow这个概念最初是由谷歌公司在2005年的时候提出来的，并被百度、yahoo等各大搜索引擎广泛支持，是一个\"反垃圾链接\"的标签，当时提出这个标签的解释主要是为了应付越来越泛滥的外链群发作弊，意思就是说，只要加入了这个nofollow标签的链接，搜索蜘蛛就不会进行爬行。","level":2},{"id":"/notes/html/nofollow#二nofollow标签的正确使用方法","title":"二、nofollow标签的正确使用方法","titles":[],"content":"1、用于meta元标签这段代码告诉搜索引擎不要抓取网页上的所有链接，和包括内部链接、外部链接。Content里index、noindex、follow、nofollow标签结合使用：：可以抓取本页，而且可以顺着本页继续索引别的链接。：不许抓取本页，但是可以顺着本页抓取索引别的链接。：可以抓取本页，但是不许顺着本页抓取索引别的链接。：不许抓取本页，也不许顺着本页抓取索引别的链接。2、用于a标签这段代码在超链接中加入nofollow属性，意思是告诉搜索引擎不要追踪这个链接。","level":2},{"id":"/notes/html/nofollow#三nofollow标签应用场景","title":"三、nofollow标签应用场景","titles":[],"content":"通过合理使用nofollow标签，网站管理员可以更好地控制链接的权重分配，提高网站的搜索引擎优化效果，并有效防止垃圾链接的扩散。nofollow标签在多种场景中具有实际应用，主要包括以下几个方面：论坛帖子和博客评价 ：这些地方通常存在大量的其他网站链接，其中可能包含垃圾链接，影响搜索引擎蜘蛛的爬取。使用nofollow标签可以避免给这些链接传递权重，防止垃圾链接的过度滋生。   广告链接 ：给广告链接加上nofollow可以明确告诉搜索引擎，这是一个广告链接，不应该传递链接权重。这样做有助于遵守搜索引擎的指南，确保广告链接不会被误认为是编辑推荐。   网站内部链接 ：对于网站内部的一些无用页面，如法律声明、版权声明等，加上nofollow标签可以阻止整个网站的权重传递到这些页面上。这样做可以确保网站的权重更集中地分配到其他更有价值的页面上。   购物车和注册页面 ：这些页面通常对搜索引擎不友好，使用nofollow标签可以阻止搜索引擎索引这些页面，从而提高网站的SEO效果。   自定义付费链接 ：为了遵循搜索引擎的指南，付费链接通常会被添加nofollow标签。这样做可以表明这不是一个编辑上的推荐链接，搜索引擎不应该传递该链接的权重。","level":2},{"id":"/notes/html/nofollow#四nofollow标签的作用","title":"四、nofollow标签的作用","titles":[],"content":"通常情况下，反向链接是会传递权重的，所以一些做  SEO 的为了添加反向链接，就在论坛和博客等大量发布带无关链接的内容。这些垃圾链接的存在给搜索引擎对网页质量的评估造成一定程度的麻烦。因此，在这种情况下，nofollow正是几大搜索引擎商(比如，Google、Yahoo、百度等)为了应对垃圾链接(Spam)引入的一个属性。 其作用具体表现为以下几方面。1、Nofollow可以帮助你区分链接自然的外链是多种多样的。一些链接是dofollow链接，另外的则是nofollow链接。这个事实是不可避免的，因为有些人不可避免地会通过nofollow链接链接到你。总之，如果一个网站只有dofollow链接，或者是占比非常高，那么就非常的可疑了。2、Nofollow链接可以防止百度谷歌惩罚如果你的内容页面，由于社会关系，碍于情面必须要链接某位熟人的低质量内容，那么你完全可以利用Nofollow标签，屏蔽这个链接，从而避免链接大量垃圾页面而遭到惩罚。3、引导爬虫抓取有效的页面链接不仅对SEO有用。它们也可以提高引荐流量。如果一个nofollow链接带来了有效价值的用户访问，说明这个链接对用户是有价值的，对搜索引擎来说就是dofollow的链接机会。4、提升锚文本的影响力虽然Nofollow标签并不能传递权重，但是来自高权重，知名站点的Nofllow链接，仍然对中小网站有着积极推动的作用，基于庞大的用户群，它有利于企业网站的曝光。**注意：**网站上添加了nofollow属性标签并不代表搜索引擎不收录那个链接，没有说不要抓取链接指向的URL，也没有说不要索引链接指向的URL，nofollow既没禁止抓取，也没禁止索引，只是不将这个链接计算入反向链接而已。链接加了nofollow，不意味着别的地方就没有正常的指向这个URL的链接，只要别的地方出现了没加nofollow的链接，目标URL还是会被发现、抓取(假设没被robotx文件禁止)、索引(假设没加noindex )。","level":2},{"id":"/notes/html/nofollow#五nofollow与robots的区别","title":"五、nofollow与robots的区别","titles":[],"content":"很多时候nofollow和robots一并被人提起，因为一般看来都有一个效果——让搜索引擎不要抓取某个页面。这里因为多种搜索引擎的不同处理方式是有不同情况的：百度：百度爬虫极有可能会爬行nofollow链接，所以试图用nofollow来屏蔽某个页面不被抓取是不妥当的，必须辅以  robots文件 。而robots文件已经屏蔽的页面，是不会获得权重的。Google：Google爬虫不会爬行nofollow链接，但是只要页面有一个dofollow链接，依然是有可能被抓取的，想要屏蔽页面最妥当的方式还是采用robots文件。因为不同搜索引擎对待这两个东西的方式不尽相同，所以当需要屏蔽页面的时候，应当把这两个都用上。","level":2},{"id":"/notes/html/nofollow#六百度与google对待nofollow标签的态度","title":"六、百度与Google对待nofollow标签的态度","titles":[],"content":"1、百度对于nofollow标签的态度网页级：< meta name=\"robots\" content=\"nofollow\" > 不追踪链接，不传递权重。链接级：< a rel=\"nofollow\" href=\"#\" >123< /a >跟踪链接并记录锚文本，但不传递权重。2、Google对待nofollow标签的态度Google对于nofollow：最近的google搜索引擎优化初学者指南中明确指出：如果您把某一链接的\"rel\"属性设置成\"nofollow\" , 这意味着您是在向Google传达这样的信息 : 您不希望Google继续跟踪抓取这些特定链接所指向的页面 , 并且也不希望将自己网页的声誉传给这些链接指向的网页。（也就是不跟踪知道的nofollow链接也不传递相应的权重）。","level":2},{"id":"/notes/html/nofollow#七链接属性的重大变化","title":"七、链接属性的重大变化","titles":[],"content":"1、增加了两个新的属性：rel=\"sponsored\":  这个新属性/标签用于标注广告、赞助商或其它因利益而存在的链接。rel=\"ugc\":  这个新属性/标签用于UGC（用户产生内容），如论坛帖子、博客评论之类的。rel=\"nofollow\":  这个老的属性/标签依然用于没有任何投票、背书意味的链接，也不传递排名权重。换句话说，新公布的两个标签是为广告和UGC各新创了一个专用标签。2、这三个标签将被搜索引擎算法在决定链接是否应该被考虑时视为一个暗示，更容易理解点的词是一个建议，而不是指令。以前的nofollow基本上是一个指令，搜索引擎会忽略加了nofollow的链接，在计算权重流动时根本不考虑这个链接。但变更以后，只把这三个标签当作建议，搜索引擎的算法是否考虑这个链接，由搜索引擎自行综合其它因素来做决定。","level":2},{"id":"/notes/html/nofollow#八nofollow标签常见问答","title":"八、nofollow标签常见问答","titles":[],"content":"1、链接中有Nofollow属性是否算外链？从主流SEO平台对nofollow跟踪来说，有专门nofollow链接的分析，归属为网站外链的一种类型，由此可以看出链接中有Nofollow属性也算一种外链，因为这种链接如果出现位置好是可以吸引用户的。2、Nofollow标签去除重复链接有什么效果?加入Nofollow标签并不能像我们想象中的那样节约很多时间，因为百度站长指南中就明确的说了，蜘蛛会将网站第一个链接抓取后，重复出现的并不会给予权值，且只做记录作用。所以为了节约时间而使用Nofollow标签去除重复性链接根本就是多此一举。总结优化猩SEO：如果你正在进行网站的外链建设，尤其是进行友情链接交换，务必查看对方网站是否添加nofollow，如果添加了nofollow属性，将导致该友情链接失去了本来的意义，因为这些链接不会传递网站权重，对网站  SEO优化 没有效果。参考链接：Nofollow_百度百科https://baike.baidu.com/item/Nofollow/2410595NOFOLLOW是什么意思 - 百度经验https://jingyan.baidu.com/article/3aed632e6627877010809101.htmlnofollow标签_nofollow是什么意思及nofollow作用-CSDN博客https://blog.csdn.net/weixin_39729840/article/details/111679084不断完善 nofollow - 确定链接性质的几种新方法 _ Google 搜索中心https://developers.google.com/search/blog/2019/09/evolving-nofollow-new-ways-to-identify?hl=zh-cnnofollow常见问题解答 - 卢松松博客https://lusongsong.com/reed/397.html修改于2023-05-05","level":2},{"id":"/notes/html/tags/a#a-标签","title":"A 标签","titles":[],"content":"","level":1},{"id":"/notes/js/js-yaml#yaml与json互转-typescript","title":"Yaml与JSON互转 typescript","titles":[],"content":"在 TypeScript（或 JavaScript）中，你可以使用第三方库如    来实现 YAML 和 JSON 之间的转换。以下是如何进行转换的示例：","level":1},{"id":"/notes/js/js-yaml#_1-安装-js-yaml","title":"1. 安装   js-yaml","titles":["Yaml与JSON互转 typescript"],"content":"首先，你需要安装    库。你可以使用 npm 或 yarn 来安装它：","level":3},{"id":"/notes/js/js-yaml#_2-在-typescript-中使用-js-yaml","title":"2. 在 TypeScript 中使用   js-yaml","titles":["Yaml与JSON互转 typescript"],"content":"安装完成后，你可以在 TypeScript 文件中导入并使用它：注意：方法用于将 JSON 对象转换为 YAML 字符串。    方法用于将 YAML 字符串转换为 JSON 对象。在    中，我们传递了    选项，以确保返回的是一个标准的 JSON 对象，而不是其他可能的类型（如 Date 对象或 RegExp 对象）。这在处理复杂 YAML 结构时特别有用，可以确保得到一致的 JSON 输出。然而，如果你确定 YAML 字符串只包含简单的键值对，并且希望保留某些特殊类型，你可以省略这个选项。  在 TypeScript 中，由于类型系统的存在，我们可能需要对    的返回值进行类型断言（如   ），以便能够正确地使用它。","level":3},{"id":"/notes/net/iczp-nuget#iczpnet-nuget包","title":"IczpNet Nuget包","titles":[],"content":"https://www.nuget.org/packages?q=IczpNet","level":1},{"id":"/notes/net/iczp-nuget#iczpnetabptrees","title":"IczpNet.AbpTrees","titles":["IczpNet Nuget包"],"content":"An abp module that provides standard tree structure entity implement.","level":2},{"id":"/notes/net/iczp-nuget#create-project-by-abp-cli","title":"Create project by Abp Cli","titles":["IczpNet Nuget包","IczpNet.AbpTrees"],"content":"","level":3},{"id":"/notes/net/iczp-nuget#build","title":"Build","titles":["IczpNet Nuget包","IczpNet.AbpTrees"],"content":"https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-build","level":3},{"id":"/notes/net/iczp-nuget#public-to-nugetorg","title":"Public to Nuget.org","titles":["IczpNet Nuget包","IczpNet.AbpTrees"],"content":"Installation","level":3},{"id":"/notes/net/iczp-nuget#install-the-following-nuget-packages-see-how","title":"Install the following NuGet packages. (see how)","titles":["IczpNet Nuget包","IczpNet.AbpTrees","Public to Nuget.org"],"content":"IczpNet.AbpTrees.Domain  IczpNet.AbpTrees.Application  IczpNet.AbpTrees.Application.Contracts  IczpNet.AbpTrees.Domain.Shared","level":5},{"id":"/notes/net/iczp-nuget#add-dependsontypeofabptreesxxxmodule-attribute-to-configure-the-module-dependencies","title":"Add   DependsOn(typeof(AbpTreesXxxModule))  attribute to configure the module dependencies.","titles":["IczpNet Nuget包","IczpNet.AbpTrees","Public to Nuget.org"],"content":"","level":5},{"id":"/notes/net/iczp-nuget#internal-structure","title":"Internal structure","titles":["IczpNet Nuget包"],"content":"","level":2},{"id":"/notes/net/iczp-nuget#iczpnetabptreesdomain","title":"IczpNet.AbpTrees.Domain","titles":["IczpNet Nuget包","Internal structure"],"content":"","level":4},{"id":"/notes/net/iczp-nuget#itreeentity","title":"ITreeEntity","titles":["IczpNet Nuget包","Internal structure","IczpNet.AbpTrees.Domain"],"content":"","level":5},{"id":"/notes/net/iczp-nuget#treeentity","title":"TreeEntity","titles":["IczpNet Nuget包","Internal structure","IczpNet.AbpTrees.Domain"],"content":"","level":5},{"id":"/notes/net/iczp-nuget#itreemanager","title":"ITreeManager","titles":["IczpNet Nuget包","Internal structure","IczpNet.AbpTrees.Domain"],"content":"","level":5},{"id":"/notes/net/iczp-nuget#treemanager","title":"TreeManager","titles":["IczpNet Nuget包","Internal structure","IczpNet.AbpTrees.Domain"],"content":"","level":5},{"id":"/notes/net/iczp-nuget#iczpnetabptreesapplicationcontracts","title":"IczpNet.AbpTrees.Application.Contracts","titles":["IczpNet Nuget包","Internal structure","IczpNet.AbpTrees.Domain"],"content":"","level":4},{"id":"/notes/net/iczp-nuget#itreeappservice","title":"ITreeAppService","titles":["IczpNet Nuget包","Internal structure","IczpNet.AbpTrees.Domain","IczpNet.AbpTrees.Application.Contracts"],"content":"","level":5},{"id":"/notes/net/iczp-nuget#dtos","title":"Dtos","titles":["IczpNet Nuget包","Internal structure","IczpNet.AbpTrees.Domain"],"content":"","level":4},{"id":"/notes/net/iczp-nuget#itreegetlistinput","title":"ITreeGetListInput","titles":["IczpNet Nuget包","Internal structure","IczpNet.AbpTrees.Domain","Dtos"],"content":"","level":5},{"id":"/notes/net/iczp-nuget#itreeinput","title":"ITreeInput","titles":["IczpNet Nuget包","Internal structure","IczpNet.AbpTrees.Domain","Dtos"],"content":"","level":5},{"id":"/notes/net/iczp-nuget#treegetlistinput","title":"TreeGetListInput","titles":["IczpNet Nuget包","Internal structure","IczpNet.AbpTrees.Domain","Dtos"],"content":"","level":5},{"id":"/notes/net/iczp-nuget#iczpnetabptreesapplication","title":"IczpNet.AbpTrees.Application","titles":["IczpNet Nuget包","Internal structure","IczpNet.AbpTrees.Domain"],"content":"","level":4},{"id":"/notes/net/iczp-nuget#treeappservice","title":"TreeAppService","titles":["IczpNet Nuget包","Internal structure","IczpNet.AbpTrees.Domain","IczpNet.AbpTrees.Application"],"content":"","level":5},{"id":"/notes/net/iczp-nuget#usage","title":"Usage","titles":["IczpNet Nuget包"],"content":"https://github.com/Iczp/AbpTrees/tree/master/Example","level":2},{"id":"/notes/net/iczp-nuget#create-a-entity","title":"Create a entity","titles":["IczpNet Nuget包","Usage"],"content":"Create a entity     and implement   .","level":4},{"id":"/notes/net/iczp-nuget#create-model","title":"Create Model","titles":["IczpNet Nuget包","Usage"],"content":"Create    and implement    in project","level":4},{"id":"/notes/net/iczp-nuget#repository","title":"Repository","titles":["IczpNet Nuget包","Usage"],"content":"","level":4},{"id":"/notes/net/iczp-nuget#create-dto","title":"Create Dto","titles":["IczpNet Nuget包","Usage"],"content":"","level":4},{"id":"/notes/net/iczp-nuget#interface-crud","title":"interface CRUD","titles":["IczpNet Nuget包","Usage"],"content":"IDepartmentAppSevice and implement   ,","level":4},{"id":"/notes/net/iczp-nuget#application-crud","title":"Application CRUD","titles":["IczpNet Nuget包","Usage"],"content":"","level":4},{"id":"/notes/net/iczp-nuget#dto-mapper","title":"Dto Mapper","titles":["IczpNet Nuget包","Usage"],"content":"","level":4},{"id":"/notes/net/iczp-nuget#add-migration-iczpnetabptreesdemohttpapihost","title":"Add-Migration   IczpNet.AbpTreesDemo.HttpApi.Host","titles":["IczpNet Nuget包","Usage"],"content":"Select Project   , Set Run Start.  Open PM      Add Controller","level":4},{"id":"/notes/net/iczp-nuget#run","title":"Run","titles":["IczpNet Nuget包"],"content":"Set as Startup Project:   ConnectionStrings:     Set PM(Package Management Console) default Project:   add-migration and update database","level":2},{"id":"/notes/net/iczp-nuget#upgrade-v1013add-property-childrencount","title":"Upgrade v1.0.13(Add Property ChildrenCount)","titles":["IczpNet Nuget包","Run"],"content":"","level":4},{"id":"/notes/net/push-nuget#在net-core中发布包到nuget主要包含以下步骤","title":"在.NET Core中发布包到NuGet主要包含以下步骤：","titles":[],"content":"","level":1},{"id":"/notes/net/push-nuget#一准备工作","title":"一、准备工作","titles":["在.NET Core中发布包到NuGet主要包含以下步骤："],"content":"在NuGet官方注册一个账号，或者直接使用微软账号登录。","level":2},{"id":"/notes/net/push-nuget#二创建项目并生成nuget包","title":"二、创建项目并生成NuGet包","titles":["在.NET Core中发布包到NuGet主要包含以下步骤："],"content":"创建一个类库项目。这通常是一个.NET Standard或.NET Core类库，确保项目的兼容性。  编写代码。实现你想要在NuGet包中提供的功能。  配置NuGet包信息。在项目文件中（通常是.csproj），你需要设置一些NuGet包的元数据，如包ID、版本、作者、描述等。这些可以在  标签内设置，例如：生成NuGet包。在命令行中使用  命令来生成NuGet包。确保你在项目的根目录下运行此命令。这将生成一个.nupkg文件，这就是你的NuGet包。","level":2},{"id":"/notes/net/push-nuget#三上传发布到nuget","title":"三、上传发布到NuGet","titles":["在.NET Core中发布包到NuGet主要包含以下步骤："],"content":"","level":2},{"id":"/notes/net/push-nuget#","title":"","titles":["在.NET Core中发布包到NuGet主要包含以下步骤："],"content":"上传NuGet包。使用NuGet的命令行工具  或者通过NuGet的官方网站来上传你的.nupkg文件。如果你使用命令行工具，需要确保你已经安装了NuGet CLI，并且已经登录到你的NuGet账号。其中，  是你的NuGet包文件名，  是NuGet的官方推送源，  是你在NuGet账号中生成的API密钥。等待后台处理。上传完成后，NuGet会进行后台处理，包括验证包的有效性、扫描病毒等。处理完成后，你的包就会显示在NuGet的包列表中。  在NuGet或Visual Studio中查看和引用。你的包发布后，其他开发者就可以在NuGet官方网站搜索到你的包，并在他们的项目中进行引用。同时，在Visual Studio的NuGet包管理器中也可以搜索和安装你的包。","level":2},{"id":"/notes/net/push-nuget#四参考","title":"四、参考","titles":["在.NET Core中发布包到NuGet主要包含以下步骤："],"content":"","level":2},{"id":"/notes/npm/pkg/js-yaml#js-yaml","title":"js-yaml","titles":[],"content":"","level":1},{"id":"/notes/npm/publish#发布-npm-包","title":"发布 NPM 包","titles":[],"content":"发布 NPM 包","level":1},{"id":"/notes/npm/publish#发布流程","title":"发布流程","titles":["发布 NPM 包"],"content":"注册账号    登录账号    创建项目    发布项目","level":2},{"id":"/notes/npm/publish#注册账号","title":"注册账号","titles":["发布 NPM 包"],"content":"","level":2},{"id":"/notes/npm/publish#测试","title":"测试","titles":["发布 NPM 包","注册账号"],"content":"","level":3},{"id":"/notes/nuxt/nuxt-generate#在-nuxt-3-中如果你想将-tailwind-css-提取到一个单独的文件而不是内联在-html-源文件中你可以遵循以下步骤","title":"在 Nuxt 3 中，如果你想将 Tailwind CSS 提取到一个单独的文件而不是内联在 HTML 源文件中，你可以遵循以下步骤：","titles":[],"content":"安装依赖 ： 确保你已经安装了    和相关的 PostCSS 依赖。或者使用 yarn：配置 Tailwind ： 在项目的根目录下创建一个    文件，并配置 Tailwind。这是一个基本的配置示例：设置 PostCSS ： 在项目的根目录下创建一个    文件，并配置 PostCSS 以使用 Tailwind。例如：在 Nuxt 3 中引入 Tailwind ： 打开    (或   ，取决于你的项目类型)，并配置 CSS 部分以引入 Tailwind。例如：在    文件中，你应该引入 Tailwind 的基础、组件和实用程序样式：提取 CSS 到单独的文件 ： 为了确保 Tailwind CSS 被提取到一个单独的文件而不是内联在 JavaScript 包中，你可以在    中配置    选项来设置    为   。例如：运行项目 ： 现在，当你运行 Nuxt 3 项目时，Tailwind CSS 应该会被提取到一个或多个单独的 CSS 文件中，而不是内联在 HTML 源文件中。你可以通过查看浏览器的开发者工具来确认这一点，检查加载的 CSS 文件。请注意，这些步骤可能会根据你的具体需求和项目设置有所不同。确保根据你的实际情况进行调整。","level":1},{"id":"/notes/readme#readmemd","title":"README.md","titles":[],"content":"","level":1},{"id":"/notes/tailwind/nuxtjs#nuxt3中使用tailwind","title":"Nuxt3中使用Tailwind @@@@","titles":[],"content":"官方网站：  https://www.tailwindcss.cn/docs/guides/nuxtjs#standard","level":1},{"id":"/notes/tailwind/nuxtjs#步骤","title":"步骤","titles":["Nuxt3中使用Tailwind @@@@"],"content":"Create your project Start by creating a new Nuxt project if you don’t have one set up already. The most common approach is to use the   Nuxt Command Line Interface .  Terminal     Install Tailwind CSS Install    and i peer dependencies via npm, and then run the init command to generate a    file.  Terminal     Add Tailwind to your PostCSS configuration Add    and    to the    object in your    file.  nuxt.config.js     Configure your template paths Add the paths to all of your template files in your    file.  tailwind.config.js     Add the Tailwind directives to your CSS Create an    file and add the    directives for each of Tailwind’s layers.  main.css     Add the CSS file globally Add your newly-created    to the    array in your    file.  nuxt.config.js     Start your build process Run your build process with   .  Terminal     Start using Tailwind in your project Start using Tailwind’s utility classes to style your content.  app.vue","level":2},{"id":"/notes/uniapp/guide#uni-app","title":"Uni App","titles":[],"content":"","level":1}]