[{"id":"/#安装","title":"安装","titles":[],"content":"安装依赖This page corresponds to the    route of your website. You can delete it or create another file in the    directory.Try to navigate to   about . These 2 pages are rendered by the    component.","level":2},{"id":"/#yamlyml","title":"Yaml/yml","titles":[],"content":"","level":2},{"id":"/docs/guide#指南","title":"指南","titles":[],"content":"","level":1},{"id":"/docs/wmsxwd#我们所向住的","title":"我们所向住的","titles":[],"content":"不好说...","level":2},{"id":"/about/about#vvllnetvite-vue-link-lab主要记录一些相关开发文档的资源和信息","title":"VVLL.net（Vite Vue Link Lab）主要记录一些相关开发文档的资源和信息。","titles":[],"content":"以下是该网站的主要内容和特点：Vite ：网站涵盖了关于 Vite 的开发文档和指南，介绍了 Vite 作为一个现代化的构建工具的特性和用法，帮助开发者快速了解和使用 Vite 进行项目开发。   Vue ：网站包含了关于 Vue.js 框架的开发文档和教程，涵盖了 Vue 的基础知识、组件开发、状态管理等方面的内容，帮助开发者掌握 Vue.js 的使用技巧。   Link Lab ：Link Lab 部分提供了有关前端开发中常用的链接、资源和工具，包括前端框架、UI 库、插件等相关内容，帮助开发者发现和使用与前端开发相关的资源。通过 VVLL.net，开发者可以获取关于 Vite、Vue 和前端开发相关的最新资讯、文档和教程，帮助他们更好地理解和应用这些技术，提升前端开发能力和效率。","level":2},{"id":"/about/pkg#以下是packagejson-的配置信息","title":"以下是  package.json  的配置信息","titles":[],"content":"如题","level":2},{"id":"/authors/iczp#iczpnet思源-10000intrycn","title":"IczpNet(思源) <10000#intry.cn>","titles":[],"content":"q  ddd","level":1},{"id":"/authors/zhongpei#zhongpei心雨-10000intrycn","title":"Zhongpei(心雨) <10000#intry.cn>","titles":[],"content":"q  ddd","level":1},{"id":"/notes/hybrid/clipboard#剪切版clipboard的使用","title":"剪切版(Clipboard)的使用","titles":[],"content":"","level":1},{"id":"/notes/hybrid/clipboard#vueuse","title":"Vueuse","titles":["剪切版(Clipboard)的使用"],"content":"https://vueuse.org/core/useClipboard/#useclipboard","level":2},{"id":"/notes/hybrid/clipboard#组件使用","title":"组件使用","titles":["剪切版(Clipboard)的使用"],"content":"该函数还通过包提供了无渲染组件版本@vueuse/components。详细了解用法。","level":2},{"id":"/notes/hybrid/icon#图标","title":"图标","titles":[],"content":"","level":2},{"id":"/notes/hybrid/icon#trees","title":"Trees","titles":["图标"],"content":"Trees","level":3},{"id":"/notes/hybrid/icon#trees-1","title":"Trees-1","titles":["图标","Trees"],"content":"Trees-1","level":4},{"id":"/notes/js/dayjs#安装","title":"安装","titles":[],"content":"可以通过 npm 或 yarn 安装 Day.js：或者","level":3},{"id":"/notes/js/dayjs#基本用法","title":"基本用法","titles":[],"content":"以下是 Day.js 的一些基本用法示例：","level":3},{"id":"/notes/js/dayjs#导入-dayjs","title":"导入 Day.js","titles":["基本用法"],"content":"","level":4},{"id":"/notes/js/dayjs#获取当前日期和时间","title":"获取当前日期和时间","titles":["基本用法"],"content":"","level":4},{"id":"/notes/js/dayjs#解析日期","title":"解析日期","titles":["基本用法"],"content":"","level":4},{"id":"/notes/js/dayjs#格式化日期","title":"格式化日期","titles":["基本用法"],"content":"","level":4},{"id":"/notes/js/dayjs#操作日期","title":"操作日期","titles":["基本用法"],"content":"","level":4},{"id":"/notes/js/dayjs#比较日期","title":"比较日期","titles":["基本用法"],"content":"","level":4},{"id":"/notes/js/dayjs#使用插件","title":"使用插件","titles":["基本用法","比较日期"],"content":"Day.js 提供了多种插件，可以扩展其功能。使用插件前需要加载并使用它们。","level":3},{"id":"/notes/js/dayjs#加载插件","title":"加载插件","titles":["基本用法","比较日期","使用插件"],"content":"","level":4},{"id":"/notes/js/dayjs#常用插件","title":"常用插件","titles":["基本用法","比较日期","使用插件"],"content":"Advanced Format : 提供更多的日期格式化选项。   Relative Time : 支持相对时间显示（如 \"3 hours ago\"）。   UTC : 提供 UTC 时间支持。   Timezone : 提供时区支持。   Duration : 提供时间间隔的支持。","level":4},{"id":"/notes/js/dayjs#示例","title":"示例","titles":["基本用法","比较日期"],"content":"","level":3},{"id":"/notes/js/dayjs#使用-advanced-format-插件","title":"使用 Advanced Format 插件","titles":["基本用法","比较日期","示例"],"content":"","level":4},{"id":"/notes/js/dayjs#使用-utc-插件","title":"使用 UTC 插件","titles":["基本用法","比较日期","示例"],"content":"","level":4},{"id":"/notes/js/dayjs#使用-timezone-插件","title":"使用 Timezone 插件","titles":["基本用法","比较日期","示例"],"content":"","level":4},{"id":"/notes/js/dayjs#注意事项","title":"注意事项","titles":["基本用法","比较日期"],"content":"Day.js 默认是不可变的，这意味着每次操作都会返回一个新的 Day.js 对象，而不是修改原来的对象。  Day.js 不支持本地化的时间差（  ），可以使用插件来实现这类功能。Day.js 提供了丰富的功能和灵活的插件机制，使其成为处理日期和时间的强大工具，同时保持了库的轻量级和高性能。","level":3},{"id":"/notes/nuxt/nuxt-tailwind#nuxt3-中使用-tailwind-css","title":"Nuxt3 中使用 Tailwind CSS","titles":[],"content":"创建项目 如果您尚未设置 Nuxt 项目，请先创建一个新的 Nuxt 项目。最常见的方法是使用  Nuxt 命令行界面 。  终端     安装 Tailwind CSS 通过 npm 安装  及其对等依赖项，然后运行 init 命令生成文件  。  终端     将 Tailwind 添加到你的 PostCSS 配置中 将  和添加  到文件中的对象。         配置模板路径 在您的文件中添加所有模板文件的路径   。       将 Tailwind 指令添加到你的 CSS 创建一个  文件并   为 Tailwind 的每个层添加指令。  主.css     全局添加 CSS 文件 将新创建的内容添加  到文件  中的数组中  。       开始构建过程 使用 运行您的构建过程  。  终端     开始在你的项目中使用 Tailwind 开始使用 Tailwind 的实用程序类来设置您的内容样式。","level":1},{"id":"/notes/tools/ai#_1-语言模型和对话系统","title":"1. 语言模型和对话系统","titles":[],"content":"OpenAI : GPT-4, ChatGPT   Google : Bard (基于 LaMDA), Google Assistant   Microsoft : Azure OpenAI Service (整合 OpenAI 的模型), Cortana   Amazon : Alexa   Apple : Siri","level":3},{"id":"/notes/tools/ai#_2-计算机视觉","title":"2. 计算机视觉","titles":[],"content":"NVIDIA : DeepStream SDK, Jetson 设备   Google : Google Cloud Vision AI   Microsoft : Azure Computer Vision   IBM : Watson Visual Recognition   Clarifai : AI 平台专注于图像和视频分析","level":3},{"id":"/notes/tools/ai#_3-语音识别和生成","title":"3. 语音识别和生成","titles":[],"content":"Google : Google Cloud Speech-to-Text, Google Text-to-Speech   Microsoft : Azure Speech Service   Amazon : Transcribe, Polly   IBM : Watson Speech to Text, Text to Speech   Nuance Communications : Dragon NaturallySpeaking","level":3},{"id":"/notes/tools/ai#_4-推荐系统","title":"4. 推荐系统","titles":[],"content":"Netflix : 内容推荐算法   Spotify : 音乐推荐系统   Amazon : 商品推荐引擎   YouTube : 视频推荐系统   Alibaba : 电子商务推荐系统","level":3},{"id":"/notes/tools/ai#_5-自动驾驶和辅助驾驶","title":"5. 自动驾驶和辅助驾驶","titles":[],"content":"Tesla : Autopilot, Full Self-Driving (FSD)   Waymo : Waymo Driver   NVIDIA : Drive AI 平台   Uber ATG : 自动驾驶技术（已被 Aurora 收购）   Baidu : Apollo 自动驾驶平台","level":3},{"id":"/notes/tools/ai#_6-医疗健康-ai","title":"6. 医疗健康 AI","titles":[],"content":"IBM Watson Health : 医疗诊断和治疗建议   Google Health : 基于 AI 的医疗研究和产品   Philips : HealthSuite AI   Butterfly Network : AI 超声波成像   Zebra Medical Vision : 医疗影像分析","level":3},{"id":"/notes/tools/ai#_7-金融科技-ai","title":"7. 金融科技 AI","titles":[],"content":"Kensho : 数据分析和金融市场预测   Numerai : 对冲基金数据科学竞赛平台   Zest AI : 信用评分和风险管理   Affirm : AI 驱动的贷款和信用服务   Sentifi : 金融市场情绪分析","level":3},{"id":"/notes/tools/ai#_8-工业和制造业-ai","title":"8. 工业和制造业 AI","titles":[],"content":"Siemens : MindSphere AI 平台   GE : Predix 平台   IBM : Maximo AI 资产管理   Rockwell Automation : FactoryTalk Analytics   Uptake : 工业数据分析平台","level":3},{"id":"/notes/tools/ai#_9-教育和学习-ai","title":"9. 教育和学习 AI","titles":[],"content":"Coursera : 个性化学习推荐   Duolingo : AI 驱动的语言学习   Khan Academy : 自适应学习平台   Quizlet : 学习辅助工具   Squirrel AI : 自适应学习系统","level":3},{"id":"/notes/tools/ai#_10-安全和监控-ai","title":"10. 安全和监控 AI","titles":[],"content":"Darktrace : 网络安全 AI   CrowdStrike : 网络威胁检测和响应   Securonix : 安全信息和事件管理 (SIEM)   Verkada : 智能监控摄像头   Clearview AI : 面部识别技术（有争议）","level":3},{"id":"/notes/tools/ai#总结","title":"总结","titles":[],"content":"市场上的 AI 产品和技术覆盖了广泛的应用领域，从语言处理和计算机视觉到医疗、金融、工业和教育等各个方面。每个领域都有一些领先的公司和产品，通过不断创新和优化，推动着 AI 技术的发展和普及。这些技术的应用不仅提高了各行各业的效率和质量，也在改变着我们的生活方式。","level":3},{"id":"/notes/tools/colors-generator#tailwind-css-颜色生成器","title":"Tailwind CSS 颜色生成器","titles":[],"content":"Tailwind CSS Color Generator   https://uicolors.app/","level":2},{"id":"/notes/tools/img2svg#图片转-svg","title":"图片转 Svg","titles":[],"content":"https://picsvg.com/","level":2},{"id":"/notes/tools/img2svg#png-to-svg","title":"Png to SVG","titles":[],"content":"https://www.pngtosvg.com/","level":2},{"id":"/notes/tools/svg2img#svg-转图片-png","title":"SVG 转图片 PNG","titles":[],"content":"https://svgtopng.com/zh/SVG 的优点和缺点\n在网络上使用 SVG 图像有很多优点。 它们与分辨率无关，这意味着它们可以被缩放到任何尺寸而不损失质量。 由于 SVG 是由 W3C 开发的开放标准，现代浏览器，如 Mozilla Firefox、Opera、Apple Safari 和 Google Chrome，可以原生显示这些类型的图像。 另外，如前所述，它们可以以任何分辨率打印，并可以用矢量设计工具进行编辑。但是，使用 SVG 格式也有一些缺点。 它的支持没有光栅图像格式那么广泛，这意味着虽然现代浏览器可以显示 SVG 图像，但旧的浏览器可能无法显示。 不同的开发平台和库可能对 SVG 功能有不同的解释，甚至对 SVG 的支持非常有限，甚至没有。 另外，SVG 不能用于有很多细节的复杂图像，比如照片。","level":1},{"id":"/notes/ts/array/includes#typescript-中的数组-arrayprototypeincludes-方法","title":"TypeScript 中的数组 Array.prototype.includes 方法","titles":[],"content":"Array.prototype.includes 方法用于判断数组是否包含某个指定的值，返回一个布尔值。它是 ES2016 引入的一部分，TypeScript 支持这一特性。在 TypeScript 中，   方法用于判断数组是否包含某个指定的值，返回一个布尔值。它是 ES2016 引入的一部分，TypeScript 支持这一特性。以下是    方法的详细用法介绍：","level":2},{"id":"/notes/ts/array/includes#基本语法","title":"基本语法","titles":["TypeScript 中的数组 Array.prototype.includes 方法"],"content":"：需要在数组中搜索的元素。     (可选)：开始搜索的索引位置。如果未提供，默认从数组的第一个元素开始。","level":3},{"id":"/notes/ts/array/includes#返回值","title":"返回值","titles":["TypeScript 中的数组 Array.prototype.includes 方法"],"content":"如果数组中包含指定的元素，返回   ，否则返回   。","level":3},{"id":"/notes/ts/array/includes#示例","title":"示例","titles":["TypeScript 中的数组 Array.prototype.includes 方法"],"content":"","level":3},{"id":"/notes/ts/array/includes#简单示例","title":"简单示例","titles":["TypeScript 中的数组 Array.prototype.includes 方法","示例"],"content":"","level":4},{"id":"/notes/ts/array/includes#从指定索引位置开始搜索","title":"从指定索引位置开始搜索","titles":["TypeScript 中的数组 Array.prototype.includes 方法","示例"],"content":"","level":4},{"id":"/notes/ts/array/includes#搜索对象","title":"搜索对象","titles":["TypeScript 中的数组 Array.prototype.includes 方法","示例"],"content":"注意：   方法使用的是严格相等（  ）比较。因此，对于对象类型的数组，   方法检查的是引用相等。","level":4},{"id":"/notes/ts/array/includes#在-typescript-中的类型检查","title":"在 TypeScript 中的类型检查","titles":["TypeScript 中的数组 Array.prototype.includes 方法","示例"],"content":"TypeScript 会根据数组的类型自动推断    方法的参数类型。如果传入不匹配的类型，TypeScript 编译器会报错。","level":3},{"id":"/notes/ts/array/includes#使用-includes-方法处理联合类型数组","title":"使用   includes  方法处理联合类型数组","titles":["TypeScript 中的数组 Array.prototype.includes 方法","示例"],"content":"如果数组的类型是联合类型，   方法可以检查所有可能的类型。","level":3},{"id":"/notes/ts/array/includes#总结","title":"总结","titles":["TypeScript 中的数组 Array.prototype.includes 方法","示例"],"content":"方法在 TypeScript 中非常有用，用于检查数组是否包含某个元素，并且它支持类型检查和类型推断。通过了解其用法，可以在开发中更方便地处理数组包含关系的判断。","level":3},{"id":"/notes/ts/array/to-dictionary#typescript-中的数组转换成对象字典","title":"TypeScript 中的数组转换成对象字典","titles":[],"content":"将 TypeScript 中的数组转换成对象字典，可以通过遍历数组并根据需要将每个元素映射到对象的键值对来实现。下面是一个示例代码，将数组转换为对象字典：假设有一个数组   ，每个元素是一个用户对象，具有    和    属性。我们将这个数组转换为一个以    为键，用户对象为值的字典。输出结果：在这个示例中，我们使用    方法遍历数组，并将每个用户对象添加到字典中。   的初始值是一个空对象   ，类型是   。如果键是字符串类型，可以相应地调整类型定义：这样可以根据数组中的数据创建一个对象字典，并可以通过指定的键快速查找值。","level":1},{"id":"/notes/ts/book/basic-types#基础类型","title":"基础类型","titles":[],"content":"TypeScript 提供了一组丰富的基本类型，这些类型帮助我们在编写代码时获得更好的类型检查和代码补全。以下是 TypeScript 的一些基础类型及其用法示例。","level":2},{"id":"/notes/ts/book/basic-types#_1-布尔值-boolean","title":"1. 布尔值 (boolean)","titles":["基础类型"],"content":"布尔值类型表示逻辑值：   或   。","level":3},{"id":"/notes/ts/book/basic-types#_2-数字-number","title":"2. 数字 (number)","titles":["基础类型"],"content":"和 JavaScript 一样，TypeScript 中所有的数字都是浮点数。TypeScript 支持十进制、十六进制、二进制和八进制字面量。","level":3},{"id":"/notes/ts/book/basic-types#_3-字符串-string","title":"3. 字符串 (string)","titles":["基础类型"],"content":"表示文本数据的类型。可以使用双引号 (  ) 或单引号 (  ) 表示字符串。还支持模板字符串，它可以跨行并且嵌入表达式。","level":3},{"id":"/notes/ts/book/basic-types#_4-数组-array","title":"4. 数组 (array)","titles":["基础类型"],"content":"可以用两种方式定义数组。第一种方式，可以在元素类型后面接上   。第二种方式是使用泛型数组类型，  。","level":3},{"id":"/notes/ts/book/basic-types#_5-元组-tuple","title":"5. 元组 (tuple)","titles":["基础类型"],"content":"元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。访问已知索引的元素会得到正确的类型：","level":3},{"id":"/notes/ts/book/basic-types#_6-枚举-enum","title":"6. 枚举 (enum)","titles":["基础类型"],"content":"枚举类型用于定义一组命名的常量。TypeScript 提供了数字枚举和字符串枚举。默认情况下，从    开始为元素编号。可以手动更改成员的值。","level":3},{"id":"/notes/ts/book/basic-types#_7-any","title":"7. Any","titles":["基础类型"],"content":"类型是为了那些在编程阶段还不清楚类型的变量而设计的。使用    类型，可以跳过类型检查。","level":3},{"id":"/notes/ts/book/basic-types#_8-unknown","title":"8. Unknown","titles":["基础类型"],"content":"类型是 TypeScript 3.0 中引入的，它表示类型不确定的值。与    不同，   类型只能在确定其类型后才能进行操作。","level":3},{"id":"/notes/ts/book/basic-types#_9-void","title":"9. Void","titles":["基础类型"],"content":"某种程度上来说，   类型像是与    类型相反，它表示没有任何类型。通常用于表示函数没有返回值。","level":3},{"id":"/notes/ts/book/basic-types#_10-null-和-undefined","title":"10. Null 和 Undefined","titles":["基础类型"],"content":"TypeScript 里，   和    有自己的类型分别叫做    和   。默认情况下，这两种类型是所有类型的子类型。也就是说，你可以把    和    赋值给其他类型的变量。","level":3},{"id":"/notes/ts/book/basic-types#_11-never","title":"11. Never","titles":["基础类型"],"content":"类型表示的是那些永不存在的值的类型。例如，那些总是会抛出异常或根本不会有返回值的函数表达式或箭头函数表达式的返回值类型。","level":3},{"id":"/notes/ts/book/basic-types#_12-object","title":"12. Object","titles":["基础类型"],"content":"表示非原始类型，也就是除   ，  ，  ，  ，   或    之外的类型。","level":3},{"id":"/notes/ts/book/basic-types#总结","title":"总结","titles":["基础类型"],"content":"这些基本类型构成了 TypeScript 类型系统的基础。通过理解和使用这些基本类型，可以编写更安全、更健壮的代码。在实际开发中，TypeScript 的类型系统能够帮助你捕获许多潜在的错误，并提高代码的可维护性和可读性。","level":3},{"id":"/notes/ts/book/basic-types#参考","title":"参考","titles":["基础类型"],"content":"https://www.typescriptlang.org/docs/handbook/2/basic-types.html","level":3},{"id":"/notes/ts/book/variable-declarations#变量声明","title":"变量声明","titles":[],"content":"在 TypeScript 中，变量的声明和作用域规则与 JavaScript 相似，但增加了一些额外的类型检查和语法糖。下面详细介绍 TypeScript 的变量声明、作用域规则、捕获变量的怪异之处、块作用域、重定义及屏蔽、块级作用域变量的获取等内容。","level":2},{"id":"/notes/ts/book/variable-declarations#_1-变量声明","title":"1. 变量声明","titles":["变量声明"],"content":"TypeScript 支持   、   和    三种变量声明方式。","level":3},{"id":"/notes/ts/book/variable-declarations#var-声明","title":"var 声明","titles":["变量声明","1. 变量声明"],"content":"声明的变量具有函数作用域或全局作用域。","level":4},{"id":"/notes/ts/book/variable-declarations#let-声明","title":"let 声明","titles":["变量声明","1. 变量声明"],"content":"声明的变量具有块级作用域，避免了    变量声明带来的一些问题。","level":4},{"id":"/notes/ts/book/variable-declarations#const-声明","title":"const 声明","titles":["变量声明","1. 变量声明"],"content":"声明的是常量，必须初始化且不可重新赋值。它也是块级作用域。","level":4},{"id":"/notes/ts/book/variable-declarations#_2-作用域规则","title":"2. 作用域规则","titles":["变量声明","1. 变量声明"],"content":"TypeScript 中的作用域规则分为全局作用域、函数作用域和块级作用域。","level":3},{"id":"/notes/ts/book/variable-declarations#全局作用域","title":"全局作用域","titles":["变量声明","1. 变量声明","2. 作用域规则"],"content":"在最外层定义的变量具有全局作用域。","level":4},{"id":"/notes/ts/book/variable-declarations#函数作用域","title":"函数作用域","titles":["变量声明","1. 变量声明","2. 作用域规则"],"content":"在函数内部定义的变量具有函数作用域，只在函数内部可见。","level":4},{"id":"/notes/ts/book/variable-declarations#块级作用域","title":"块级作用域","titles":["变量声明","1. 变量声明","2. 作用域规则"],"content":"用    或    声明的变量在块级作用域内可见。","level":4},{"id":"/notes/ts/book/variable-declarations#_3-捕获变量的怪异之处","title":"3. 捕获变量的怪异之处","titles":["变量声明","1. 变量声明"],"content":"在 JavaScript 中，   声明的变量有变量提升和函数作用域，这可能导致一些意想不到的行为。使用    可以避免这个问题，因为它具有块级作用域。","level":3},{"id":"/notes/ts/book/variable-declarations#_4-重定义及屏蔽","title":"4. 重定义及屏蔽","titles":["变量声明","1. 变量声明"],"content":"在 TypeScript 中，可以重定义同一作用域内的变量，这可能导致意想不到的行为。使用    或    可以避免这种情况。","level":3},{"id":"/notes/ts/book/variable-declarations#_5-块级作用域变量的获取","title":"5. 块级作用域变量的获取","titles":["变量声明","1. 变量声明"],"content":"在嵌套的块级作用域中，内层作用域可以访问外层作用域的变量。在块级作用域中，如果内层作用域中有与外层作用域同名的变量，内层变量会屏蔽外层变量。","level":3},{"id":"/notes/ts/book/variable-declarations#_6-使用闭包捕获变量","title":"6. 使用闭包捕获变量","titles":["变量声明","1. 变量声明"],"content":"在使用闭包时，要特别注意变量的捕获方式。可以通过立即执行函数表达式（IIFE）来创建新的作用域，以捕获每次迭代的变量。","level":3},{"id":"/notes/ts/book/variable-declarations#总结","title":"总结","titles":["变量声明","1. 变量声明"],"content":"TypeScript 的变量声明和作用域规则提供了更严格的类型检查和更明确的作用域控制，避免了许多 JavaScript 中常见的问题。通过理解和使用这些规则，可以编写更可靠和可维护的代码。","level":3},{"id":"/notes/ts/book/variable-declarations#参考","title":"参考","titles":["变量声明","1. 变量声明"],"content":"https://www.typescriptlang.org/docs/handbook/variable-declarations.html","level":3},{"id":"/notes/ts/book/variable-deconstruction#变量解构","title":"变量解构","titles":[],"content":"在 TypeScript 中，变量解构是一种简洁的语法，允许从数组或对象中提取值，并将其赋值给变量。解构可以提高代码的可读性和可维护性。以下是 TypeScript 中变量解构的详细介绍，包括数组解构、对象解构、解构赋值中的默认值、嵌套解构和函数参数解构。","level":2},{"id":"/notes/ts/book/variable-deconstruction#_1-数组解构","title":"1. 数组解构","titles":["变量解构"],"content":"数组解构允许你将数组中的元素解构为变量。你还可以跳过某些元素：数组解构也支持使用剩余变量收集其余元素：","level":3},{"id":"/notes/ts/book/variable-deconstruction#_2-对象解构","title":"2. 对象解构","titles":["变量解构"],"content":"对象解构允许你将对象的属性解构为变量。你也可以使用不同的变量名来解构对象的属性：","level":3},{"id":"/notes/ts/book/variable-deconstruction#_3-默认值","title":"3. 默认值","titles":["变量解构"],"content":"在解构过程中，你可以为变量指定默认值，当属性未定义时使用默认值。同样，数组解构也支持默认值：","level":3},{"id":"/notes/ts/book/variable-deconstruction#_4-嵌套解构","title":"4. 嵌套解构","titles":["变量解构"],"content":"对象和数组中嵌套的属性也可以解构。","level":3},{"id":"/notes/ts/book/variable-deconstruction#_5-函数参数解构","title":"5. 函数参数解构","titles":["变量解构"],"content":"解构可以用于函数参数，这样可以直接从参数中提取需要的属性或元素。","level":3},{"id":"/notes/ts/book/variable-deconstruction#数组解构","title":"数组解构","titles":["变量解构","5. 函数参数解构"],"content":"","level":4},{"id":"/notes/ts/book/variable-deconstruction#对象解构","title":"对象解构","titles":["变量解构","5. 函数参数解构"],"content":"","level":4},{"id":"/notes/ts/book/variable-deconstruction#示例","title":"示例","titles":["变量解构","5. 函数参数解构"],"content":"以下是一个综合示例，演示如何在函数参数中使用对象解构和默认值：","level":3},{"id":"/notes/ts/book/variable-deconstruction#_6-结合类型和接口","title":"6. 结合类型和接口","titles":["变量解构","5. 函数参数解构"],"content":"使用 TypeScript 类型和接口与解构结合，可以更好地保证类型安全。","level":3},{"id":"/notes/ts/book/variable-deconstruction#总结","title":"总结","titles":["变量解构","5. 函数参数解构"],"content":"TypeScript 的解构赋值使得从数组和对象中提取数据变得更加简洁和清晰。通过使用解构赋值，可以编写更加简洁和具可读性的代码，尤其是在处理复杂数据结构时。此外，结合 TypeScript 的类型系统，解构赋值不仅提供了简洁的语法，还保证了类型安全。","level":3},{"id":"/notes/ts/book/interface#interface","title":"interface","titles":[],"content":"在 TypeScript 中，接口（  ）用于定义对象的结构类型。接口是一个关键的概念，它帮助你定义对象的类型和形状，从而使代码更易于理解和维护。下面详细介绍 TypeScript 接口的作用、核心原则、类型、实现、继承及一些注意事项。","level":2},{"id":"/notes/ts/book/interface#_1-接口的作用","title":"1. 接口的作用","titles":["interface"],"content":"接口的主要作用是定义对象的类型。它描述了对象应该具有的属性和方法。接口不会在编译后的 JavaScript 中生成代码，仅在编译时进行类型检查。","level":3},{"id":"/notes/ts/book/interface#_2-核心原则","title":"2. 核心原则","titles":["interface"],"content":"TypeScript 的核心原则是基于结构类型系统，即类型是基于其成员来定义的。接口描述了一个对象的形状，并且是面向类型检查的契约。","level":3},{"id":"/notes/ts/book/interface#_3-定义和使用接口","title":"3. 定义和使用接口","titles":["interface"],"content":"","level":3},{"id":"/notes/ts/book/interface#基本接口","title":"基本接口","titles":["interface","3. 定义和使用接口"],"content":"","level":4},{"id":"/notes/ts/book/interface#_4-接口中的属性和方法","title":"4. 接口中的属性和方法","titles":["interface","3. 定义和使用接口"],"content":"接口不仅可以描述对象的属性，还可以描述对象的方法。","level":3},{"id":"/notes/ts/book/interface#_5-接口的可选属性和只读属性","title":"5. 接口的可选属性和只读属性","titles":["interface","3. 定义和使用接口"],"content":"","level":3},{"id":"/notes/ts/book/interface#可选属性","title":"可选属性","titles":["interface","3. 定义和使用接口","5. 接口的可选属性和只读属性"],"content":"接口中的可选属性使用    标记。","level":4},{"id":"/notes/ts/book/interface#只读属性","title":"只读属性","titles":["interface","3. 定义和使用接口","5. 接口的可选属性和只读属性"],"content":"接口中的只读属性使用    标记，表示属性不可修改。","level":4},{"id":"/notes/ts/book/interface#_6-接口的继承","title":"6. 接口的继承","titles":["interface","3. 定义和使用接口"],"content":"接口可以通过    关键字继承其他接口，从而实现接口的扩展。","level":3},{"id":"/notes/ts/book/interface#_7-混合类型接口","title":"7. 混合类型接口","titles":["interface","3. 定义和使用接口"],"content":"接口可以描述具有多种类型的对象，例如既有属性又有方法的对象。","level":3},{"id":"/notes/ts/book/interface#_8-实现接口","title":"8. 实现接口","titles":["interface","3. 定义和使用接口"],"content":"类可以实现一个接口，用    关键字。","level":3},{"id":"/notes/ts/book/interface#_9-接口与类型别名","title":"9. 接口与类型别名","titles":["interface","3. 定义和使用接口"],"content":"虽然接口和类型别名（  ）都可以定义对象类型，但接口更适合用于描述对象的结构和行为，而类型别名更适合用于组合简单类型或联合类型。","level":3},{"id":"/notes/ts/book/interface#_10-注意事项","title":"10. 注意事项","titles":["interface","3. 定义和使用接口"],"content":"接口合并 ：在 TypeScript 中，接口可以自动合并，这在声明全局类型时非常有用。     可选属性检查 ：当使用可选属性时，要注意检查该属性是否存在。     严格类型检查 ：在严格模式下，TypeScript 会对接口进行严格的类型检查，这有助于捕捉潜在的错误。","level":3},{"id":"/notes/ts/book/interface#readonly-vs-const","title":"readonly vs const","titles":["interface","3. 定义和使用接口"],"content":"在 TypeScript 中，   和    都用于创建不可修改的值，但它们应用的场景有所不同，具体区别如下：","level":3},{"id":"/notes/ts/book/interface#readonly","title":"readonly","titles":["interface","3. 定义和使用接口","readonly vs const"],"content":"用于属性级别，用来表示一个属性只读，即不能修改其值。","level":4},{"id":"/notes/ts/book/interface#对象属性中的使用","title":"对象属性中的使用：","titles":["interface","3. 定义和使用接口","readonly vs const"],"content":"","level":4},{"id":"/notes/ts/book/interface#类中的使用","title":"类中的使用：","titles":["interface","3. 定义和使用接口","readonly vs const"],"content":"","level":4},{"id":"/notes/ts/book/interface#const","title":"const","titles":["interface","3. 定义和使用接口","readonly vs const"],"content":"用于变量声明，表示一个常量，一旦声明，其值不能重新赋值。","level":4},{"id":"/notes/ts/book/interface#变量声明中的使用","title":"变量声明中的使用：","titles":["interface","3. 定义和使用接口","readonly vs const"],"content":"","level":4},{"id":"/notes/ts/book/interface#区别","title":"区别：","titles":["interface","3. 定义和使用接口","readonly vs const"],"content":"作用范围 ：     可以用于对象的属性以及类的属性，表示属性只读。    只能用于变量的声明，表示变量的值只读。   赋值时机 ：     的值可以在运行时或构造函数中赋值。    的值必须在声明时立即赋值，并且不能再次赋值。   使用场景 ：   如果需要将一个属性标记为不可修改，应该使用   。  如果需要声明一个常量值，应该使用   。在实际使用中，根据变量或属性的需要确定是使用    还是    是很重要的。","level":4},{"id":"/notes/ts/book/interface#总结","title":"总结","titles":["interface","3. 定义和使用接口"],"content":"TypeScript 的接口是一种强大的工具，用于定义对象的结构类型、确保类型安全、实现面向对象编程的抽象和继承。通过使用接口，可以编写更可读、可维护的代码，并提高开发效率。希望这些示例和注意事项能帮助你更好地理解和使用 TypeScript 的接口。","level":3},{"id":"/notes/ts/book/interface#参考","title":"参考","titles":["interface","3. 定义和使用接口"],"content":"https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html#interfaces","level":3},{"id":"/notes/ts/book/classes#class","title":"Class","titles":[],"content":"在 TypeScript 中，类（Class）是面向对象编程的核心概念之一，它提供了一种结构化的方式来定义对象的蓝图，包括属性和方法。下面详细介绍 TypeScript 中类的定义、构造函数、属性、方法、继承、访问修饰符等相关内容。","level":2},{"id":"/notes/ts/book/classes#_1-定义类","title":"1. 定义类","titles":["Class"],"content":"在 TypeScript 中定义一个类使用    关键字，类可以包含属性和方法。","level":3},{"id":"/notes/ts/book/classes#_2-构造函数","title":"2. 构造函数","titles":["Class"],"content":"类的构造函数使用    关键字定义，用于初始化对象的实例。在构造函数中，可以初始化类的属性。","level":3},{"id":"/notes/ts/book/classes#_3-属性和方法","title":"3. 属性和方法","titles":["Class"],"content":"类可以包含实例属性和方法，也可以包含静态属性和方法（通过    关键字定义）。","level":3},{"id":"/notes/ts/book/classes#_4-继承","title":"4. 继承","titles":["Class"],"content":"类可以通过    关键字进行继承另一个类，子类（派生类）可以继承父类（基类）的属性和方法，并且可以扩展或重写它们。","level":3},{"id":"/notes/ts/book/classes#_5-访问修饰符","title":"5. 访问修饰符","titles":["Class"],"content":"TypeScript 支持访问修饰符来控制类的成员（属性和方法）的访问权限。主要的访问修饰符包括   、   和   。：默认的访问修饰符，成员在类内外都可以访问。   ：成员只能在类内部访问。   ：成员在类内部和继承的子类中可以访问。","level":3},{"id":"/notes/ts/book/classes#_6-抽象类","title":"6. 抽象类","titles":["Class"],"content":"抽象类用于定义其他类继承的基类，不能被实例化。抽象类的方法在子类中必须被实现（除非它们自己也是抽象的）。","level":3},{"id":"/notes/ts/book/classes#_7-使用类实现接口","title":"7. 使用类实现接口","titles":["Class"],"content":"类可以使用    关键字来实现接口，一个类可以实现多个接口。","level":3},{"id":"/notes/ts/book/classes#总结","title":"总结","titles":["Class"],"content":"在 TypeScript 中，类是面向对象编程的基础，它允许你组织代码以对象为中心，并通过继承和访问修饰符等机制实现代码的组织和封装。理解和熟练使用类是 TypeScript 中的重要一环，能够帮助你编写结构清晰、易于维护的代码。","level":3},{"id":"/notes/ts/book/classes#参考","title":"参考","titles":["Class"],"content":"https://www.typescriptlang.org/docs/handbook/2/classes.html","level":3},{"id":"/notes/ts/book/functions#基本函数","title":"基本函数","titles":[],"content":"在 TypeScript 中，函数的定义与 JavaScript 类似，但可以指定参数和返回值的类型。和    指定了参数的类型。    表示函数的返回值类型。","level":3},{"id":"/notes/ts/book/functions#可选参数和默认参数","title":"可选参数和默认参数","titles":[],"content":"TypeScript 支持函数参数的可选性和默认值。","level":3},{"id":"/notes/ts/book/functions#可选参数","title":"可选参数","titles":["可选参数和默认参数"],"content":"在参数名后加    表示该参数是可选的。表示    是一个可选参数，如果不传该参数，函数调用仍然有效。","level":4},{"id":"/notes/ts/book/functions#默认参数","title":"默认参数","titles":["可选参数和默认参数"],"content":"在参数定义时赋予默认值。表示    的默认值是 \"Hello\"。","level":4},{"id":"/notes/ts/book/functions#剩余参数","title":"剩余参数","titles":["可选参数和默认参数","默认参数"],"content":"TypeScript 支持剩余参数，它允许我们将不确定数量的参数作为数组传递。表示    是一个包含所有剩余参数的数组。","level":3},{"id":"/notes/ts/book/functions#函数类型","title":"函数类型","titles":["可选参数和默认参数","默认参数"],"content":"可以使用类型别名来定义函数类型，这在传递回调函数时特别有用。定义了一个函数类型别名   。    表示    是一个符合    类型的函数。","level":3},{"id":"/notes/ts/book/functions#箭头函数","title":"箭头函数","titles":["可选参数和默认参数","默认参数"],"content":"TypeScript 支持箭头函数，它们语法简洁，并且可以保留    的指向。","level":3},{"id":"/notes/ts/book/functions#重载","title":"重载","titles":["可选参数和默认参数","默认参数"],"content":"TypeScript 支持函数重载，即同名函数可以有多个不同的签名。前两行定义了两个不同的签名：   和   。  最后一行是函数的具体实现。","level":3},{"id":"/notes/ts/book/functions#函数中的-this","title":"函数中的 this","titles":["可选参数和默认参数","默认参数"],"content":"在 TypeScript 中，我们可以明确地指定函数内部    的类型。明确了    的类型，使得函数内部的    更加可控。","level":3},{"id":"/notes/ts/book/functions#泛型函数","title":"泛型函数","titles":["可选参数和默认参数","默认参数"],"content":"TypeScript 支持泛型函数，可以处理不同类型的参数。使用了泛型   ，表示函数可以接受任意类型的参数，并返回相同类型的值。    和    是泛型函数的具体应用。通过以上介绍，TypeScript 函数的各种特性和用法可以帮助我们编写更健壮和可维护的代码。","level":3},{"id":"/notes/ts/book/functions#参考","title":"参考","titles":["可选参数和默认参数","默认参数"],"content":"https://www.typescriptlang.org/docs/handbook/2/functions.html","level":3},{"id":"/notes/ts/book/generics#_1-泛型概述","title":"1. 泛型概述","titles":[],"content":"泛型（Generics）允许定义函数、类或接口时不指定具体类型，而是在使用时再指定具体类型。这种方式使得代码在保持类型安全的同时，具有更高的灵活性。","level":3},{"id":"/notes/ts/book/generics#_2-泛型变量","title":"2. 泛型变量","titles":[],"content":"泛型变量用来捕获传递给函数、类或接口的类型。中的    就是泛型变量。  调用时指定具体类型，例如   。","level":3},{"id":"/notes/ts/book/generics#_3-泛型类型","title":"3. 泛型类型","titles":[],"content":"泛型类型用于定义包含一个或多个类型参数的类型。定义了一个泛型类型别名。    使用泛型类型别名定义变量。","level":3},{"id":"/notes/ts/book/generics#_4-泛型类","title":"4. 泛型类","titles":[],"content":"泛型类允许类在实例化时指定类型。定义了一个泛型类。    实例化时指定具体类型。","level":3},{"id":"/notes/ts/book/generics#_5-泛型约束","title":"5. 泛型约束","titles":[],"content":"泛型约束用于限制泛型类型的范围。表示泛型类型    必须满足    接口的约束。  这样可以确保    类型具有    属性。","level":3},{"id":"/notes/ts/book/generics#_6-学习技巧","title":"6. 学习技巧","titles":[],"content":"要掌握 TypeScript 泛型，可以采用以下学习技巧：从简单示例入手 ：理解基本概念后，再逐步复杂化。   阅读官方文档 ：TypeScript 官方文档是最权威的学习资源，涵盖了泛型的方方面面。   实践练习 ：多写代码，尝试将常见的非泛型代码改写成泛型代码。   阅读开源项目代码 ：学习他人如何在大型项目中使用泛型。   使用TypeScript Playground ：在  TypeScript Playground  上实验代码，快速验证想法。","level":3},{"id":"/notes/ts/book/generics#综合示例","title":"综合示例","titles":[],"content":"以下是一个综合示例，展示了如何使用泛型函数、泛型接口和泛型类：通过这些示例，可以全面理解 TypeScript 中泛型的使用和优势。多加练习，可以更好地掌握和应用泛型，使代码更加通用和可复用。","level":3},{"id":"/notes/ts/book/generics#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/2/generics.html#handbook-content","level":3},{"id":"/notes/ts/book/enums#数字枚举","title":"数字枚举","titles":[],"content":"数字枚举是 TypeScript 中最常见的枚举类型。默认情况下，枚举成员的值从    开始递增。你也可以手动指定枚举成员的值，后续成员的值会从这个指定值开始递增。","level":3},{"id":"/notes/ts/book/enums#字符串枚举","title":"字符串枚举","titles":[],"content":"字符串枚举的每个成员必须用字符串字面量进行初始化。这种方式提供了更清晰的语义。","level":3},{"id":"/notes/ts/book/enums#异构枚举","title":"异构枚举","titles":[],"content":"异构枚举允许混合使用字符串和数字成员。这种用法较少见，但在某些特定场景下可能会有用。","level":3},{"id":"/notes/ts/book/enums#计算和常量成员","title":"计算和常量成员","titles":[],"content":"枚举成员可以是常量或计算值。常量成员是在编译时计算出的值，而计算成员则是在运行时计算的。","level":3},{"id":"/notes/ts/book/enums#常量枚举","title":"常量枚举","titles":[],"content":"常量枚举使用    关键字定义，编译时会被完全移除。常量枚举只在性能优化上有用，特别是在频繁使用的情况下。编译后的代码将不包含枚举定义，而是直接使用其值：","level":3},{"id":"/notes/ts/book/enums#反向映射","title":"反向映射","titles":[],"content":"数字枚举成员不仅创建从名字到值的映射，还创建从值到名字的反向映射。反向映射仅适用于数字枚举成员，字符串枚举成员不提供这种特性。","level":3},{"id":"/notes/ts/book/enums#枚举成员类型","title":"枚举成员类型","titles":[],"content":"枚举成员类型可以作为单独的类型使用，尤其在需要特定值的场景下。","level":3},{"id":"/notes/ts/book/enums#总结","title":"总结","titles":[],"content":"TypeScript 枚举提供了一种灵活和强大的方式来定义一组命名常量，使代码更加可读和易于维护。以下是总结的几点：数字枚举 ：默认从    开始递增，可以手动指定值。   字符串枚举 ：每个成员用字符串字面量初始化，提供清晰的语义。   异构枚举 ：允许混合字符串和数字成员。   计算和常量成员 ：支持在编译时和运行时计算的成员。   常量枚举 ：使用    关键字定义，编译时移除以优化性能。   反向映射 ：数字枚举成员支持从名字到值和从值到名字的反向映射。   枚举成员类型 ：可以作为单独的类型使用。通过掌握这些特性，你可以更有效地使用 TypeScript 枚举来构建强类型的应用程序。","level":3},{"id":"/notes/ts/book/enums#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/enums.html#handbook-content","level":3},{"id":"/notes/ts/book/type-inference#基本类型推论","title":"基本类型推论","titles":[],"content":"当变量被声明并初始化时，TypeScript 会根据初始化的值推断出变量的类型。即使没有显式地声明类型，TypeScript 也能够推断出变量的类型。例如，   被推断为   ，因为它被初始化为   。","level":3},{"id":"/notes/ts/book/type-inference#最佳通用类型","title":"最佳通用类型","titles":[],"content":"当推断数组的类型时，TypeScript 会基于数组元素的类型推断出数组的类型。如果数组中有不同类型的元素，TypeScript 会推断出一个包含所有可能类型的联合类型。","level":3},{"id":"/notes/ts/book/type-inference#上下文类型","title":"上下文类型","titles":[],"content":"当变量的类型由其上下文决定时，称为上下文类型。这个机制通常出现在函数参数和返回值、回调函数等场景中。在上述代码中，   的类型被推断为   ，因为    事件处理函数的上下文决定了    的类型。","level":3},{"id":"/notes/ts/book/type-inference#返回值类型推论","title":"返回值类型推论","titles":[],"content":"当函数有返回值时，TypeScript 可以基于    语句自动推断出返回值的类型。在这个例子中，   函数的返回值类型被推断为   。","level":3},{"id":"/notes/ts/book/type-inference#上下文类型与回调函数","title":"上下文类型与回调函数","titles":[],"content":"当回调函数作为参数传递给另一个函数时，TypeScript 可以推断出回调函数参数的类型。在这里，   的回调函数参数    的类型被推断为   ，因为    是一个   。","level":3},{"id":"/notes/ts/book/type-inference#上下文类型与类型别名","title":"上下文类型与类型别名","titles":[],"content":"在使用类型别名时，TypeScript 也会进行类型推论。在这个例子中，   被推断为    类型，因为它被初始化为一个符合    类型的对象。","level":3},{"id":"/notes/ts/book/type-inference#类型推论的局限性","title":"类型推论的局限性","titles":[],"content":"虽然类型推论可以极大地减少显式类型声明的需要，但在某些情况下，显式声明类型仍然是必要的。复杂对象 ：当对象结构复杂时，显式声明类型可以提高代码可读性。   外部接口 ：在与外部接口交互时，显式声明类型可以避免潜在的类型错误。   默认参数 ：在函数的默认参数中，显式声明类型可以使函数更易于理解。","level":3},{"id":"/notes/ts/book/type-inference#强制类型推断","title":"强制类型推断","titles":[],"content":"有时，TypeScript 无法推断出正确的类型，或者推断出的类型不符合预期。在这种情况下，可以使用类型断言来强制指定类型。","level":3},{"id":"/notes/ts/book/type-inference#总结","title":"总结","titles":[],"content":"TypeScript 的类型推论机制能够在大多数情况下自动推断出变量的类型，从而减少显式类型声明的需要。理解和利用类型推论可以使代码更加简洁和易读。以下是一些关键点：基本类型推论 ：基于初始化值推断类型。   最佳通用类型 ：在数组和联合类型中推断出最合适的类型。   上下文类型 ：根据上下文环境推断类型，如事件处理和回调函数。   返回值类型推论 ：基于    语句推断函数的返回值类型。   类型断言 ：在需要时强制指定类型。通过熟练掌握这些机制，可以在 TypeScript 中更好地利用类型系统的强大功能。","level":3},{"id":"/notes/ts/book/type-inference#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/type-inference.html","level":3},{"id":"/notes/ts/book/type-compatibility#_1-基本规则","title":"1. 基本规则","titles":[],"content":"在 TypeScript 中，一个类型    可以赋值给另一个类型   ，当且仅当    兼容   。类型兼容性主要取决于两个方面：结构兼容性 ：即一个类型的属性集合是否是另一个类型属性集合的子集。   可分配性 ：即一个类型的值是否可以赋值给另一个类型。","level":3},{"id":"/notes/ts/book/type-compatibility#_2-接口兼容性","title":"2. 接口兼容性","titles":[],"content":"当判断两个接口类型的兼容性时，TypeScript 会检查一个接口的属性是否可以包含在另一个接口中。在这个例子中，   包含    所有的属性，因此    类型可以赋值给    类型。","level":3},{"id":"/notes/ts/book/type-compatibility#_3-类兼容性","title":"3. 类兼容性","titles":[],"content":"类的兼容性与接口类似，但还会考虑到类的静态成员和构造函数。只考虑实例成员和方法。","level":3},{"id":"/notes/ts/book/type-compatibility#_4-函数兼容性","title":"4. 函数兼容性","titles":[],"content":"函数的兼容性检查主要涉及参数和返回值的类型。在检查函数兼容性时，TypeScript 会执行双向检查。参数 ：参数类型必须兼容（逆变）。   返回值 ：返回值类型必须兼容（协变）。","level":3},{"id":"/notes/ts/book/type-compatibility#_5-泛型兼容性","title":"5. 泛型兼容性","titles":[],"content":"泛型类型的兼容性与普通类型相似，TypeScript 会检查实际使用时泛型参数的兼容性。","level":3},{"id":"/notes/ts/book/type-compatibility#_6-枚举兼容性","title":"6. 枚举兼容性","titles":[],"content":"不同枚举类型之间不兼容，但可以将枚举类型与数字类型相互赋值。","level":3},{"id":"/notes/ts/book/type-compatibility#_7-高级类型兼容性","title":"7. 高级类型兼容性","titles":[],"content":"","level":3},{"id":"/notes/ts/book/type-compatibility#联合类型和交叉类型","title":"联合类型和交叉类型","titles":["7. 高级类型兼容性"],"content":"联合类型（Union Types） ：A | B 表示 A 或 B 的类型，可以兼容 A 或 B 的类型。   交叉类型（Intersection Types） ：A & B 表示同时是 A 和 B 的类型。","level":4},{"id":"/notes/ts/book/type-compatibility#_8-typescript-中类型兼容性总结","title":"8. TypeScript 中类型兼容性总结","titles":["7. 高级类型兼容性","联合类型和交叉类型"],"content":"结构化类型系统 ：基于成员结构判断类型兼容性。   接口和类 ：成员类型兼容即可赋值，类需注意静态成员和构造函数。   函数 ：参数类型逆变，返回值类型协变。   泛型 ：实际使用时泛型参数需兼容。   枚举 ：与数字类型互相兼容，不同枚举类型不兼容。   联合类型和交叉类型 ：分别表示可选类型和组合类型。通过理解和掌握 TypeScript 的类型兼容性机制，可以编写出更安全、可维护的代码，同时也可以更灵活地利用类型系统的强大功能。","level":3},{"id":"/notes/ts/book/type-compatibility#参考","title":"参考","titles":["7. 高级类型兼容性","联合类型和交叉类型"],"content":"https://www.typescriptlang.org/docs/handbook/type-compatibility.html#handbook-content","level":3},{"id":"/notes/ts/book/advanced-types#typescript-高级类型","title":"TypeScript 高级类型","titles":[],"content":"TypeScript 高级类型是 TypeScript 类型系统中的一些高级特性和技巧，用于编写更复杂和灵活的代码。以下是 TypeScript 高级类型的详细介绍，包括交叉类型、联合类型、类型别名、类型断言、字面量类型、可辨识联合、类型守卫、映射类型和条件类型。","level":2},{"id":"/notes/ts/book/advanced-types#_1-交叉类型intersection-types","title":"1. 交叉类型（Intersection Types）","titles":["TypeScript 高级类型"],"content":"交叉类型    表示同时是    和    类型的类型。它通常用于将多个类型的成员结合在一起。","level":3},{"id":"/notes/ts/book/advanced-types#_2-联合类型union-types","title":"2. 联合类型（Union Types）","titles":["TypeScript 高级类型"],"content":"联合类型    表示可以是    或    类型的类型。它通常用于表示一个值可以有多种类型。","level":3},{"id":"/notes/ts/book/advanced-types#_3-类型别名type-aliases","title":"3. 类型别名（Type Aliases）","titles":["TypeScript 高级类型"],"content":"类型别名用于给类型起一个新的名字。它可以简化复杂类型的使用。","level":3},{"id":"/notes/ts/book/advanced-types#_4-字面量类型literal-types","title":"4. 字面量类型（Literal Types）","titles":["TypeScript 高级类型"],"content":"字面量类型允许你指定一个变量只能有特定的值。它通常与联合类型结合使用来实现枚举的效果。","level":3},{"id":"/notes/ts/book/advanced-types#_5-可辨识联合discriminated-unions","title":"5. 可辨识联合（Discriminated Unions）","titles":["TypeScript 高级类型"],"content":"可辨识联合是 TypeScript 中的一种模式，用于类型安全地处理联合类型。它通常由联合类型、字面量类型和类型守卫结合实现。","level":3},{"id":"/notes/ts/book/advanced-types#_6-类型守卫type-guards","title":"6. 类型守卫（Type Guards）","titles":["TypeScript 高级类型"],"content":"类型守卫是一些表达式，用于在运行时检查类型，并在特定的代码块中缩小类型范围。常见的类型守卫包括   、   和自定义类型谓词。","level":3},{"id":"/notes/ts/book/advanced-types#_7-映射类型mapped-types","title":"7. 映射类型（Mapped Types）","titles":["TypeScript 高级类型"],"content":"映射类型用于基于旧类型创建新类型。它遍历旧类型的属性，并基于其创建新的类型。","level":3},{"id":"/notes/ts/book/advanced-types#_8-条件类型conditional-types","title":"8. 条件类型（Conditional Types）","titles":["TypeScript 高级类型"],"content":"条件类型用于根据某个条件表达式生成不同的类型。","level":3},{"id":"/notes/ts/book/advanced-types#_9-索引类型index-types","title":"9. 索引类型（Index Types）","titles":["TypeScript 高级类型"],"content":"定义 ：索引类型用于获取对象属性的类型。用法 ：使用    和索引访问操作符   。说明 ：   操作符获取对象的键，   获取对象属性的类型。","level":3},{"id":"/notes/ts/book/advanced-types#高级类型示例","title":"高级类型示例","titles":["TypeScript 高级类型"],"content":"结合使用多个高级类型特性可以创建更复杂的类型定义。","level":2},{"id":"/notes/ts/book/advanced-types#高级类型总结","title":"高级类型总结","titles":["TypeScript 高级类型"],"content":"TypeScript 高级类型提供了一些强大而灵活的工具，用于创建复杂且类型安全的代码。通过理解和利用这些特性，你可以编写更健壮和可维护的 TypeScript 代码。以下是关键点：交叉类型 ：将多个类型合并为一个类型。   联合类型 ：表示值可以是多种类型之一。   类型别名 ：给复杂类型起一个简洁的名字。   字面量类型 ：指定变量只能有特定的值。   可辨识联合 ：安全处理联合类型。   类型守卫 ：在运行时检查并缩小类型范围。   映射类型 ：基于旧类型创建新类型。   条件类型 ：根据条件生成不同的类型。通过掌握这些高级类型特性，你可以更加灵活和精确地描述代码中的数据结构和行为。","level":2},{"id":"/notes/ts/book/advanced-types#参考","title":"参考","titles":["TypeScript 高级类型"],"content":"https://www.typescriptlang.org/docs/handbook/type-compatibility.html#advanced-topics","level":2},{"id":"/notes/ts/book/symbols#_1-创建-symbol","title":"1. 创建 Symbol","titles":[],"content":"可以使用    函数来创建一个新的 Symbol。每个 Symbol 都是唯一的，即使它们的描述相同。","level":3},{"id":"/notes/ts/book/symbols#_2-使用-symbol-作为对象属性键","title":"2. 使用 Symbol 作为对象属性键","titles":[],"content":"由于 Symbol 是唯一的，它们非常适合作为对象属性键，以避免属性名冲突。","level":3},{"id":"/notes/ts/book/symbols#_3-全局-symbol-注册表","title":"3. 全局 Symbol 注册表","titles":[],"content":"可以使用    和    在全局注册表中创建和查找 Symbols。这样即使在不同的模块中也可以共享同一个 Symbol。","level":3},{"id":"/notes/ts/book/symbols#_4-内置的-well-known-symbols","title":"4. 内置的 Well-Known Symbols","titles":[],"content":"JavaScript 和 TypeScript 定义了一些内置的 Symbol，这些 Symbol 被称为 Well-Known Symbols，它们可以用来修改内置行为。例如，   用于定义对象的默认迭代器。","level":3},{"id":"/notes/ts/book/symbols#_5-symbol-属性不可枚举","title":"5. Symbol 属性不可枚举","titles":[],"content":"使用    或    循环时，Symbol 属性不会被枚举出来。但是可以使用    来获取对象的 Symbol 属性。","level":3},{"id":"/notes/ts/book/symbols#_6-使用-symbol-实现私有属性","title":"6. 使用 Symbol 实现私有属性","titles":[],"content":"尽管 TypeScript 提供了    关键字，但在运行时它不会真正将属性隐藏。使用 Symbol 可以实现某种程度的私有属性，因为 Symbol 属性不会被意外访问或覆盖。","level":3},{"id":"/notes/ts/book/symbols#_7-使用-symbol-实现枚举类型的扩展","title":"7. 使用 Symbol 实现枚举类型的扩展","titles":[],"content":"Symbol 也可以用于扩展枚举类型，使其更灵活和安全。","level":3},{"id":"/notes/ts/book/symbols#_8-示例总结","title":"8. 示例总结","titles":[],"content":"综合以上使用方式，Symbols 可以在以下场景中大显身手：避免对象属性名冲突 ：使用 Symbol 作为对象属性键，确保属性的唯一性。   创建私有属性 ：虽然不是完全的私有，但可以避免意外的访问或覆盖。   使用全局 Symbol 注册表 ：在多个模块之间共享同一个 Symbol。   修改内置行为 ：通过 Well-Known Symbols 修改内置对象的行为。   增强枚举类型 ：使用 Symbol 实现更灵活和安全的枚举类型扩展。通过合理使用 Symbols，可以大大提升代码的健壮性和可维护性。","level":3},{"id":"/notes/ts/book/symbols#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/symbols.html#handbook-content","level":3},{"id":"/notes/ts/book/iterators-and-generators#_1-迭代器-iterators","title":"1. 迭代器 (Iterators)","titles":[],"content":"定义 ：迭代器是一个对象，它实现了    接口，该接口包含一个    方法，返回一个包含    和    属性的对象。基本用法 ：说明 ：   类实现了一个简单的迭代器，它生成从    到    的值。","level":3},{"id":"/notes/ts/book/iterators-and-generators#_2-可迭代对象-iterable","title":"2. 可迭代对象 (Iterable)","titles":[],"content":"定义 ：一个对象被认为是可迭代的，如果它实现了    接口，这意味着它有一个    属性，返回一个迭代器。基本用法 ：说明 ：   类实现了    接口，使得其实例可以使用    循环进行迭代。","level":3},{"id":"/notes/ts/book/iterators-and-generators#_3-生成器-generators","title":"3. 生成器 (Generators)","titles":[],"content":"定义 ：生成器是一种特殊类型的函数，它可以暂停和恢复其执行。生成器函数使用    语法定义，内部使用    表达式来生成值。基本用法 ：说明 ：   函数每次    一个值，当没有更多值时，返回   。","level":3},{"id":"/notes/ts/book/iterators-and-generators#_4-使用生成器实现可迭代对象","title":"4. 使用生成器实现可迭代对象","titles":[],"content":"定义和用法 ：生成器函数可以用于实现    接口，使得自定义迭代逻辑更加简单。说明 ：   类使用生成器函数实现了    接口，使得迭代逻辑更简洁。","level":3},{"id":"/notes/ts/book/iterators-and-generators#_5-生成器的高级用法","title":"5. 生成器的高级用法","titles":[],"content":"生成器除了简单地生成序列，还可以通过    表达式和    方法之间的双向通信，实现更复杂的迭代逻辑。双向通信 ：说明 ：生成器函数    演示了如何在调用    时向生成器发送值，并在生成器中接收这些值。","level":3},{"id":"/notes/ts/book/iterators-and-generators#_6-异步生成器-async-generators","title":"6. 异步生成器 (Async Generators)","titles":[],"content":"定义 ：异步生成器函数使用    语法定义，允许在生成器函数中使用    表达式，从而处理异步操作。基本用法 ：说明 ：   异步生成器函数每秒生成一个值，通过    循环进行异步迭代。","level":3},{"id":"/notes/ts/book/iterators-and-generators#总结","title":"总结","titles":[],"content":"TypeScript 中的迭代器和生成器提供了强大的工具来处理序列和异步操作：迭代器 ：通过实现    接口自定义迭代行为。   可迭代对象 ：实现    接口，使对象可以被    循环迭代。   生成器 ：使用    定义，使用    表达式生成值，提供暂停和恢复执行的能力。   异步生成器 ：使用    定义，允许在生成器中使用异步操作。通过理解和应用这些特性，你可以编写更加灵活和高效的代码，处理复杂的迭代逻辑和异步操作。","level":3},{"id":"/notes/ts/book/iterators-and-generators#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#handbook-content","level":3},{"id":"/notes/ts/book/modules#_1-模块基础","title":"1. 模块基础","titles":[],"content":"模块的定义 ：在 TypeScript 中，一个文件就是一个模块。模块中的代码默认是私有的，只有通过导出（export）的内容才能在其他模块中使用。基本用法 ：","level":3},{"id":"/notes/ts/book/modules#导出和导入","title":"导出和导入","titles":["1. 模块基础"],"content":"导出 (Export) ：可以通过    关键字将变量、函数、类、接口等导出。导入 (Import) ：可以通过    关键字从其他模块中导入导出的内容。","level":4},{"id":"/notes/ts/book/modules#_2-默认导出default-exports","title":"2. 默认导出（Default Exports）","titles":["1. 模块基础","导出和导入"],"content":"默认导出是指一个模块可以有一个默认导出，使用    语法。说明 ：默认导出的内容在导入时不需要使用花括号   ，并且可以使用任意名字进行导入。","level":3},{"id":"/notes/ts/book/modules#_3-重命名导入和导出","title":"3. 重命名导入和导出","titles":["1. 模块基础","导出和导入"],"content":"可以在导出和导入时对标识符进行重命名，以避免命名冲突或提升代码可读性。导出时重命名 ：导入时重命名 ：","level":3},{"id":"/notes/ts/book/modules#_4-重新导出re-exporting","title":"4. 重新导出（Re-Exporting）","titles":["1. 模块基础","导出和导入"],"content":"重新导出可以将一个模块的所有内容或部分内容重新导出，以便在其他模块中使用。重新导出所有内容 ：重新导出部分内容 ：","level":3},{"id":"/notes/ts/book/modules#_5-动态导入","title":"5. 动态导入","titles":["1. 模块基础","导出和导入"],"content":"动态导入允许在运行时按需加载模块，使用    语法。说明 ：动态导入返回一个   ，适合用于按需加载、代码分割和性能优化。","level":3},{"id":"/notes/ts/book/modules#_6-命名空间namespaces","title":"6. 命名空间（Namespaces）","titles":["1. 模块基础","导出和导入"],"content":"命名空间用于将一组相关的代码组织在一起，它是 TypeScript 提供的另一种模块化方式，但在现代开发中更推荐使用模块（ES 模块）。","level":3},{"id":"/notes/ts/book/modules#_7-模块解析","title":"7. 模块解析","titles":["1. 模块基础","导出和导入"],"content":"TypeScript 提供了两种模块解析策略：  经典（Classic）  和   节点（Node） 。默认情况下，TypeScript 使用节点解析策略。节点解析策略 ：遵循 Node.js 的模块解析逻辑，支持相对路径和包路径导入。","level":3},{"id":"/notes/ts/book/modules#_8-配置模块","title":"8. 配置模块","titles":["1. 模块基础","导出和导入"],"content":"在    文件中，可以通过    配置模块相关选项。说明 ：通过    和    选项，可以配置路径别名，简化模块导入路径。","level":3},{"id":"/notes/ts/book/modules#_9-高级用法示例","title":"9. 高级用法示例","titles":["1. 模块基础","导出和导入"],"content":"结合以上各种模块特性，可以实现复杂的模块组织和依赖管理。示例 ：","level":3},{"id":"/notes/ts/book/modules#总结","title":"总结","titles":["1. 模块基础","导出和导入"],"content":"TypeScript 模块通过导出和导入机制帮助开发者将代码组织成逻辑单元，提高代码可维护性和重用性。默认导出、重命名导入导出、动态导入、命名空间等高级特性使得模块的使用更加灵活和强大。通过合理配置和使用这些特性，可以构建清晰、模块化和高效的 TypeScript 项目。","level":3},{"id":"/notes/ts/book/modules#参考","title":"参考","titles":["1. 模块基础","导出和导入"],"content":"https://www.typescriptlang.org/docs/handbook/modules/introduction.html#handbook-content","level":3},{"id":"/notes/ts/book/namespaces#typescript-namespaces-命名空间","title":"TypeScript Namespaces (命名空间)","titles":[],"content":"Namespaces(命名空间) 是 TypeScript 提供的一种组织代码的方法，特别适用于大型项目。通过使用 namespaces，可以将代码分隔成不同的模块，从而避免全局命名空间污染并提升代码的可读性和可维护性。","level":3},{"id":"/notes/ts/book/namespaces#基本语法","title":"基本语法","titles":[],"content":"","level":3},{"id":"/notes/ts/book/namespaces#声明-namespace","title":"声明 Namespace","titles":["基本语法"],"content":"Namespace 使用    关键字进行声明，并可以包含变量、函数、类、接口和子命名空间等。在这个示例中，   包含一个类   ，一个函数    和一个常量   。需要注意的是，必须使用    关键字导出这些成员，否则它们在命名空间外部将不可访问。","level":4},{"id":"/notes/ts/book/namespaces#使用-namespace","title":"使用 Namespace","titles":["基本语法"],"content":"可以通过点符号访问命名空间中的导出成员：","level":4},{"id":"/notes/ts/book/namespaces#嵌套-namespace","title":"嵌套 Namespace","titles":["基本语法","使用 Namespace"],"content":"命名空间可以嵌套，这对于分层次组织代码非常有用。","level":3},{"id":"/notes/ts/book/namespaces#合并-namespaces","title":"合并 Namespaces","titles":["基本语法","使用 Namespace"],"content":"在 TypeScript 中，命名空间可以进行合并。这意味着你可以在多个文件中定义同一个命名空间，它们会被合并在一起。这在大型项目中非常有用。","level":3},{"id":"/notes/ts/book/namespaces#示例合并命名空间","title":"示例：合并命名空间","titles":["基本语法","使用 Namespace","合并 Namespaces"],"content":"文件   ：文件   ：在编译和使用时，   将包含两个函数    和   ：","level":4},{"id":"/notes/ts/book/namespaces#外部模块与-namespaces","title":"外部模块与 Namespaces","titles":["基本语法","使用 Namespace"],"content":"现代 TypeScript 项目通常使用 ES6 模块（即外部模块）来组织代码，而不是命名空间。模块提供了更好的作用域隔离和更灵活的加载机制。","level":3},{"id":"/notes/ts/book/namespaces#namespaces-的使用场景","title":"Namespaces 的使用场景","titles":["基本语法","使用 Namespace"],"content":"虽然外部模块在现代 TypeScript 项目中更为常见，但命名空间在以下场景中仍然有用：全局库 ：对于希望在全局范围内使用的库，命名空间是一个不错的选择。   旧代码迁移 ：在将旧的 JavaScript 项目迁移到 TypeScript 时，命名空间可以帮助逐步组织和隔离代码。   简单项目 ：对于小型项目或简单的脚本，命名空间可以快速组织代码而不需要配置模块加载器。","level":3},{"id":"/notes/ts/book/namespaces#示例项目","title":"示例项目","titles":["基本语法","使用 Namespace"],"content":"以下是一个完整示例，展示了如何在 TypeScript 项目中使用命名空间：","level":3},{"id":"/notes/ts/book/namespaces#文件结构","title":"文件结构","titles":["基本语法","使用 Namespace","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces#mynamespacets","title":"myNamespace.ts","titles":["基本语法","使用 Namespace","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces#indexts","title":"index.ts","titles":["基本语法","使用 Namespace","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces#编译和运行","title":"编译和运行","titles":["基本语法","使用 Namespace"],"content":"使用    命令编译 TypeScript 文件：这会将所有 TypeScript 文件编译为一个单独的 JavaScript 文件   ，并可以在浏览器中运行。","level":3},{"id":"/notes/ts/book/namespaces#总结","title":"总结","titles":["基本语法","使用 Namespace"],"content":"Namespaces 是 TypeScript 提供的一种组织代码的方法，特别适用于大型项目。尽管在现代 TypeScript 项目中，模块化的方式更为常见，但命名空间在某些特定场景中仍然有其优势。理解和灵活运用命名空间和模块，可以帮助你更好地组织和管理你的 TypeScript 代码。","level":3},{"id":"/notes/ts/book/namespaces#参考","title":"参考","titles":["基本语法","使用 Namespace"],"content":"https://www.typescriptlang.org/docs/handbook/namespaces.html#handbook-content","level":3},{"id":"/notes/ts/book/namespaces-and-modules#namespaces-modules命名空间和模块","title":"Namespaces & Modules(命名空间和模块)","titles":[],"content":"在 TypeScript 中，   和    是用于组织和管理代码的两种主要机制。虽然它们在某些方面具有相似性，但它们有不同的用途和应用场景。以下是对 TypeScript 中    和    的详细介绍，包括它们的用法、差异和最佳实践。","level":2},{"id":"/notes/ts/book/namespaces-and-modules#namespaces","title":"Namespaces","titles":["Namespaces & Modules(命名空间和模块)"],"content":"","level":3},{"id":"/notes/ts/book/namespaces-and-modules#什么是-namespaces","title":"什么是 Namespaces?","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"Namespaces 是 TypeScript 中的一个内部模块系统，用于将相关代码组织在一起，以避免全局命名空间的污染。它们使用    关键字定义，可以包含类、接口、函数和变量等。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#声明和使用-namespaces","title":"声明和使用 Namespaces","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#声明-namespace","title":"声明 Namespace","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","声明和使用 Namespaces"],"content":"","level":5},{"id":"/notes/ts/book/namespaces-and-modules#使用-namespace","title":"使用 Namespace","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","声明和使用 Namespaces"],"content":"","level":5},{"id":"/notes/ts/book/namespaces-and-modules#嵌套-namespaces","title":"嵌套 Namespaces","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","声明和使用 Namespaces"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#modules","title":"Modules","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"","level":3},{"id":"/notes/ts/book/namespaces-and-modules#什么是-modules","title":"什么是 Modules?","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Modules"],"content":"Modules 是 TypeScript 和 JavaScript 中的外部模块系统，通过文件和文件夹来组织代码。它们符合 ES6 标准，并使用    和    语法导入和导出模块。模块在模块范围内具有自己的作用域，不会污染全局命名空间。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#声明和使用-modules","title":"声明和使用 Modules","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Modules"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#声明-module","title":"声明 Module","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Modules","声明和使用 Modules"],"content":"创建一个名为    的文件：","level":5},{"id":"/notes/ts/book/namespaces-and-modules#使用-module","title":"使用 Module","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Modules","声明和使用 Modules"],"content":"创建一个名为    的文件：","level":5},{"id":"/notes/ts/book/namespaces-and-modules#differences-between-namespaces-and-modules","title":"Differences between Namespaces and Modules","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"","level":3},{"id":"/notes/ts/book/namespaces-and-modules#用途","title":"用途","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Differences between Namespaces and Modules"],"content":"Namespaces ：适用于在同一个文件或全局范围内组织代码，通常用于小型项目或旧项目的代码组织。   Modules ：适用于大型项目，通过文件和文件夹组织代码，符合现代 JavaScript 标准，支持更好的作用域隔离和模块加载。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#语法","title":"语法","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Differences between Namespaces and Modules"],"content":"Namespaces ：使用    关键字定义，通过点符号访问命名空间成员。   Modules ：使用    和    关键字导入和导出模块成员。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#作用域","title":"作用域","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Differences between Namespaces and Modules"],"content":"Namespaces ：在全局作用域中定义，所有导出的成员在全局可访问。   Modules ：在模块作用域中定义，导出的成员需要显式导入才能访问。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#加载机制","title":"加载机制","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Differences between Namespaces and Modules"],"content":"Namespaces ：不依赖模块加载器，直接在全局作用域中可用。   Modules ：依赖模块加载器（如 CommonJS、AMD、ES6 模块），需要正确的模块解析配置。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#best-practices","title":"Best Practices","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"","level":3},{"id":"/notes/ts/book/namespaces-and-modules#何时使用-namespaces","title":"何时使用 Namespaces","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Best Practices"],"content":"小型项目或简单脚本。  需要在全局范围内共享代码的库或工具。  将现有的 JavaScript 代码迁移到 TypeScript。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#何时使用-modules","title":"何时使用 Modules","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Best Practices"],"content":"大型项目或复杂应用。  需要模块化加载和作用域隔离。  现代 JavaScript 开发环境，使用构建工具（如 Webpack、Rollup）。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#示例项目","title":"示例项目","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"","level":3},{"id":"/notes/ts/book/namespaces-and-modules#文件结构","title":"文件结构","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#mynamespacets","title":"myNamespace.ts","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#indexts","title":"index.ts","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#mymodulemodule1ts","title":"myModule/module1.ts","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#mymodulemodule2ts","title":"myModule/module2.ts","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#总结","title":"总结","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"Namespaces 和 Modules 是 TypeScript 提供的两种组织代码的机制。Namespaces 适用于小型项目或需要全局共享代码的场景，而 Modules 则适用于大型项目，通过模块化加载和作用域隔离来组织代码。在现代开发中，Modules 更加符合 JavaScript 标准，并且是推荐的代码组织方式。理解这两者的差异和应用场景，能够帮助你更好地组织和管理 TypeScript 项目。","level":3},{"id":"/notes/ts/book/namespaces-and-modules#参考","title":"参考","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html#handbook-content","level":3},{"id":"/notes/ts/book/module-resolution#_1-模块解析的种类","title":"1. 模块解析的种类","titles":[],"content":"TypeScript 支持两种主要的模块解析策略：Classic 模式 ：也称为相对路径模式或相对路径引用模式。   Node 模式 ：也称为非相对路径模式或模块解析模式。","level":3},{"id":"/notes/ts/book/module-resolution#_2-classic-模式","title":"2. Classic 模式","titles":[],"content":"Classic 模式是 TypeScript 的旧模块解析策略，主要用于处理在 TypeScript 刚刚推出时的模块系统。它的特点包括：相对路径引用 ：使用相对路径或者以    或    开头的路径来引用模块。   baseUrl 和 paths 配置 ：通过    中的    和    配置来映射模块名称到实际路径。   不支持 Node 模块解析 ：不会考虑 Node.js 中    的结构，主要用于处理不符合 CommonJS 或 AMD 模块规范的模块系统。示例    配置：","level":3},{"id":"/notes/ts/book/module-resolution#_3-node-模式","title":"3. Node 模式","titles":[],"content":"Node 模式是目前推荐的模块解析策略，特点包括：非相对路径引用 ：使用非相对路径来引用模块，如模块名称（如   ）。   Node.js 核心模块解析 ：可以直接引用 Node.js 核心模块（如   ）。   支持   ：支持像 Node.js 一样的    结构，可以从当前文件的目录结构中自动解析出依赖模块。示例    配置：","level":3},{"id":"/notes/ts/book/module-resolution#_4-配置-tsconfigjson","title":"4. 配置   tsconfig.json","titles":[],"content":"在    中，通过    字段可以指定使用哪种模块解析策略。可以选择的值包括：：使用 Node 模块解析策略。   ：使用 Classic 模块解析策略。示例：","level":3},{"id":"/notes/ts/book/module-resolution#_5-模块解析过程","title":"5. 模块解析过程","titles":[],"content":"无论是 Classic 模式还是 Node 模式，模块解析过程一般包括以下步骤：相对路径解析 ：如果模块引用以    或    开头，TypeScript 将根据相对路径寻找对应的模块文件。   baseUrl 和 paths 解析 ：根据    中的    和    配置，将模块名称映射为具体的文件路径。   Node 模块解析 ：在 Node 模式下，TypeScript 会根据 Node.js 的模块解析规则，查找和加载    中的模块。   文件扩展名解析 ：根据    中的    配置或默认配置，解析模块文件的扩展名（如   ,   ,   ,   ,    等）。","level":3},{"id":"/notes/ts/book/module-resolution#_6-总结","title":"6. 总结","titles":[],"content":"模块解析在 TypeScript 中是一个重要的环节，它决定了在编译时如何查找和加载模块依赖。通过正确配置    中的    和相关选项，可以确保 TypeScript 在开发过程中能够正确地解析和处理模块的依赖关系，提高项目的可维护性和可扩展性。","level":3},{"id":"/notes/ts/book/module-resolution#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-resolution#handbook-content","level":3},{"id":"/notes/ts/book/declaration-merging#typescript-declaration-merging-声明合并","title":"TypeScript Declaration Merging (声明合并)","titles":[],"content":"Declaration Merging（声明合并）是 TypeScript 的一个独特功能，它允许开发者将多个声明合并成一个单一声明。这对于扩展现有类型和接口非常有用。在 TypeScript 中，声明合并主要应用于接口、命名空间和函数。","level":3},{"id":"/notes/ts/book/declaration-merging#接口合并","title":"接口合并","titles":[],"content":"当 TypeScript 遇到多个同名接口声明时，它会自动将它们合并成一个接口。这对于为现有接口添加属性或方法非常有用。","level":3},{"id":"/notes/ts/book/declaration-merging#示例接口合并","title":"示例：接口合并","titles":["接口合并"],"content":"在这个示例中，TypeScript 将两个    接口合并成一个包含    和    属性的接口。","level":4},{"id":"/notes/ts/book/declaration-merging#命名空间合并","title":"命名空间合并","titles":["接口合并","示例：接口合并"],"content":"命名空间的声明也可以合并。这在扩展现有命名空间时非常有用，例如为已有的命名空间添加新的函数、类或常量。","level":3},{"id":"/notes/ts/book/declaration-merging#示例命名空间合并","title":"示例：命名空间合并","titles":["接口合并","示例：接口合并","命名空间合并"],"content":"在这个示例中，两个    命名空间被合并，合并后的命名空间包含    接口、   常量和    类。","level":4},{"id":"/notes/ts/book/declaration-merging#函数合并","title":"函数合并","titles":["接口合并","示例：接口合并"],"content":"TypeScript 允许为同一个函数提供多个重载声明，这实际上是通过声明合并实现的。所有重载声明会被合并成一个函数声明。","level":3},{"id":"/notes/ts/book/declaration-merging#示例函数合并","title":"示例：函数合并","titles":["接口合并","示例：接口合并","函数合并"],"content":"在这个示例中，   函数有两个重载声明，一个接受两个数字参数，另一个接受两个字符串参数。最终的实现合并了这两个重载声明。","level":4},{"id":"/notes/ts/book/declaration-merging#类和命名空间合并","title":"类和命名空间合并","titles":["接口合并","示例：接口合并"],"content":"TypeScript 还允许类和命名空间进行合并。这在为一个类添加静态成员或扩展类功能时非常有用。","level":3},{"id":"/notes/ts/book/declaration-merging#示例类和命名空间合并","title":"示例：类和命名空间合并","titles":["接口合并","示例：接口合并","类和命名空间合并"],"content":"在这个示例中，   类和    命名空间合并，   命名空间中的    方法可以作为类的静态方法来使用。","level":4},{"id":"/notes/ts/book/declaration-merging#枚举和命名空间合并","title":"枚举和命名空间合并","titles":["接口合并","示例：接口合并"],"content":"TypeScript 还允许枚举和命名空间进行合并。这在为枚举添加静态方法时非常有用。","level":3},{"id":"/notes/ts/book/declaration-merging#示例枚举和命名空间合并","title":"示例：枚举和命名空间合并","titles":["接口合并","示例：接口合并","枚举和命名空间合并"],"content":"在这个示例中，   枚举和    命名空间合并，   命名空间中的    方法可以作为枚举的静态方法来使用。","level":4},{"id":"/notes/ts/book/declaration-merging#总结","title":"总结","titles":["接口合并","示例：接口合并"],"content":"TypeScript 的声明合并功能允许开发者以模块化和扩展的方式组织代码。通过接口合并、命名空间合并、函数合并、类与命名空间合并以及枚举与命名空间合并，可以轻松地扩展和组织代码，而不必担心名称冲突。了解和利用声明合并功能，可以帮助开发者更灵活地处理复杂的类型定义和模块化编程。","level":3},{"id":"/notes/ts/book/declaration-merging#参考","title":"参考","titles":["接口合并","示例：接口合并"],"content":"https://www.typescriptlang.org/docs/handbook/declaration-merging.html#handbook-content","level":3},{"id":"/notes/ts/book/jsx#_1-jsx-是什么","title":"1. JSX 是什么？","titles":[],"content":"JSX 是 JavaScript XML 的缩写，它允许开发者在 JavaScript 代码中直接编写类似 HTML 的结构。在 React 应用中，开发者可以使用 JSX 来声明组件的 UI 部分，例如：","level":3},{"id":"/notes/ts/book/jsx#_2-typescript-中的-jsx","title":"2. TypeScript 中的 JSX","titles":[],"content":"TypeScript 扩展了对 JSX 的支持，可以在 TypeScript 代码中使用 JSX 语法来描述 React 组件的结构。与普通 JavaScript 不同的是，TypeScript 提供了类型检查和类型推断功能，可以在编译时捕获潜在的类型错误。","level":3},{"id":"/notes/ts/book/jsx#_21-配置-typescript-支持-jsx","title":"2.1. 配置 TypeScript 支持 JSX","titles":["2. TypeScript 中的 JSX"],"content":"在 TypeScript 项目中，需要在    文件中配置    选项，以指定使用哪种 JSX 的语法：：指定使用 React 的 JSX 语法，这是在 React 应用中常见的配置。   ：保留 JSX，不进行转换，这在某些非 React 的项目中可能会使用到。","level":4},{"id":"/notes/ts/book/jsx#_22-typescript-中的-jsx-示例","title":"2.2. TypeScript 中的 JSX 示例","titles":["2. TypeScript 中的 JSX"],"content":"在 TypeScript 文件中，可以直接使用 JSX 语法编写 React 组件：","level":4},{"id":"/notes/ts/book/jsx#_3-typescript-对-jsx-的支持特性","title":"3. TypeScript 对 JSX 的支持特性","titles":["2. TypeScript 中的 JSX","2.2. TypeScript 中的 JSX 示例"],"content":"TypeScript 不仅支持基本的 JSX 语法，还提供了一些增强特性，例如：类型检查 ：检查 JSX 元素的属性是否符合预期的类型。   智能提示 ：提供与 JSX 相关的代码补全和文档提示。   属性扩展 ：支持使用展开操作符    扩展属性。   事件处理 ：对事件处理函数进行类型检查。","level":3},{"id":"/notes/ts/book/jsx#_4-注意事项","title":"4. 注意事项","titles":["2. TypeScript 中的 JSX","2.2. TypeScript 中的 JSX 示例"],"content":"在使用 TypeScript 开发 React 应用时，需要注意以下几点：命名空间冲突 ：JSX 中的    对应 HTML 的    属性，需要注意不要与 TypeScript 的    关键字混淆。   类型声明 ：确保为组件的 props、state 等定义良好的类型声明，以便 TypeScript 可以进行正确的类型推断和检查。","level":3},{"id":"/notes/ts/book/jsx#_5-总结","title":"5. 总结","titles":["2. TypeScript 中的 JSX","2.2. TypeScript 中的 JSX 示例"],"content":"JSX 是一种用于在 JavaScript 中编写类似 XML 结构的语法扩展，在 TypeScript 中，通过配置和类型系统的支持，可以使得在 React 应用中使用 JSX 更加高效和安全。合理配置    文件中的    选项，并且利用 TypeScript 提供的类型检查和智能提示功能，可以显著提升开发效率和代码质量。","level":3},{"id":"/notes/ts/book/jsx#参考","title":"参考","titles":["2. TypeScript 中的 JSX","2.2. TypeScript 中的 JSX 示例"],"content":"https://www.typescriptlang.org/docs/handbook/jsx.html#handbook-content","level":3},{"id":"/notes/ts/book/decorators#_1-基本概念","title":"1. 基本概念","titles":[],"content":"装饰器允许开发者通过注释或修饰类的方式来声明一些特性，这些特性包括：类装饰器 ：应用于类的声明之前，可以用来修改类的行为。   方法装饰器 ：应用于方法的声明之前，可以用来修改方法的行为。   访问器装饰器 ：应用于访问器（getter 和 setter）的声明之前，可以用来修改访问器的行为。   属性装饰器 ：应用于属性的声明之前，可以用来修改属性的行为。   参数装饰器 ：应用于函数参数的声明之前，可以用来修改参数的行为。","level":3},{"id":"/notes/ts/book/decorators#_2-使用装饰器的语法","title":"2. 使用装饰器的语法","titles":[],"content":"装饰器是一个函数，它接收三个参数：对于类成员（方法、属性、访问器或参数），装饰器的参数如下：\n   对于静态成员，是类的构造函数。  对于实例成员，是类的原型对象。  对于方法、访问器和属性，是成员的名称。  对于参数，是参数的索引。装饰器函数的实现可以是任何有效的 JavaScript 函数，通常返回一个函数或者直接操作传入的参数。","level":3},{"id":"/notes/ts/book/decorators#_3-示例","title":"3. 示例","titles":[],"content":"","level":3},{"id":"/notes/ts/book/decorators#_31-类装饰器示例","title":"3.1 类装饰器示例","titles":["3. 示例"],"content":"","level":4},{"id":"/notes/ts/book/decorators#_32-方法装饰器示例","title":"3.2 方法装饰器示例","titles":["3. 示例"],"content":"","level":4},{"id":"/notes/ts/book/decorators#_4-typescript-中的装饰器限制和注意事项","title":"4. TypeScript 中的装饰器限制和注意事项","titles":["3. 示例","3.2 方法装饰器示例"],"content":"实验性特性 ：装饰器目前仍处于实验阶段，可能会有语法和行为上的变化。   装饰器顺序 ：多个装饰器的执行顺序是从下到上、从右到左的。   装饰器应用目标 ：不同类型的装饰器只能应用于特定类型的声明（例如方法装饰器只能应用于方法）。   编译选项 ：使用装饰器需要将 TypeScript 编译器的    选项设置为   。","level":3},{"id":"/notes/ts/book/decorators#_5-总结","title":"5. 总结","titles":["3. 示例","3.2 方法装饰器示例"],"content":"装饰器是 TypeScript 中一个强大的特性，它使得可以通过简单的语法来修改类及其成员的行为，例如添加日志、验证等功能。虽然装饰器目前还是一个实验性特性，但在某些场景下可以提供非常有用的功能增强。在使用装饰器时，建议始终关注 TypeScript 和 JavaScript 的最新文档和规范，以确保正确和稳定的使用。","level":3},{"id":"/notes/ts/book/decorators#参考","title":"参考","titles":["3. 示例","3.2 方法装饰器示例"],"content":"https://www.typescriptlang.org/docs/handbook/decorators.html#handbook-content","level":3},{"id":"/notes/ts/book/mixins#_1-mixin-的基本概念","title":"1. Mixin 的基本概念","titles":[],"content":"Mixin 是一种设计模式，它通过组合多个类（或对象）的特性来创建一个新的类。在 TypeScript 中，通常使用一些技术（如交叉类型和类型断言）来实现 Mixin。","level":3},{"id":"/notes/ts/book/mixins#_2-实现-mixin-的方法","title":"2. 实现 Mixin 的方法","titles":[],"content":"","level":3},{"id":"/notes/ts/book/mixins#_21-基于类的-mixin","title":"2.1. 基于类的 Mixin","titles":["2. 实现 Mixin 的方法"],"content":"基于类的 Mixin 是通过将现有类的方法和属性合并到新的类中来实现的。例如，假设有一个 Logger Mixin，它可以将日志记录功能添加到类中：","level":4},{"id":"/notes/ts/book/mixins#_22-基于函数的-mixin","title":"2.2. 基于函数的 Mixin","titles":["2. 实现 Mixin 的方法"],"content":"基于函数的 Mixin 使用函数返回一个具有特定特性的对象，而不是一个类。这种方法更灵活，适用于需要动态组合功能的场景。","level":4},{"id":"/notes/ts/book/mixins#_3-mixin-的优势和注意事项","title":"3. Mixin 的优势和注意事项","titles":["2. 实现 Mixin 的方法","2.2. 基于函数的 Mixin"],"content":"优势 ：    避免类层次结构过深 ：通过 Mixin 可以避免创建过深的类继承层次结构。   灵活性 ：可以根据需求动态组合类的特性，而不是硬编码在类定义中。   复用性 ：可以将相同的 Mixin 应用于多个类，提高代码复用性。   注意事项 ：    命名冲突 ：当多个 Mixin 中存在相同名称的方法或属性时，可能会引起命名冲突，需要适当处理。   装饰器替代 ：在某些情况下，装饰器可能更适合用于添加类的额外功能，因为装饰器提供了更好的语法支持和类型安全性。","level":3},{"id":"/notes/ts/book/mixins#_4-总结","title":"4. 总结","titles":["2. 实现 Mixin 的方法","2.2. 基于函数的 Mixin"],"content":"Mixin 是一种强大的设计模式，允许开发者通过组合类的方式来创建具有多个功能的新类。在 TypeScript 中，可以通过基于类的方法或基于函数的方法实现 Mixin。使用 Mixin 可以避免类继承层次结构过深的问题，并提高代码的灵活性和复用性。然而，在使用 Mixin 时需要注意命名冲突和适当的设计，以确保代码的清晰和可维护性。","level":3},{"id":"/notes/ts/book/mixins#参考","title":"参考","titles":["2. 实现 Mixin 的方法","2.2. 基于函数的 Mixin"],"content":"https://www.typescriptlang.org/docs/handbook/mixins.html#handbook-content","level":3},{"id":"/notes/ts/book/triple-slash-directives#三斜线指令triple-slash-directives","title":"三斜线指令(Triple-Slash Directives)","titles":[],"content":"三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。三斜线指令  仅 可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。","level":1},{"id":"/notes/ts/book/triple-slash-directives#reference-path","title":"/// <reference path=\"...\" />","titles":["三斜线指令(Triple-Slash Directives)"],"content":"指令是三斜线指令中最常见的一种。 它用于声明文件间的   依赖 。三斜线引用告诉编译器在编译过程中要引入的额外的文件。当使用  或  时，它也可以做为调整输出内容顺序的一种方法。 文件在输出文件内容中的位置与经过预处理后的输入顺序一致。","level":2},{"id":"/notes/ts/book/triple-slash-directives#预处理输入文件","title":"预处理输入文件","titles":["三斜线指令(Triple-Slash Directives)","/// <reference path=\"...\" />"],"content":"编译器会对输入文件进行预处理来解析所有三斜线引用指令。 在这个过程中，额外的文件会加到编译过程中。这个过程会以一些  根文件 开始； 它们是在命令行中指定的文件或是在   中的  列表里的文件。 这些根文件按指定的顺序进行预处理。 在一个文件被加入列表前，它包含的所有三斜线引用都要被处理，还有它们包含的目标。 三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析。一个三斜线引用路径是相对于包含它的文件的，如果不是根文件。","level":3},{"id":"/notes/ts/book/triple-slash-directives#错误","title":"错误","titles":["三斜线指令(Triple-Slash Directives)","/// <reference path=\"...\" />"],"content":"引用不存在的文件会报错。 一个文件用三斜线指令引用自己会报错。","level":3},{"id":"/notes/ts/book/triple-slash-directives#使用-noresolve","title":"使用   --noResolve","titles":["三斜线指令(Triple-Slash Directives)","/// <reference path=\"...\" />"],"content":"如果指定了  编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。","level":3},{"id":"/notes/ts/book/triple-slash-directives#reference-types","title":"/// <reference types=\"...\" />","titles":["三斜线指令(Triple-Slash Directives)"],"content":"与   指令相似，这个指令是用来声明   依赖 的； 一个   指令则声明了对某个包的依赖。对这些包的名字的解析与在   语句里对模块名的解析类似。 可以简单地把三斜线类型引用指令当做   声明的包。例如，把   引入到声明文件，表明这个文件使用了   里面声明的名字； 并且，这个包需要在编译阶段与声明文件一起被包含进来。仅当在你需要写一个  文件时才使用这个指令。对于那些在编译阶段生成的声明文件，编译器会自动地添加  ；   当且仅当 结果文件中使用了引用的包里的声明时才会在生成的声明文件里添加  语句。若要在  文件里声明一个对  包的依赖，使用  命令行选项或在  里指定。 查看   在  里使用  ，  和  了解详情。","level":2},{"id":"/notes/ts/book/triple-slash-directives#reference-no-default-libtrue","title":"/// <reference no-default-lib=\"true\"/>","titles":["三斜线指令(Triple-Slash Directives)"],"content":"这个指令把一个文件标记成  默认库 。 你会在   文件和它不同的变体的顶端看到这个注释。这个指令告诉编译器在编译过程中  不要 包含这个默认库（比如，  ）。 这与在命令行上使用   相似。还要注意，当传递了  时，编译器只会忽略检查带有  的文件。","level":2},{"id":"/notes/ts/book/triple-slash-directives#amd-module","title":"/// <amd-module />","titles":["三斜线指令(Triple-Slash Directives)"],"content":"默认情况下生成的AMD模块都是匿名的。 但是，当一些工具需要处理生成的模块时会产生问题，比如   。指令允许给编译器传入一个可选的模块名：","level":2},{"id":"/notes/ts/book/triple-slash-directives#amdmodulets","title":"amdModule.ts","titles":["三斜线指令(Triple-Slash Directives)","/// <amd-module />"],"content":"这会将  传入到AMD   函数里：","level":5},{"id":"/notes/ts/book/triple-slash-directives#amdmodulejs","title":"amdModule.js","titles":["三斜线指令(Triple-Slash Directives)","/// <amd-module />"],"content":"","level":5},{"id":"/notes/ts/book/triple-slash-directives#amd-dependency","title":"/// <amd-dependency />","titles":["三斜线指令(Triple-Slash Directives)"],"content":"注意 ：这个指令被废弃了。使用  语句代替。告诉编译器有一个非TypeScript模块依赖需要被注入，做为目标模块  调用的一部分。指令也可以带一个可选的  属性；它允许我们为amd-dependency传入一个可选名字：生成的JavaScript代码：","level":2},{"id":"/notes/ts/book/triple-slash-directives#参考","title":"参考","titles":["三斜线指令(Triple-Slash Directives)","/// <amd-dependency />"],"content":"https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html","level":3},{"id":"/notes/ts/book/type-checking-javascript-files#javascript-文件类型检查","title":"JavaScript 文件类型检查","titles":[],"content":"TypeScript 2.3 以后的版本支持使用  对  文件进行类型检查和错误提示。你可以通过添加  注释来忽略类型检查；相反，你可以通过去掉  设置并添加一个  注释来选则检查某些  文件。 你还可以使用  来忽略本行的错误。 如果你使用了  ，JS 检查将遵照一些严格检查标记，如  ，  等。 但因为 JS 检查是相对宽松的，在使用严格标记时可能会有些出乎意料的情况。对比  文件和  文件在类型检查上的差异，有如下几点需要注意：","level":1},{"id":"/notes/ts/book/type-checking-javascript-files#用-jsdoc-类型表示类型信息","title":"用 JSDoc 类型表示类型信息","titles":["JavaScript 文件类型检查"],"content":"文件里，类型可以和在  文件里一样被推断出来。 同样地，当类型不能被推断时，它们可以通过 JSDoc 来指定，就好比在  文件里那样。 如同 TypeScript，  会在编译器无法推断类型的位置报错。 （除了对象字面量的情况；后面会详细介绍）JSDoc 注解修饰的声明会被设置为这个声明的类型。比如：你可以在这里找到所有 JSDoc 支持的模式，  JSDoc 文档 。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#属性的推断来自于类内的赋值语句","title":"属性的推断来自于类内的赋值语句","titles":["JavaScript 文件类型检查"],"content":"ES2015 没提供声明类属性的方法。属性是动态赋值的，就像对象字面量一样。在  文件里，编译器从类内部的属性赋值语句来推断属性类型。 属性的类型是在构造函数里赋的值的类型，除非它没在构造函数里定义或者在构造函数里是  或  。 若是这种情况，类型将会是所有赋的值的类型的联合类型。 在构造函数里定义的属性会被认为是一直存在的，然而那些在方法，存取器里定义的属性被当成可选的。如果一个属性从没在类内设置过，它们会被当成未知的。如果类的属性只是读取用的，那么就在构造函数里用 JSDoc 声明它的类型。 如果它稍后会被初始化，你甚至都不需要在构造函数里给它赋值：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#构造函数等同于类","title":"构造函数等同于类","titles":["JavaScript 文件类型检查"],"content":"ES2015 以前，Javascript 使用构造函数代替类。 编译器支持这种模式并能够将构造函数识别为 ES2015 的类。 属性类型推断机制和上面介绍的一致。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#支持-commonjs-模块","title":"支持 CommonJS 模块","titles":["JavaScript 文件类型检查"],"content":"在  文件里，TypeScript 能识别出 CommonJS 模块。 对  和  的赋值被识别为导出声明。 相似地，  函数调用被识别为模块导入。例如：对 JavaScript 文件里模块语法的支持比在 TypeScript 里宽泛多了。 大部分的赋值和声明方式都是允许的。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#类函数和对象字面量是命名空间","title":"类，函数和对象字面量是命名空间","titles":["JavaScript 文件类型检查"],"content":"文件里的类是命名空间。 它可以用于嵌套类，比如：ES2015 之前的代码，它可以用来模拟静态方法：它还可以用于创建简单的命名空间：同时还支持其它的变化：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#对象字面量是开放的","title":"对象字面量是开放的","titles":["JavaScript 文件类型检查"],"content":"文件里，用对象字面量初始化一个变量的同时也给它声明了类型。 新的成员不能再被添加到对象字面量中。 这个规则在  文件里被放宽了；对象字面量具有开放的类型，允许添加并访问原先没有定义的属性。例如：对象字面量的表现就好比具有一个默认的索引签名  ，它们可以被当成开放的映射而不是封闭的对象。与其它 JS 检查行为相似，这种行为可以通过指定 JSDoc 类型来改变，例如：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#nullundefined和空数组的类型是-any-或-any","title":"null，undefined，和空数组的类型是 any 或 any","titles":["JavaScript 文件类型检查"],"content":"任何用  ，  初始化的变量，参数或属性，它们的类型是  ，就算是在严格  检查模式下。 任何用  初始化的变量，参数或属性，它们的类型是  ，就算是在严格  检查模式下。 唯一的例外是像上面那样有多个初始化器的属性。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#函数参数是默认可选的","title":"函数参数是默认可选的","titles":["JavaScript 文件类型检查"],"content":"由于在 ES2015 之前无法指定可选参数，因此  文件里所有函数参数都被当做是可选的。 使用比预期少的参数调用函数是允许的。需要注意的一点是，使用过多的参数调用函数会得到一个错误。例如：使用 JSDoc 注解的函数会被从这条规则里移除。 使用 JSDoc 可选参数语法来表示可选性。比如：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#由arguments推断出的-var-args-参数声明","title":"由  arguments 推断出的 var-args 参数声明","titles":["JavaScript 文件类型检查"],"content":"如果一个函数的函数体内有对  的引用，那么这个函数会隐式地被认为具有一个 var-arg 参数（比如:  )）。使用 JSDoc 的 var-arg 语法来指定  的类型。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#未指定的类型参数默认为any","title":"未指定的类型参数默认为  any","titles":["JavaScript 文件类型检查"],"content":"由于 JavaScript 里没有一种自然的语法来指定泛型参数，因此未指定的参数类型默认为  。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#在-extends-语句中","title":"在 extends 语句中：","titles":["JavaScript 文件类型检查","未指定的类型参数默认为  any"],"content":"例如，  被定义成具有两个类型参数，  和  。 在一个  文件里，没有一个合法的方式在 extends 语句里指定它们。默认地参数类型为  ：使用 JSDoc 的  来明确地指定类型。例如：","level":3},{"id":"/notes/ts/book/type-checking-javascript-files#在-jsdoc-引用中","title":"在 JSDoc 引用中：","titles":["JavaScript 文件类型检查","未指定的类型参数默认为  any"],"content":"JSDoc 里未指定的类型参数默认为  ：","level":3},{"id":"/notes/ts/book/type-checking-javascript-files#在函数调用中","title":"在函数调用中","titles":["JavaScript 文件类型检查","未指定的类型参数默认为  any"],"content":"泛型函数的调用使用  来推断泛型参数。有时候，这个流程不能够推断出类型，大多是因为缺少推断的源；在这种情况下，类型参数类型默认为  。例如：","level":3},{"id":"/notes/ts/book/type-checking-javascript-files#支持的-jsdoc","title":"支持的 JSDoc","titles":[],"content":"下面的列表列出了当前所支持的 JSDoc 注解，你可以用它们在 JavaScript 文件里添加类型信息。注意，没有在下面列出的标记（例如  ）都是还不支持的。(or    or   )    (or   )          (or   )      (or   )它们代表的意义与 usejsdoc.org 上面给出的通常是一致的或者是它的超集。 下面的代码描述了它们的区别并给出了一些示例。","level":1},{"id":"/notes/ts/book/type-checking-javascript-files#type","title":"@type","titles":["支持的 JSDoc"],"content":"可以使用  标记并引用一个类型名称（原始类型，TypeScript 里声明的类型，或在 JSDoc 里  标记指定的） 可以使用任何 TypeScript 类型和大多数 JSDoc 类型。可以指定联合类型—例如，  和  类型的联合。注意，括号是可选的。有多种方式来指定数组类型：还可以指定对象字面量类型。 例如，一个带有  （字符串）和  （数字）属性的对象，使用下面的语法：可以使用字符串和数字索引签名来指定  和  的对象，使用标准的 JSDoc 语法或者 TypeScript 语法。这两个类型与 TypeScript 里的  和  是等同的。编译器能识别出这两种语法。可以使用 TypeScript 或 Closure 语法指定函数类型。或者直接使用未指定的  类型：Closure 的其它类型也可以使用：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#转换","title":"转换","titles":["支持的 JSDoc","@type"],"content":"TypeScript 借鉴了 Closure 里的转换语法。 在括号表达式前面使用  标记，可以将一种类型转换成另一种类型","level":3},{"id":"/notes/ts/book/type-checking-javascript-files#导入类型","title":"导入类型","titles":["支持的 JSDoc","@type"],"content":"可以使用导入类型从其它文件中导入声明。 这个语法是 TypeScript 特有的，与 JSDoc 标准不同：导入类型也可以使用在类型别名声明中：导入类型可以用在从模块中得到一个值的类型。","level":3},{"id":"/notes/ts/book/type-checking-javascript-files#param和returns","title":"@param 和  @returns","titles":["支持的 JSDoc"],"content":"语法和  相同，但增加了一个参数名。 使用  可以把参数声明为可选的：函数的返回值类型也是类似的：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#typedef-callback-和-param","title":"@typedef ,   @callback , 和   @param","titles":["支持的 JSDoc"],"content":"可以用来声明复杂类型。 和  类似的语法。可以在第一行上使用  或  。允许使用相似的语法。 注意，嵌套的属性名必须使用参数名做为前缀：与  相似，但它指定函数类型而不是对象类型：当然，所有这些类型都可以使用 TypeScript 的语法  在一行上声明：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#template","title":"@template","titles":["支持的 JSDoc"],"content":"使用  声明泛型：用逗号或多个标记来声明多个类型参数：还可以在参数名前指定类型约束。 只有列表的第一项类型参数会被约束：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#constructor","title":"@constructor","titles":["支持的 JSDoc"],"content":"编译器通过  属性的赋值来推断构造函数，但你可以让检查更严格提示更友好，你可以添加一个  标记：通过  ，  将在构造函数  里被检查，因此你在  方法里得到一个提示，如果你传入一个数字你还将得到一个错误提示。如果你直接调用  而不是构造它，也会得到一个错误。不幸的是，这意味着那些既能构造也能直接调用的构造函数不能使用  。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#this","title":"@this","titles":["支持的 JSDoc"],"content":"编译器通常可以通过上下文来推断出  的类型。但你可以使用  来明确指定它的类型：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#extends","title":"@extends","titles":["支持的 JSDoc"],"content":"当 JavaScript 类继承了一个基类，无处指定类型参数的类型。而  标记提供了这样一种方式：注意  只作用于类。当前，无法实现构造函数继承类的情况。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#enum","title":"@enum","titles":["支持的 JSDoc"],"content":"标记允许你创建一个对象字面量，它的成员都有确定的类型。不同于 JavaScript 里大多数的对象字面量，它不允许添加额外成员。注意  与 TypeScript 的  大不相同，它更加简单。然而，不同于 TypeScript 的枚举，  可以是任何类型：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#更多示例","title":"更多示例","titles":["支持的 JSDoc"],"content":"","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#已知不支持的模式","title":"已知不支持的模式","titles":["支持的 JSDoc"],"content":"在值空间中将对象视为类型是不可以的，除非对象创建了类型，如构造函数。对象字面量属性上的  后缀不能指定这个属性是可选的：类型只在启用了  检查时才启作用：类型没有意义，以其原类型对待：不同于 JSDoc 类型系统，TypeScript 只允许将类型标记为包不包含  。 没有明确的   -- 如果启用了  ，那么  是非  的。 如果没有启用，那么  是可以为  的。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#参考","title":"参考","titles":["支持的 JSDoc","已知不支持的模式"],"content":"https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#handbook-content","level":3},{"id":"/notes/ts/declaration-files/introduction#_1-声明文件的作用","title":"1. 声明文件的作用","titles":[],"content":"TypeScript 的类型系统需要了解每个变量、函数、类和模块的类型。对于 JavaScript 代码库，特别是那些没有原生支持 TypeScript 的第三方库，TypeScript 需要额外的声明文件来描述这些库的类型信息。声明文件告诉 TypeScript 每个符号的类型、结构和如何使用它们。","level":3},{"id":"/notes/ts/declaration-files/introduction#_2-使用声明文件","title":"2. 使用声明文件","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/introduction#通过-definitelytyped","title":"通过 DefinitelyTyped","titles":["2. 使用声明文件"],"content":"大多数常见的第三方 JavaScript 库都已经有了相应的声明文件，这些声明文件通常托管在 DefinitelyTyped 社区。可以通过以下几种方式获取和使用声明文件：npm 安装 ：很多声明文件都已经发布到 npm 上，可以通过    包前缀进行安装。     手动下载 ：可以直接从 DefinitelyTyped 的 GitHub 仓库手动下载声明文件，并将其放置在项目中。","level":4},{"id":"/notes/ts/declaration-files/introduction#编写自定义声明文件","title":"编写自定义声明文件","titles":["2. 使用声明文件"],"content":"如果要使用的库没有相关的声明文件，或者需要自定义类型声明，可以编写自己的声明文件。文件命名约定 ：声明文件通常以    为后缀，比如   。   声明文件语法 ：使用 TypeScript 的声明语法描述变量、函数、类、接口等的类型信息。     全局变量声明 ：描述全局变量的类型信息。","level":4},{"id":"/notes/ts/declaration-files/introduction#_3-使用声明文件的注意事项","title":"3. 使用声明文件的注意事项","titles":["2. 使用声明文件","编写自定义声明文件"],"content":"全局声明 ：如果声明文件定义了全局变量或全局模块，在使用之前需要确保它们在全局作用域中可用。   模块声明 ：如果声明文件定义了模块内的类型信息，需要使用    或    来导入声明的类型。   类型合并 ：可以通过声明合并（Declaration Merging）来扩展已有类型的定义。","level":3},{"id":"/notes/ts/declaration-files/introduction#_4-示例应用","title":"4. 示例应用","titles":["2. 使用声明文件","编写自定义声明文件"],"content":"假设有一个 JavaScript 库   ，我们想在 TypeScript 中使用它，但是它没有类型定义文件：为了在 TypeScript 中使用，我们可以编写一个声明文件   ：然后在 TypeScript 项目中导入和使用该模块：","level":3},{"id":"/notes/ts/declaration-files/introduction#_5-自动生成声明文件","title":"5. 自动生成声明文件","titles":["2. 使用声明文件","编写自定义声明文件"],"content":"对于自己编写的 TypeScript 代码，TypeScript 编译器会自动为每个 TypeScript 文件生成相应的声明文件（  ），这些文件包含了已声明的类型信息，可以被其他 TypeScript 项目导入和使用。","level":3},{"id":"/notes/ts/declaration-files/introduction#总结","title":"总结","titles":["2. 使用声明文件","编写自定义声明文件"],"content":"TypeScript 声明文件是一种重要的工具，用于描述 JavaScript 库的类型信息，使得 TypeScript 可以进行类型检查和智能提示。通过使用已有的声明文件或编写自定义的声明文件，可以很好地整合第三方 JavaScript 库到 TypeScript 项目中，并获得类型安全和开发效率的提升。","level":3},{"id":"/notes/ts/declaration-files/introduction#参考","title":"参考","titles":["2. 使用声明文件","编写自定义声明文件"],"content":"https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html","level":3},{"id":"/notes/ts/declaration-files/library-structures#_1-基本结构","title":"1. 基本结构","titles":[],"content":"一个典型的 TypeScript 库通常包含以下基本元素：源代码文件夹 （src）：存放 TypeScript 源码文件。   编译输出文件夹 （dist 或 lib）：存放编译后的 JavaScript 文件（如果需要发布给用户）。   类型声明文件夹 （types 或 typings）：存放 TypeScript 声明文件（  ）。","level":3},{"id":"/notes/ts/declaration-files/library-structures#_2-设计原则和最佳实践","title":"2. 设计原则和最佳实践","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/library-structures#_21-使用-es-模块","title":"2.1. 使用 ES 模块","titles":["2. 设计原则和最佳实践"],"content":"推荐使用 ES 模块作为默认的模块格式，因为它提供了静态分析、树摇（去除未使用代码）和更清晰的语法。如果需要兼容 CommonJS（例如在 Node.js 中使用），可以通过工具进行转换或使用条件导出。","level":4},{"id":"/notes/ts/declaration-files/library-structures#_22-利用命名空间和模块","title":"2.2. 利用命名空间和模块","titles":["2. 设计原则和最佳实践"],"content":"命名空间（Namespace） ：用于将相关的类型和函数组织在一起，但在现代 TypeScript 开发中，推荐使用 ES 模块来代替命名空间。     模块（Module） ：用于将相关的代码组织成一个独立的单元，可以导出和导入模块中的内容。","level":4},{"id":"/notes/ts/declaration-files/library-structures#_23-声明文件","title":"2.3. 声明文件","titles":["2. 设计原则和最佳实践"],"content":"对于每个 TypeScript 文件，TypeScript 编译器会自动生成对应的声明文件（  ），如果需要自定义声明，可以创建单独的声明文件。","level":4},{"id":"/notes/ts/declaration-files/library-structures#_24-模块化的组织方式","title":"2.4. 模块化的组织方式","titles":["2. 设计原则和最佳实践"],"content":"根据功能和使用频率，将功能相关的代码组织成模块，并尽可能减少模块之间的耦合。可以通过模块的导入和导出来管理模块之间的依赖关系。","level":4},{"id":"/notes/ts/declaration-files/library-structures#_25-编译和构建","title":"2.5. 编译和构建","titles":["2. 设计原则和最佳实践"],"content":"在    中配置编译选项，确保 TypeScript 编译器可以正确地将 TypeScript 代码转换为 JavaScript 代码，并生成声明文件。","level":4},{"id":"/notes/ts/declaration-files/library-structures#_3-示例应用","title":"3. 示例应用","titles":["2. 设计原则和最佳实践","2.5. 编译和构建"],"content":"假设有一个名为    的 TypeScript 库，可以按以下结构组织代码：在    中导出库的主要功能，例如：然后在    中配置编译选项，生成 JavaScript 文件和声明文件到    和    目录。","level":3},{"id":"/notes/ts/declaration-files/library-structures#_4-发布和文档化","title":"4. 发布和文档化","titles":["2. 设计原则和最佳实践","2.5. 编译和构建"],"content":"发布 TypeScript 库时，可以使用 npm 进行发布，并确保包含编译后的 JavaScript 文件和相应的声明文件。另外，编写清晰的文档（如 README.md 文件）来说明库的用途、安装方法和使用示例，提高库的易用性和可维护性。","level":3},{"id":"/notes/ts/declaration-files/library-structures#总结","title":"总结","titles":["2. 设计原则和最佳实践","2.5. 编译和构建"],"content":"设计和组织 TypeScript 库的结构是一个综合考虑功能模块化、依赖管理、编译配置和发布流程的过程。通过合理的结构设计，可以使得库更易于维护、扩展和使用，提高代码的可读性和可靠性。","level":3},{"id":"/notes/ts/declaration-files/library-structures#参考","title":"参考","titles":["2. 设计原则和最佳实践","2.5. 编译和构建"],"content":"https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html","level":3},{"id":"/notes/ts/declaration-files/by-example#_1-全局变量","title":"1. 全局变量","titles":[],"content":"假设要声明一个全局变量   ，它是一个字符串类型。","level":3},{"id":"/notes/ts/declaration-files/by-example#typescript-声明文件","title":"TypeScript 声明文件","titles":["1. 全局变量"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#api-文档","title":"API 文档","titles":["1. 全局变量"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#示例","title":"示例","titles":["1. 全局变量"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#_2-全局函数","title":"2. 全局函数","titles":["1. 全局变量","示例"],"content":"假设要声明一个全局函数   ，它接受一个字符串参数并返回一个字符串。","level":3},{"id":"/notes/ts/declaration-files/by-example#typescript-声明文件-1","title":"TypeScript 声明文件","titles":["1. 全局变量","示例","2. 全局函数"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#api-文档-1","title":"API 文档","titles":["1. 全局变量","示例","2. 全局函数"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#示例-1","title":"示例","titles":["1. 全局变量","示例","2. 全局函数"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#_3-带属性的对象","title":"3. 带属性的对象","titles":["1. 全局变量","示例"],"content":"假设要声明一个对象   ，它有一个属性    和一个方法   。","level":3},{"id":"/notes/ts/declaration-files/by-example#typescript-声明文件-2","title":"TypeScript 声明文件","titles":["1. 全局变量","示例","3. 带属性的对象"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#api-文档-2","title":"API 文档","titles":["1. 全局变量","示例","3. 带属性的对象"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#示例-2","title":"示例","titles":["1. 全局变量","示例","3. 带属性的对象"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#_4-函数重载","title":"4. 函数重载","titles":["1. 全局变量","示例"],"content":"假设要声明一个函数   ，它根据传入参数的类型不同有不同的行为。","level":3},{"id":"/notes/ts/declaration-files/by-example#typescript-声明文件-3","title":"TypeScript 声明文件","titles":["1. 全局变量","示例","4. 函数重载"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#api-文档-3","title":"API 文档","titles":["1. 全局变量","示例","4. 函数重载"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#示例-3","title":"示例","titles":["1. 全局变量","示例","4. 函数重载"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#_5-可重用类型接口","title":"5. 可重用类型（接口）","titles":["1. 全局变量","示例"],"content":"假设要声明一个接口   ，描述一个人的基本信息。","level":3},{"id":"/notes/ts/declaration-files/by-example#typescript-声明文件-4","title":"TypeScript 声明文件","titles":["1. 全局变量","示例","5. 可重用类型（接口）"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#api-文档-4","title":"API 文档","titles":["1. 全局变量","示例","5. 可重用类型（接口）"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#示例-4","title":"示例","titles":["1. 全局变量","示例","5. 可重用类型（接口）"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#_6-可重用类型类型别名","title":"6. 可重用类型（类型别名）","titles":["1. 全局变量","示例"],"content":"假设要声明一个类型别名   ，用于描述坐标的类型。","level":3},{"id":"/notes/ts/declaration-files/by-example#typescript-声明文件-5","title":"TypeScript 声明文件","titles":["1. 全局变量","示例","6. 可重用类型（类型别名）"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#api-文档-5","title":"API 文档","titles":["1. 全局变量","示例","6. 可重用类型（类型别名）"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#示例-5","title":"示例","titles":["1. 全局变量","示例","6. 可重用类型（类型别名）"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#_7-组织类型","title":"7. 组织类型","titles":["1. 全局变量","示例"],"content":"假设要声明一个类   ，它有一个构造函数和一些实例方法。","level":3},{"id":"/notes/ts/declaration-files/by-example#typescript-声明文件-6","title":"TypeScript 声明文件","titles":["1. 全局变量","示例","7. 组织类型"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#api-文档-6","title":"API 文档","titles":["1. 全局变量","示例","7. 组织类型"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#示例-6","title":"示例","titles":["1. 全局变量","示例","7. 组织类型"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#总结","title":"总结","titles":["1. 全局变量","示例"],"content":"编写高质量的 TypeScript 声明文件需要结合清晰的 API 文档和实际示例，确保用户可以轻松理解和正确使用你的库。通过合理的组织和描述，可以提升代码的可读性、可维护性，以及 TypeScript 的类型推断和类型安全检查效果。","level":3},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#_1-普通类型","title":"1. 普通类型","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#正常用例","title":"正常用例","titles":["1. 普通类型"],"content":"普通类型指的是 TypeScript 中的基本数据类型和自定义类型。这些类型可以用来声明变量、函数参数、返回值等。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#错误用例","title":"错误用例","titles":["1. 普通类型"],"content":"错误的使用方式包括将变量赋予不匹配的类型或者在函数调用时传递不符合类型预期的参数。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#_2-泛型","title":"2. 泛型","titles":["1. 普通类型","错误用例"],"content":"泛型允许在定义函数、类或接口时延迟指定类型，提高代码的复用性和灵活性。","level":3},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#正常用例-1","title":"正常用例","titles":["1. 普通类型","错误用例","2. 泛型"],"content":"使用泛型可以在定义函数或类时不指定具体类型，而是在使用时根据传入的参数类型来确定。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#错误用例-1","title":"错误用例","titles":["1. 普通类型","错误用例","2. 泛型"],"content":"在泛型使用中的错误通常涉及类型不匹配或不正确的用法。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#_3-回调函数类型","title":"3. 回调函数类型","titles":["1. 普通类型","错误用例"],"content":"回调函数类型是指在 TypeScript 中定义函数参数时指定函数的类型。","level":3},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#正常用例-2","title":"正常用例","titles":["1. 普通类型","错误用例","3. 回调函数类型"],"content":"使用回调函数类型可以确保函数接受正确类型的函数作为参数。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#错误用例-2","title":"错误用例","titles":["1. 普通类型","错误用例","3. 回调函数类型"],"content":"错误的回调函数类型使用可能导致参数类型不匹配或函数调用失败。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#_4-函数重载","title":"4. 函数重载","titles":["1. 普通类型","错误用例"],"content":"函数重载允许定义多个函数签名来处理不同的参数类型或数量，提高函数的灵活性和适用性。","level":3},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#正常用例-3","title":"正常用例","titles":["1. 普通类型","错误用例","4. 函数重载"],"content":"通过合理定义函数重载，可以根据不同的参数类型或数量调用不同的函数实现。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#错误用例-3","title":"错误用例","titles":["1. 普通类型","错误用例","4. 函数重载"],"content":"错误的函数重载定义或调用可能导致函数无法正确识别参数类型。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#总结","title":"总结","titles":["1. 普通类型","错误用例"],"content":"遵循 TypeScript 规范，正确使用普通类型、泛型、回调函数类型和函数重载是确保代码类型安全性和可维护性的重要步骤。通过合理的类型定义和使用，可以有效减少运行时错误，并提升代码的可读性和可靠性。","level":3},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#参考","title":"参考","titles":["1. 普通类型","错误用例"],"content":"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html","level":3},{"id":"/notes/ts/declaration-files/templates#global-modifying-moduledts","title":"global-modifying-module.d.ts","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/templates#global-plugindts","title":"global-plugin.d.ts","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/templates#globaldts","title":"global.d.ts","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/templates#module-classdts","title":"module-class.d.ts","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/templates#module-functiondts","title":"module-function.d.ts","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/templates#module-plugindts","title":"module-plugin.d.ts","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/templates#moduledts","title":"module.d.ts","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/templates#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html","level":3},{"id":"/notes/ts/declaration-files/publishing#_1-准备项目","title":"1. 准备项目","titles":[],"content":"首先，确保你的 TypeScript 项目已经完成开发，并通过 TypeScript 编译器（  ）将 TypeScript 代码编译为 JavaScript。项目中应包含以下关键文件：：项目的配置文件，包含项目的名称、版本、依赖等信息。  编译后的 JavaScript 文件（通常位于    或    目录下）。  TypeScript 声明文件（   文件），如果有的话。","level":3},{"id":"/notes/ts/declaration-files/publishing#_2-配置-packagejson","title":"2. 配置   package.json","titles":[],"content":"在    文件中，需要做以下几个关键配置：name ：包的名称，确保它在 npm 中是唯一的。   version ：包的版本号。   main ：指定入口文件，通常是编译后的 JavaScript 文件。   typings ：指定 TypeScript 声明文件的入口文件（如果有的话）。   license ：指定项目的许可证类型。   dependencies  和   devDependencies ：列出项目的依赖，确保所有依赖都被正确声明。例如，一个简单的    配置可能如下所示：","level":3},{"id":"/notes/ts/declaration-files/publishing#_3-构建项目","title":"3. 构建项目","titles":[],"content":"确保你的项目可以成功构建并生成编译后的 JavaScript 文件和 TypeScript 声明文件。你可以使用    命令来进行手动编译，或者配置构建脚本在    中自动执行。运行    或    来执行构建。","level":3},{"id":"/notes/ts/declaration-files/publishing#_4-登录-npm-账号","title":"4. 登录 npm 账号","titles":[],"content":"在发布之前，你需要登录你的 npm 账号。如果没有账号，可以使用    命令注册一个新账号。","level":3},{"id":"/notes/ts/declaration-files/publishing#_5-发布到-npm","title":"5. 发布到 npm","titles":[],"content":"完成上述步骤后，即可进行发布。登录 npm 账号 ：     发布包 ：    如果是第一次发布该包，可能需要添加    参数来确保包对所有人可见：","level":3},{"id":"/notes/ts/declaration-files/publishing#_6-验证发布","title":"6. 验证发布","titles":[],"content":"发布完成后，可以访问 npm 上的包页面，确认包已经成功发布。确保可以安装包并使用。","level":3},{"id":"/notes/ts/declaration-files/publishing#_7-发布-typescript-声明文件","title":"7. 发布 TypeScript 声明文件","titles":[],"content":"如果你的项目包含 TypeScript 声明文件，确保它们也包含在你的发布包中，并在    中正确配置    字段。通常情况下，编译后的 JavaScript 文件和 TypeScript 声明文件应该位于    目录（或其他类似目录）下，并在    中相应地引用。","level":3},{"id":"/notes/ts/declaration-files/publishing#示例完整的发布流程","title":"示例：完整的发布流程","titles":[],"content":"假设你的项目名称为   ，包含了一个主文件    和 TypeScript 声明文件   ，你可以按照以下步骤进行发布：确保项目构建成功：    登录 npm 账号：    发布包：    验证发布：  访问    确认包已经发布成功。通过以上步骤，你可以成功地发布你的 TypeScript 项目，并包含 TypeScript 声明文件以供其他开发者使用和引用。","level":3},{"id":"/notes/ts/declaration-files/publishing#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html","level":3},{"id":"/notes/ts/declaration-files/consumption#使用","title":"使用","titles":[],"content":"在TypeScript 2.0，获取、使用和查找声明文件变得十分容易。 这篇文章将详细说明怎么做这三件事。","level":1},{"id":"/notes/ts/declaration-files/consumption#下载","title":"下载","titles":[],"content":"在TypeScript 2.0以上的版本，获取类型声明文件只需要使用npm。比如，获取lodash库的声明文件，只需使用下面的命令：如果一个npm包像  发布 里所讲的一样已经包含了它的声明文件，那就不必再去下载相应的  包了。","level":1},{"id":"/notes/ts/declaration-files/consumption#使用-1","title":"使用","titles":[],"content":"下载完后，就可以直接在TypeScript里使用lodash了。 不论是在模块里还是全局代码里使用。比如，你已经  安装了类型声明，你可以使用导入：或者如果你没有使用模块，那么你只需使用全局的变量  。","level":1},{"id":"/notes/ts/declaration-files/consumption#查找","title":"查找","titles":[],"content":"大多数情况下，类型声明包的名字总是与它们在  上的包的名字相同，但是有  前缀， 但如果你需要的话，你可以在   https://aka.ms/types 这里查找你喜欢的库。注意：如果你要找的声明文件不存在，你可以贡献一份，这样就方便了下一位要使用它的人。 查看DefinitelyTyped 贡献指南页了解详情。","level":1},{"id":"/notes/ts/declaration-files/consumption#参考","title":"参考","titles":["查找"],"content":"https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html","level":3},{"id":"/notes/ts/object/guide#总览","title":"总览","titles":[],"content":"在 TypeScript 中，   是 JavaScript 中的基本对象类型，包含多种方法来操作和处理对象。以下是    的常用方法及其描述：","level":2},{"id":"/notes/ts/object/guide#object-类的静态方法","title":"Object  类的静态方法","titles":["总览"],"content":"：   用于将一个或多个源对象的所有可枚举属性复制到目标对象中，返回目标对象。       ：   使用指定的原型对象和可选的属性描述符创建一个新对象。       ：   直接在对象上定义一个新属性，或者修改对象的现有属性，并返回该对象。       ：   直接在对象上定义一个或多个新的属性或修改现有属性，返回该对象。       ：   返回一个给定对象自身可枚举属性的键值对数组，其排列顺序与使用    循环遍历该对象时返回的顺序一致。       ：   冻结一个对象，冻结后不能向该对象添加新属性，不能删除已有属性，不能修改已有属性的可枚举性、可配置性、可写性以及属性值。       ：   返回对象上一个自有属性对应的属性描述符（如果存在），否则返回   。       ：   返回一个对象的所有自身属性的描述符。       ：   返回一个包含对象自身所有属性（包括不可枚举属性但不包括    属性）的数组。       ：   返回一个数组，包含对象自身所有的    属性键。       ：   返回指定对象的原型（即，内部 [[Prototype]] 属性的值）。       ：   判断两个值是否是相同的值。所有    值都相同（即    返回   ），但正零和负零不相同。       ：   判断对象是否是可扩展的（即，可以添加新的属性）。       ：   判断对象是否被冻结。       ：   判断对象是否被密封。       ：   返回一个包含对象自身所有可枚举属性名称的数组。       ：   防止对象的扩展。将对象设置为不可扩展（即，不能添加新的属性）。       ：   密封一个对象，防止添加新属性并将所有现有属性标记为不可配置。现有属性的值仍然可以改变。       ：   设置对象的原型（即，内部 [[Prototype]] 属性的值），返回指定对象。       ：   返回一个包含对象自身所有可枚举属性值的数组。这些方法可以帮助你在 TypeScript 中有效地处理和操作对象。通过理解和利用这些方法，你可以编写更健壮和灵活的代码。","level":3},{"id":"/notes/ts/object/assign#objectassign","title":"Object.assign","titles":[],"content":"是一个常用的 JavaScript 方法，它可以将一个或多个源对象的所有可枚举属性复制到目标对象中，并返回目标对象。TypeScript 完全支持    方法，并且可以提供类型检查。","level":1},{"id":"/notes/ts/object/assign#基本用法","title":"基本用法","titles":["Object.assign"],"content":"：目标对象。    ：一个或多个源对象。","level":3},{"id":"/notes/ts/object/assign#示例","title":"示例","titles":["Object.assign"],"content":"","level":3},{"id":"/notes/ts/object/assign#基本示例","title":"基本示例","titles":["Object.assign","示例"],"content":"将一个源对象的属性复制到目标对象：","level":4},{"id":"/notes/ts/object/assign#合并多个源对象","title":"合并多个源对象","titles":["Object.assign","示例"],"content":"","level":4},{"id":"/notes/ts/object/assign#克隆对象","title":"克隆对象","titles":["Object.assign","示例"],"content":"创建对象的浅拷贝：","level":4},{"id":"/notes/ts/object/assign#处理嵌套对象","title":"处理嵌套对象","titles":["Object.assign","示例"],"content":"注意：   只进行浅拷贝，不会深度合并嵌套对象。","level":4},{"id":"/notes/ts/object/assign#注意事项","title":"注意事项","titles":["Object.assign","示例"],"content":"浅拷贝 ：   执行的是浅拷贝，如果源对象的某个属性是对象，则只会复制对象的引用。     目标对象的修改 ：   会改变目标对象本身，如果不想修改目标对象，可以传入一个空对象作为目标对象。     处理原型链上的属性 ：   只会复制源对象自身的可枚举属性，不会复制继承的属性。     处理不可枚举属性 ：   不会复制不可枚举的属性。     处理 Symbol 属性 ：   会复制    类型的属性。","level":3},{"id":"/notes/ts/object/assign#总结","title":"总结","titles":["Object.assign","示例"],"content":"是一个强大的工具，用于对象的合并和克隆。了解其浅拷贝的特性以及对原型链和不可枚举属性的处理方式，可以帮助你在使用    时避免一些常见的陷阱。通过合理使用   ，可以在 TypeScript 中编写更简洁和高效的代码。","level":3},{"id":"/notes/ts/object/create#objectcreate","title":"Object.create","titles":[],"content":"是一个 JavaScript 方法，用于创建一个新对象，并将其原型设置为指定的对象。在 TypeScript 中，这个方法同样适用。下面是    的用法、示例、常见问题和注意事项。","level":2},{"id":"/notes/ts/object/create#基本用法","title":"基本用法","titles":["Object.create"],"content":"：新创建对象的原型对象。    （可选）：一个对象，其属性将作为新对象的自有属性。这些属性的属性描述符格式与    中的相同。","level":3},{"id":"/notes/ts/object/create#示例","title":"示例","titles":["Object.create"],"content":"","level":3},{"id":"/notes/ts/object/create#创建一个具有指定原型的新对象","title":"创建一个具有指定原型的新对象","titles":["Object.create","示例"],"content":"","level":4},{"id":"/notes/ts/object/create#使用属性描述符创建对象","title":"使用属性描述符创建对象","titles":["Object.create","示例"],"content":"","level":4},{"id":"/notes/ts/object/create#常见问题","title":"常见问题","titles":["Object.create","示例"],"content":"","level":3},{"id":"/notes/ts/object/create#_1-objectcreate-与-new-的区别","title":"1.    Object.create  与   new  的区别","titles":["Object.create","示例","常见问题"],"content":"直接创建一个新对象并设置其原型，而    关键字则用于创建一个构造函数的实例。前者更灵活，后者适合使用构造函数模式。","level":4},{"id":"/notes/ts/object/create#_2-继承多个对象","title":"2.   继承多个对象","titles":["Object.create","示例","常见问题"],"content":"只能设置一个对象作为新对象的原型，因此不能直接实现多重继承。要实现多重继承，需要结合    或其他方法手动混合多个对象的属性。","level":4},{"id":"/notes/ts/object/create#注意事项","title":"注意事项","titles":["Object.create","示例"],"content":"浅拷贝创建的新对象与原型对象之间是浅拷贝关系。如果原型对象的属性是引用类型，修改新对象上的该属性会影响原型对象。属性描述符在    中定义的属性是非继承的自有属性，可以通过属性描述符进行详细配置。注意如果属性描述符未设置   、   和   ，它们的默认值为   。原型链通过    创建的对象，其原型链与    指定的对象一致。可以通过    方法验证。","level":3},{"id":"/notes/ts/object/create#总结","title":"总结","titles":["Object.create","示例"],"content":"是一个强大的工具，允许你创建具有特定原型和属性的新对象。通过理解其用法和特性，可以在 TypeScript 中更灵活地进行面向对象编程。然而，要注意浅拷贝特性和属性描述符的配置，以避免潜在的问题。","level":3},{"id":"/notes/ts/project-configuration/tsconfig-json#tsconfigjson","title":"tsconfig.json","titles":[],"content":"","level":1},{"id":"/notes/ts/project-configuration/tsconfig-json#概述","title":"概述","titles":["tsconfig.json"],"content":"如果一个目录下存在一个  文件，那么它意味着这个目录是 TypeScript 项目的根目录。   文件中指定了用来编译这个项目的根文件和编译选项。 一个项目可以通过以下方式之一来编译：","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#使用-tsconfigjson","title":"使用 tsconfig.json","titles":["tsconfig.json"],"content":"不带任何输入文件的情况下调用  ，编译器会从当前目录开始去查找  文件，逐级向上搜索父目录。  不带任何输入文件的情况下调用  ，且使用命令行参数  （或  ）指定一个包含  文件的目录。当命令行上指定了输入文件时，  文件会被忽略。","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#示例","title":"示例","titles":["tsconfig.json"],"content":"示例文件:使用  属性    使用  和  属性","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#细节","title":"细节","titles":["tsconfig.json"],"content":"可以被忽略，这时编译器会使用默认值。在这里查看完整的  编译器选项 列表。指定一个包含相对或绝对文件路径的列表。   和  属性指定一个文件 glob 匹配模式列表。 支持的 glob 通配符有：匹配 0 或多个字符（不包括目录分隔符）    匹配一个任意字符（不包括目录分隔符）    递归匹配任意子目录如果一个 glob 模式里的某部分只包含  或  ，那么仅有支持的文件扩展名类型被包含在内（比如默认  ，  ，和  ， 如果   设置能  还包含  和  ）。如果  和  都没有被指定，编译器默认包含当前目录和子目录下所有的 TypeScript 文件（  ,    和   ），排除在  里指定的文件。JS 文件（  和  ）也被包含进来如果  被设置成  。 如果指定了   或  ，编译器会将它们结合一并包含进来。 使用   指定的目录下的文件永远会被编译器排除，除非你明确地使用  将其包含进来（这时就算用  指定也没用）。使用  引入的文件可以使用  属性过滤。 然而，通过   属性明确指定的文件却总是会被包含在内，不管  如何设置。 如果没有特殊指定，   默认情况下会排除  ，  ，  和  目录。任何被  或  指定的文件所引用的文件也会被包含进来。   引用了  ，因此  不能被排除，除非引用它的  在  列表中。需要注意编译器不会去引入那些可能做为输出的文件；比如，假设我们包含了  ，那么  和  会被排除在外。 通常来讲，不推荐只有扩展名的不同来区分同目录下的文件。文件可以是个空文件，那么所有默认的文件（如上面所述）都会以默认配置选项编译。在命令行上指定的编译选项会覆盖在  文件里的相应选项。","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#typestyperoots和types","title":"@types ，  typeRoots 和  types","titles":["tsconfig.json"],"content":"默认所有  可见的 \"  \"包会在编译过程中被包含进来。   文件夹下以及它们子文件夹下的所有包都是  可见的 ； 也就是说，   ，  和  等等。如果指定了  ，  只有  下面的包才会被包含进来。 比如：这个配置文件会包含  所有  下面的包，而不包含  里面的包。如果指定了  ，只有被列出来的包才会被包含进来。 比如：这个  文件将  仅会 包含   ，  和  。/@types/。   里面的其它包不会被引入进来。指定  来禁用自动引入  包。注意，自动引入只在你使用了全局的声明（相反于模块）时是重要的。 如果你使用   语句，TypeScript 仍然会查找  和  文件夹来获取  包。","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#使用extends继承配置","title":"使用  extends 继承配置","titles":["tsconfig.json"],"content":"文件可以利用  属性从另一个配置文件里继承配置。是  文件里的顶级属性（与  ，  ，  ，和  一样）。   的值是一个字符串，包含指向另一个要继承文件的路径。在原文件里的配置先被加载，然后被来至继承文件里的配置重写。 如果发现循环引用，则会报错。来至所继承配置文件的  ，  和   覆盖 源配置文件的属性。配置文件里的相对路径在解析时相对于它所在的文件。比如：：：：","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#compileonsave","title":"compileOnSave","titles":["tsconfig.json"],"content":"在最顶层设置  标记，可以让 IDE 在保存文件的时候根据  重新生成文件。要想支持这个特性需要 Visual Studio 2015， TypeScript1.8.4 以上并且安装  atom-typescript 插件。","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#模式","title":"模式","titles":["tsconfig.json"],"content":"到这里查看模式:   http://json.schemastore.org/tsconfig  .","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#参考","title":"参考","titles":["tsconfig.json","模式"],"content":"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#handbook-content","level":3},{"id":"/notes/ts/project-configuration/compiler-options-in-msbuild#typescript-编译器选项","title":"TypeScript 编译器选项","titles":[],"content":"TypeScript 的编译器选项可以通过配置文件（通常是   ）或者在 MSBuild 项目文件中直接指定。以下是一些常见的 TypeScript 编译器选项，它们可以通过 MSBuild 配置来控制：OutDir  设置输出目录，指定编译后 JavaScript 文件的输出位置。     SourceMap  是否生成 source map 文件，用于在调试时将编译后的 JavaScript 代码映射回 TypeScript 源代码。     ModuleResolution  指定模块解析策略，可以是   （Node.js 模块解析策略）或   （经典模块解析策略）。     Target  指定 ECMAScript 目标版本，例如 ES5、ES6 等。     NoEmitOnError  如果有 TypeScript 编译错误，是否终止生成 JavaScript 文件。     AllowJs  是否允许编译器编译    文件。","level":3},{"id":"/notes/ts/project-configuration/compiler-options-in-msbuild#在-msbuild-项目中配置-typescript-编译器选项","title":"在 MSBuild 项目中配置 TypeScript 编译器选项","titles":[],"content":"在 MSBuild 项目文件（例如    文件）中，可以通过    和    元素来配置 TypeScript 编译器选项。以下是一个示例：在这个例子中：指定了编译后 JavaScript 文件的输出目录。    设置为   ，生成对应的 source map 文件。    设置为   ，使用 Node.js 模块解析策略。    指定了编译的目标 ECMAScript 版本为 ES5。    设置为   ，在 TypeScript 编译错误时停止生成 JavaScript 文件。    设置为   ，允许编译器编译    文件。通过在 MSBuild 项目文件中配置这些选项，可以有效地控制 TypeScript 的编译行为，以适应项目的需求和环境。","level":3},{"id":"/notes/ts/project-configuration/compiler-options-in-msbuild#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html#handbook-content","level":3},{"id":"/notes/ts/project-configuration/compiler-options#常见的-tsc-cli-options","title":"常见的 tsc CLI Options","titles":[],"content":"--help  显示 tsc 命令行帮助信息，列出所有可用的命令行选项。     --version  显示 TypeScript 编译器的版本信息。     --target  指定编译后的 ECMAScript 目标版本。可选值包括   ,   ,   ,   ,   ,   ,   ,   ,    等。     --module  指定生成的模块系统。可选值包括   ,   ,   ,   ,   ,   ,    等。     --outDir  指定输出目录，用来存放编译后的 JavaScript 文件。     --sourceMap  是否生成 source map 文件，用于在调试时将编译后的 JavaScript 代码映射回 TypeScript 源代码。     --strict  开启所有严格类型检查选项。相当于同时启用   ,   ,   ,   ,   ,   ,   。     --noEmit  不生成任何输出文件，只进行类型检查。     --watch  监视文件变化并重新编译。在开发过程中常用来实时监控文件变化并自动重新编译。     --esModuleInterop  允许在导入默认导出时使用 CommonJS 的    语法。     --declaration  是否生成    声明文件。     --allowJs  允许编译器编译    文件。","level":3},{"id":"/notes/ts/project-configuration/compiler-options#示例","title":"示例","titles":[],"content":"假设我们有一个 TypeScript 项目，项目文件结构如下：文件内容如下：我们可以使用 tsc 命令行工具来编译这个 TypeScript 文件：这个命令将会把    编译成    和    文件，使用    目标版本，   模块系统，并生成 source map 文件以便在调试时进行源代码映射。","level":3},{"id":"/notes/ts/project-configuration/compiler-options#总结","title":"总结","titles":[],"content":"tsc 命令行工具提供了丰富的选项来控制 TypeScript 的编译行为，可以根据项目需求和特定的环境配置相应的选项。这些选项可以通过直接在命令行中指定，也可以在项目的    文件中进行配置，以达到灵活和高效地管理 TypeScript 项目的目的。","level":3},{"id":"/notes/ts/project-configuration/compiler-options#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/compiler-options.html","level":3},{"id":"/notes/ts/project-configuration/project-references#项目引用-project-references","title":"项目引用 Project References","titles":[],"content":"TypeScript 的项目引用（Project References）是一个强大的功能，允许一个 TypeScript 项目引用另一个 TypeScript 项目。这个功能非常适用于大型代码库和单体仓库（monorepos），它使得项目之间的依赖关系更明确，并且可以显著加快编译速度。","level":2},{"id":"/notes/ts/project-configuration/project-references#项目引用的核心概念","title":"项目引用的核心概念","titles":["项目引用 Project References"],"content":"项目引用通过允许一个项目依赖于另一个项目，使得 TypeScript 编译器可以在编译时确保所有引用的项目都被正确编译。这不仅提高了编译效率，还改善了项目间的类型检查和代码导航。","level":3},{"id":"/notes/ts/project-configuration/project-references#配置项目引用","title":"配置项目引用","titles":["项目引用 Project References"],"content":"要使用项目引用，需要对 TypeScript 项目进行一些配置，主要包括    文件的设置。","level":3},{"id":"/notes/ts/project-configuration/project-references#步骤-1-创建多个项目","title":"步骤 1: 创建多个项目","titles":["项目引用 Project References","配置项目引用"],"content":"假设我们有两个项目，   和   。   项目依赖于    项目。","level":4},{"id":"/notes/ts/project-configuration/project-references#步骤-2-配置-core-项目的-tsconfigjson","title":"步骤 2: 配置   core  项目的   tsconfig.json","titles":["项目引用 Project References","配置项目引用"],"content":"首先，我们需要配置    项目的   ：选项必须启用，它表示这是一个可以被引用的 TypeScript 项目。","level":4},{"id":"/notes/ts/project-configuration/project-references#步骤-3-配置-app-项目的-tsconfigjson","title":"步骤 3: 配置   app  项目的   tsconfig.json","titles":["项目引用 Project References","配置项目引用"],"content":"接下来，我们需要配置    项目的   ，并引用    项目：字段指定了    项目引用了    项目。","level":4},{"id":"/notes/ts/project-configuration/project-references#步骤-4-配置顶层-tsconfigjson","title":"步骤 4: 配置顶层   tsconfig.json","titles":["项目引用 Project References","配置项目引用"],"content":"在顶层目录创建一个    文件，以便可以一次性编译整个项目结构：","level":4},{"id":"/notes/ts/project-configuration/project-references#构建项目","title":"构建项目","titles":["项目引用 Project References","配置项目引用"],"content":"通过在顶层目录运行    命令，可以一次性编译所有的子项目：这个命令会按照项目之间的依赖关系顺序编译所有的项目，并生成相应的输出文件。","level":3},{"id":"/notes/ts/project-configuration/project-references#项目引用的优势","title":"项目引用的优势","titles":["项目引用 Project References","配置项目引用"],"content":"加快增量编译 ：由于每个项目可以单独编译，并且编译结果可以被缓存，所以在修改一个项目时，只需要重新编译受影响的项目，从而加快编译速度。   更好的模块化 ：项目引用使得项目之间的依赖关系更加明确，有助于模块化管理代码。   改进的类型检查和代码导航 ：TypeScript 编译器可以跨项目进行类型检查，确保类型安全，并且开发工具（如 VS Code）可以提供更好的代码导航支持。","level":3},{"id":"/notes/ts/project-configuration/project-references#总结","title":"总结","titles":["项目引用 Project References","配置项目引用"],"content":"TypeScript 的项目引用是一个非常实用的功能，特别适用于大型项目和单体仓库。通过配置项目引用，可以提高编译速度，改进代码模块化管理，并且增强类型检查和代码导航能力。使用项目引用可以使得 TypeScript 项目之间的依赖关系更加清晰和高效，从而更好地管理和维护大型代码库。","level":3},{"id":"/notes/ts/project-configuration/project-references#参考","title":"参考","titles":["项目引用 Project References","配置项目引用"],"content":"https://www.typescriptlang.org/docs/handbook/project-references.html","level":3},{"id":"/notes/ts/project-configuration/integrating-with-build-tools#与构建工具集成-integrating-with-build-tools","title":"与构建工具集成 Integrating with Build Tools","titles":[],"content":"在现代前端开发中，使用构建工具来管理和自动化构建流程已经成为一种常见的做法。TypeScript 提供了良好的工具链支持，可以无缝集成到各种构建工具中，例如 Gulp、Grunt、Webpack 等。以下是如何将 TypeScript 集成到这些构建工具中的详细介绍。","level":2},{"id":"/notes/ts/project-configuration/integrating-with-build-tools#使用-gulp-集成-typescript","title":"使用 Gulp 集成 TypeScript","titles":["与构建工具集成 Integrating with Build Tools"],"content":"Gulp 是一个流行的基于流的构建工具，适合用来自动化前端开发任务。以下是使用 Gulp 集成 TypeScript 的步骤：安装必要的依赖包 ：     创建   ：     配置   ：     运行 Gulp 任务 ：","level":3},{"id":"/notes/ts/project-configuration/integrating-with-build-tools#使用-grunt-集成-typescript","title":"使用 Grunt 集成 TypeScript","titles":["与构建工具集成 Integrating with Build Tools"],"content":"Grunt 是一个基于任务的构建工具，非常适合用于构建、验证和运行项目中的重复性任务。以下是使用 Grunt 集成 TypeScript 的步骤：安装必要的依赖包 ：     创建   ：     配置   ：     运行 Grunt 任务 ：","level":3},{"id":"/notes/ts/project-configuration/integrating-with-build-tools#使用-webpack-集成-typescript","title":"使用 Webpack 集成 TypeScript","titles":["与构建工具集成 Integrating with Build Tools"],"content":"Webpack 是一个模块打包工具，适用于现代 JavaScript 应用。以下是使用 Webpack 集成 TypeScript 的步骤：安装必要的依赖包 ：     创建   ：     配置   ：     运行 Webpack 构建 ：","level":3},{"id":"/notes/ts/project-configuration/integrating-with-build-tools#使用-npm-scripts-集成-typescript","title":"使用 npm Scripts 集成 TypeScript","titles":["与构建工具集成 Integrating with Build Tools"],"content":"对于一些简单的项目，使用 npm 脚本来构建 TypeScript 也是一个不错的选择。以下是如何配置 npm 脚本来编译 TypeScript：安装 TypeScript ：     配置   ：     更新    文件添加编译脚本：     运行 npm 脚本 ：","level":3},{"id":"/notes/ts/project-configuration/integrating-with-build-tools#总结","title":"总结","titles":["与构建工具集成 Integrating with Build Tools"],"content":"将 TypeScript 集成到各种构建工具中可以提高开发效率，自动化构建流程。无论是 Gulp、Grunt、Webpack 还是 npm Scripts，TypeScript 都能很好地融入其中，根据项目需求选择合适的构建工具进行集成，是管理项目构建的最佳实践之一。","level":3},{"id":"/notes/ts/project-configuration/integrating-with-build-tools#参考","title":"参考","titles":["与构建工具集成 Integrating with Build Tools"],"content":"https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#配置监视-configuring-watch","title":"配置监视 Configuring Watch","titles":[],"content":"在 TypeScript 中，   选项允许编译器监视文件变化，并在文件修改时自动重新编译。这对于开发者来说是一个非常有用的功能，可以提高开发效率，减少手动编译的次数。除了基本的    选项，TypeScript 提供了许多配置选项来定制监视行为。","level":2},{"id":"/notes/ts/project-configuration/configuring-watch#基本使用","title":"基本使用","titles":["配置监视 Configuring Watch"],"content":"要使用 TypeScript 的    模式，只需要在命令行中添加    选项。例如：这会让 TypeScript 编译器监视当前目录及其子目录中的所有 TypeScript 文件，当这些文件发生变化时，编译器会自动重新编译。","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#配置-tsconfigjson","title":"配置 tsconfig.json","titles":["配置监视 Configuring Watch"],"content":"为了更方便地使用    选项，可以在    文件中配置监视模式。这允许你更灵活地控制监视行为。","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#基本-tsconfigjson-配置","title":"基本 tsconfig.json 配置","titles":["配置监视 Configuring Watch","配置 tsconfig.json"],"content":"创建一个基本的    文件：然后在命令行中运行：这会让 TypeScript 监视    目录中的所有    文件，并将编译后的输出放到    目录中。","level":4},{"id":"/notes/ts/project-configuration/configuring-watch#监视模式配置选项","title":"监视模式配置选项","titles":["配置监视 Configuring Watch","配置 tsconfig.json"],"content":"TypeScript 提供了几个配置选项，可以在    中设置，以更好地控制监视模式。","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#watchoptions","title":"watchOptions","titles":["配置监视 Configuring Watch","配置 tsconfig.json","监视模式配置选项"],"content":"在    文件中，你可以使用    来配置监视模式的行为：以下是    中的一些常用选项：excludeDirectories : 排除特定的目录，不监视这些目录中的文件。   excludeFiles : 排除特定的文件，不监视这些文件。   watchFile : 设置文件监视策略。可选值有：\n    : 固定的轮询间隔。   : 优先级轮询间隔。   : 动态优先级轮询。   : 使用文件系统事件（推荐）。   watchDirectory : 设置目录监视策略。可选值有：\n    : 使用文件系统事件（推荐）。   : 固定的轮询间隔。   : 动态优先级轮询。   fallbackPolling : 设置回退的轮询策略，当文件系统事件不可用时使用。可选值有：\n    : 固定的轮询间隔。   : 优先级轮询。   : 动态优先级轮询。","level":4},{"id":"/notes/ts/project-configuration/configuring-watch#使用-tsc-watch","title":"使用 tsc-watch","titles":["配置监视 Configuring Watch","配置 tsconfig.json"],"content":"是一个第三方工具，提供了更高级的监视功能，例如在文件变化时自动运行自定义脚本。安装 tsc-watch ：     配置 package.json ：  在    中添加脚本来使用   ：     运行监视脚本 ：这样，当 TypeScript 文件编译成功时，会自动运行    脚本。","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#示例配置监视模式的项目","title":"示例：配置监视模式的项目","titles":["配置监视 Configuring Watch","配置 tsconfig.json"],"content":"假设我们有以下项目结构：文件内容：文件内容：","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#运行监视模式","title":"运行监视模式","titles":["配置监视 Configuring Watch","配置 tsconfig.json"],"content":"使用 TypeScript 内置的    模式：    使用    提供的高级监视功能：","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#总结","title":"总结","titles":["配置监视 Configuring Watch","配置 tsconfig.json"],"content":"TypeScript 的监视模式是开发过程中提高效率的有力工具。通过配置    中的   ，可以定制监视行为以适应不同的开发需求。对于更高级的使用场景，可以借助    等第三方工具，实现文件变化时自动运行自定义脚本的功能。","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#参考","title":"参考","titles":["配置监视 Configuring Watch","配置 tsconfig.json"],"content":"https://www.typescriptlang.org/docs/handbook/configuring-watch.html","level":3},{"id":"/notes/ts/project-configuration/nightly-builds#每日构建","title":"每日构建","titles":[],"content":"TypeScript Nightly Builds 是 TypeScript 编译器和语言服务的最新、最前沿的版本，通常每天发布一次。这些构建包含了最新的功能、修复和改进，使开发者可以尽早测试和使用新功能。然而，这些版本也可能包含未经过全面测试的代码，因此可能不如正式发布版稳定。","level":2},{"id":"/notes/ts/project-configuration/nightly-builds#安装-typescript-nightly-builds","title":"安装 TypeScript Nightly Builds","titles":["每日构建"],"content":"要安装 TypeScript 的 Nightly 版本，可以使用 npm 包管理器。命令如下：这将全局安装最新的 Nightly 版本，并将    命令指向该版本。如果只想在某个项目中使用 Nightly 版本，可以运行：","level":3},{"id":"/notes/ts/project-configuration/nightly-builds#使用-typescript-nightly-builds","title":"使用 TypeScript Nightly Builds","titles":["每日构建"],"content":"使用 Nightly 版本与使用正式版本的 TypeScript 没有区别。你仍然可以通过    命令编译 TypeScript 文件，并通过    文件配置编译选项。","level":3},{"id":"/notes/ts/project-configuration/nightly-builds#查看-typescript-版本","title":"查看 TypeScript 版本","titles":["每日构建","使用 TypeScript Nightly Builds"],"content":"要确认安装的 TypeScript 版本，可以运行以下命令：输出将类似于：这里的版本号表示这是一个 2022 年 2 月 14 日的 Nightly 构建版本。","level":4},{"id":"/notes/ts/project-configuration/nightly-builds#优点和风险","title":"优点和风险","titles":["每日构建","使用 TypeScript Nightly Builds"],"content":"","level":3},{"id":"/notes/ts/project-configuration/nightly-builds#优点","title":"优点","titles":["每日构建","使用 TypeScript Nightly Builds","优点和风险"],"content":"新功能 ：能够率先体验和使用 TypeScript 最新的语言特性和改进。   早期反馈 ：通过使用 Nightly 版本，开发者可以向 TypeScript 团队提供早期反馈，帮助发现和修复问题。   社区参与 ：积极参与 TypeScript 社区，贡献自己的意见和经验。","level":4},{"id":"/notes/ts/project-configuration/nightly-builds#风险","title":"风险","titles":["每日构建","使用 TypeScript Nightly Builds","优点和风险"],"content":"不稳定 ：Nightly 版本可能包含未经全面测试的功能和改动，可能会导致编译错误或运行时错误。   频繁更新 ：每天一个新版本，可能需要频繁更新项目中的 TypeScript 依赖。   向后兼容性问题 ：某些新功能或改动可能不向后兼容，可能会破坏现有代码。","level":4},{"id":"/notes/ts/project-configuration/nightly-builds#如何报告问题","title":"如何报告问题","titles":["每日构建","使用 TypeScript Nightly Builds"],"content":"如果在使用 Nightly 版本时遇到问题，可以通过 TypeScript 的 GitHub 仓库报告问题。具体步骤如下：前往   TypeScript 的 GitHub 仓库 。  点击 \"Issues\" 标签。  点击 \"New issue\" 按钮。  填写问题的详细信息，包括重现步骤、预期行为和实际行为。  提交问题。","level":3},{"id":"/notes/ts/project-configuration/nightly-builds#示例使用-nightly-版本的新功能","title":"示例：使用 Nightly 版本的新功能","titles":["每日构建","使用 TypeScript Nightly Builds"],"content":"假设 Nightly 版本引入了一个新的类型运算符   。我们可以创建一个    文件来启用 Nightly 版本特有的配置，并编写一些使用新功能的代码。","level":3},{"id":"/notes/ts/project-configuration/nightly-builds#tsconfigjson","title":"tsconfig.json","titles":["每日构建","使用 TypeScript Nightly Builds","示例：使用 Nightly 版本的新功能"],"content":"","level":4},{"id":"/notes/ts/project-configuration/nightly-builds#示例代码","title":"示例代码","titles":["每日构建","使用 TypeScript Nightly Builds","示例：使用 Nightly 版本的新功能"],"content":"通过运行    命令编译这些代码，如果编译器正常工作且支持新的    运算符，则表示 Nightly 版本正常。","level":4},{"id":"/notes/ts/project-configuration/nightly-builds#总结","title":"总结","titles":["每日构建","使用 TypeScript Nightly Builds"],"content":"TypeScript Nightly Builds 是开发者可以提前体验和测试 TypeScript 最新功能的重要工具。通过安装和使用这些版本，开发者不仅可以获得最新的功能和改进，还可以向 TypeScript 团队提供早期反馈，帮助改进 TypeScript。不过，由于这些版本可能不够稳定，因此在生产环境中使用时需要谨慎。","level":3},{"id":"/notes/ts/project-configuration/nightly-builds#参考","title":"参考","titles":["每日构建","使用 TypeScript Nightly Builds"],"content":"https://www.typescriptlang.org/docs/handbook/nightly-builds.html","level":3},{"id":"/notes/vue/vue-slot#vue3-获取插槽内容-slot","title":"vue3 获取插槽内容 slot","titles":[],"content":"useSlots()的用法, renderSlotContent","level":1},{"id":"/posts/regex#正则表达式手册regex","title":"正则表达式手册(Regex)","titles":[],"content":"正则表达式（Regular Expressions,简称 Regex）是一种用于匹配字符串的模式。它在文本处理、数据验证和提取等方面非常强大和灵活。以下是详细的 Regex 语法手册,并附有示例说明。","level":1},{"id":"/posts/regex#基本字符匹配","title":"基本字符匹配","titles":["正则表达式手册(Regex)"],"content":"字符 ：直接匹配字符本身。例如：\n     匹配字符串 \"a\"。    匹配字符串 \"abc\"。","level":3},{"id":"/posts/regex#元字符","title":"元字符","titles":["正则表达式手册(Regex)"],"content":"：匹配除换行符以外的任意单个字符。     匹配 \"aab\", \"acb\" 等。    ：转义字符,用于转义元字符,使其失去特殊意义。     匹配 \"a.b\"。","level":3},{"id":"/posts/regex#字符类","title":"字符类","titles":["正则表达式手册(Regex)"],"content":"：匹配方括号内的任意一个字符。     匹配 \"a\", \"b\", \"c\" 中的任意一个。    ：匹配不在方括号内的任意一个字符。     匹配除 \"a\", \"b\", \"c\" 以外的任意一个字符。   范围 ：在方括号内使用    指定字符范围。     匹配小写字母。    匹配数字。","level":3},{"id":"/posts/regex#预定义字符类","title":"预定义字符类","titles":["正则表达式手册(Regex)"],"content":"：匹配任何数字,相当于   。     匹配任何三位数字,如 \"123\"。    ：匹配任何非数字字符,相当于   。     匹配 \"a\", \"-\" 等非数字字符。    ：匹配任何字母、数字或下划线,相当于   。     匹配一个或多个字母、数字或下划线。    ：匹配任何非字母、数字或下划线字符,相当于   。     匹配 \"!\", \"@\" 等特殊字符。    ：匹配任何空白字符（包括空格、制表符、换行符等）。     匹配 \" \", \"\\t\" 等。    ：匹配任何非空白字符,相当于   。     匹配 \"a\", \"1\" 等非空白字符。","level":3},{"id":"/posts/regex#数量词","title":"数量词","titles":["正则表达式手册(Regex)"],"content":"：匹配前面的字符零次或多次。     匹配 \"\", \"a\", \"aa\" 等。    ：匹配前面的字符一次或多次。     匹配 \"a\", \"aa\" 等。    ：匹配前面的字符零次或一次。     匹配 \"\", \"a\"。    ：匹配前面的字符恰好 n 次。     匹配 \"aaa\"。    ：匹配前面的字符至少 n 次。     匹配 \"aa\", \"aaa\" 等。    ：匹配前面的字符至少 n 次,但不超过 m 次。     匹配 \"aa\", \"aaa\", \"aaaa\"。","level":3},{"id":"/posts/regex#边界匹配","title":"边界匹配","titles":["正则表达式手册(Regex)"],"content":"：匹配字符串的开始。     匹配以 \"abc\" 开头的字符串。    ：匹配字符串的结束。     匹配以 \"abc\" 结尾的字符串。    ：匹配单词边界。     匹配单词 \"word\"。    ：匹配非单词边界。     匹配 \"password\" 中的 \"word\"。","level":3},{"id":"/posts/regex#分组和引用","title":"分组和引用","titles":["正则表达式手册(Regex)"],"content":"：分组,用于提取子字符串或应用数量词。     匹配 \"abc\", \"abcabc\"。    ,   , ... ：反向引用,用于匹配之前的捕获组。     匹配 \"abab\"。","level":3},{"id":"/posts/regex#或匹配","title":"或匹配","titles":["正则表达式手册(Regex)"],"content":"：匹配左边或右边的字符。\n     匹配 \"a\" 或 \"b\"。","level":3},{"id":"/posts/regex#零宽断言","title":"零宽断言","titles":["正则表达式手册(Regex)"],"content":"：正向前瞻断言,要求接下来的字符与 ... 匹配,但不消耗这些字符。     匹配 \"a\" 仅当其后跟着 \"b\"。    ：负向前瞻断言,要求接下来的字符不与 ... 匹配。     匹配 \"a\" 仅当其后不跟着 \"b\"。    ：正向后瞻断言,要求前面的字符与 ... 匹配,但不消耗这些字符。     匹配 \"b\" 仅当其前面是 \"a\"。    ：负向后瞻断言,要求前面的字符不与 ... 匹配。     匹配 \"b\" 仅当其前面不是 \"a\"。","level":3},{"id":"/posts/regex#贪婪与懒惰匹配","title":"贪婪与懒惰匹配","titles":["正则表达式手册(Regex)"],"content":"贪婪匹配 ：尽可能多地匹配字符,默认行为。     匹配 \"a\" 开头和 \"b\" 结尾的最长字符串。   懒惰匹配 ：尽可能少地匹配字符,在量词后加    实现。     匹配 \"a\" 开头和 \"b\" 结尾的最短字符串。","level":3},{"id":"/posts/regex#示例汇总","title":"示例汇总","titles":["正则表达式手册(Regex)"],"content":"匹配邮箱地址 ：     解释：匹配类似 \"  example@example.com \" 的邮箱地址。   匹配电话号码 ：     解释：匹配类似 \"123-456-7890\" 的电话号码。   匹配日期（YYYY-MM-DD） ：     解释：匹配类似 \"2024-06-17\" 的日期格式。","level":3},{"id":"/projects/chatmaxim-electron-vite#chatmaxim-桌面端","title":"ChatMaxim 桌面端","titles":[],"content":"","level":1},{"id":"/projects/chatmaxim-electron-vite#我是-h2-标题","title":"我是 H2 标题","titles":["ChatMaxim 桌面端"],"content":"资料整理中...","level":2},{"id":"/projects/chatmaxim-electron-vite#先在-github-上看看","title":"先在 Github 上看看","titles":["ChatMaxim 桌面端","我是 H2 标题"],"content":"https://github.com/iczp","level":3},{"id":"/projects/chatmaxim-flutter#chatmaxim-移动端flutter","title":"ChatMaxim 移动端(Flutter)","titles":[],"content":"VVLL.net（Vite Vue Link Lab）是一个网站，主要提供关于Vite、Vue和相关开发文档的资源和信息。以下是该网站的主要内容和特点：Vite ：网站涵盖了关于Vite的开发文档和指南，介绍了Vite作为一个现代化的构建工具的特性和用法，帮助开发者快速了解和使用Vite进行项目开发。   Vue ：网站包含了关于Vue.js框架的开发文档和教程，涵盖了Vue的基础知识、组件开发、状态管理等方面的内容，帮助开发者掌握Vue.js的使用技巧。   Link Lab ：Link Lab部分提供了有关前端开发中常用的链接、资源和工具，包括前端框架、UI库、插件等相关内容，帮助开发者发现和使用与前端开发相关的资源。通过VVLL.net，开发者可以获取关于Vite、Vue和前端开发相关的最新资讯、文档和教程，帮助他们更好地理解和应用这些技术，提升前端开发能力和效率。","level":1},{"id":"/projects/nuxt-vvll#nuxt3-vvll","title":"Nuxt3 VVLL","titles":[],"content":"VVLL.net（Vite Vue Link Lab）是一个网站，主要提供关于Vite、Vue和相关开发文档的资源和信息。以下是该网站的主要内容和特点：Vite ：网站涵盖了关于Vite的开发文档和指南，介绍了Vite作为一个现代化的构建工具的特性和用法，帮助开发者快速了解和使用Vite进行项目开发。   Vue ：网站包含了关于Vue.js框架的开发文档和教程，涵盖了Vue的基础知识、组件开发、状态管理等方面的内容，帮助开发者掌握Vue.js的使用技巧。   Link Lab ：Link Lab部分提供了有关前端开发中常用的链接、资源和工具，包括前端框架、UI库、插件等相关内容，帮助开发者发现和使用与前端开发相关的资源。通过VVLL.net，开发者可以获取关于Vite、Vue和前端开发相关的最新资讯、文档和教程，帮助他们更好地理解和应用这些技术，提升前端开发能力和效率。","level":1},{"id":"/sub/guide#sub-guidemd","title":"sub Guide.md","titles":[],"content":"Back to Home","level":1},{"id":"/sub/other#sub-othermd","title":"sub other.md","titles":[],"content":"sub index","level":1},{"id":"/tags/ai/chatgpt#chatgpt-的主要特点","title":"ChatGPT 的主要特点","titles":[],"content":"强大的自然语言理解和生成能力 ：\nChatGPT 能够理解并生成自然语言，适用于多种语言任务，如对话、文本生成、翻译、问答、文本摘要等。   基于 GPT-4 架构 ：\nChatGPT 基于最新的 GPT-4 架构，这使得它在理解上下文和生成连贯文本方面表现出色。相比于前代模型，GPT-4 具有更大的参数量和更强的推理能力。   大规模预训练 ：\nChatGPT 在大规模文本数据上进行预训练，这使其具备丰富的语言知识和上下文理解能力。预训练数据包括各种书籍、文章、网站等，涵盖广泛的主题和领域。   多轮对话能力 ：\nChatGPT 能够进行多轮对话，保持上下文信息，使对话更加连贯和自然。这在对话系统和客服机器人中尤为重要。   定制和微调 ：\n用户可以通过微调 ChatGPT 模型，使其适应特定领域或任务的需求。这种定制化能力使得 ChatGPT 能够更好地满足不同场景下的应用需求。","level":3},{"id":"/tags/ai/chatgpt#使用场景","title":"使用场景","titles":[],"content":"对话系统和客服 ：\nChatGPT 可以用于构建智能对话系统和客服机器人，帮助企业自动化处理客户咨询和支持请求。   内容生成 ：\nChatGPT 可以生成各种类型的内容，包括文章、博客、产品描述、创意写作等，帮助内容创作者提高效率。   语言翻译 ：\nChatGPT 能够进行高质量的语言翻译，支持多种语言之间的相互转换。   教育和辅导 ：\nChatGPT 可以作为虚拟教师或辅导助手，为学生提供问题解答、作业辅导和学习建议。   问答系统 ：\nChatGPT 可以构建智能问答系统，为用户提供准确的答案和信息查询服务。   文本摘要 ：\nChatGPT 可以对长文档进行自动摘要，提取关键信息，帮助用户快速了解内容。","level":3},{"id":"/tags/ai/chatgpt#优势和局限","title":"优势和局限","titles":[],"content":"","level":3},{"id":"/tags/ai/chatgpt#优势","title":"优势","titles":["优势和局限"],"content":"强大的生成能力 ：\nChatGPT 能够生成流畅、自然的文本，适用于各种语言任务。   广泛的应用场景 ：\n其多功能性使得 ChatGPT 在多个领域都有广泛应用，如对话系统、内容生成、翻译等。   持续改进 ：\nOpenAI 持续改进和优化 ChatGPT 模型，提供更好的性能和功能。","level":4},{"id":"/tags/ai/chatgpt#局限","title":"局限","titles":["优势和局限"],"content":"依赖训练数据 ：\nChatGPT 的生成质量和准确性取决于其训练数据，可能在特定领域表现不佳。   潜在的偏见和不准确 ：\n由于训练数据中的偏见和噪音，ChatGPT 可能生成带有偏见或不准确的信息。   缺乏真正的理解 ：\n虽然 ChatGPT 表现出色，但它并不具备真正的理解能力，仅仅是通过模式匹配生成文本。","level":4},{"id":"/tags/ai/chatgpt#示例","title":"示例","titles":["优势和局限","局限"],"content":"以下是一个 ChatGPT 的示例对话：用户：什么是量子计算？ChatGPT：量子计算是一种基于量子力学原理的新型计算方式。与传统计算机使用二进制比特（0和1）不同，量子计算机使用量子比特（量子位或qubit）。量子比特可以同时处于多种状态的叠加，这使得量子计算机在处理某些复杂问题时具有潜在的巨大优势，如因子分解、优化问题和模拟量子系统等。量子计算的核心概念包括叠加、纠缠和量子门操作。","level":3},{"id":"/tags/ai/chatgpt#总结","title":"总结","titles":["优势和局限","局限"],"content":"ChatGPT 是一种强大的自然语言处理模型，具备广泛的应用场景和强大的生成能力。它在对话系统、内容生成、翻译、教育等领域表现出色。虽然存在一定的局限，但随着技术的不断进步，ChatGPT 及其后续版本将为各类应用提供更优质的解决方案。","level":3},{"id":"/tags/ai/edagedb-ai#edgedb-的特点和功能","title":"EdgeDB 的特点和功能","titles":[],"content":"面向对象的数据建模 ：\nEdgeDB 支持复杂数据模型的定义，包括实体（Entity）、关系（Relationship）、枚举（Enum）等，使得数据模型更加清晰和直观。   声明式查询语言 ：\nEdgeDB 提供了一种声明式的查询语言，旨在简化复杂查询的编写和理解。它结合了关系型数据库的强大查询能力和面向对象数据库的灵活性。   类型安全和数据完整性 ：\n通过类型系统和约束，EdgeDB 提供了高度的数据安全性和完整性保障，防止无效数据插入和数据冲突。   内置版本控制 ：\nEdgeDB 内置了版本控制功能，允许用户跟踪和管理数据模型的演变历史，轻松进行数据库架构的变更和回滚。   开发者友好 ：\nEdgeDB 设计简单且易于使用，适合开发人员快速上手，并支持与现有应用程序和工具的集成。   跨平台支持 ：\nEdgeDB 可以在多种操作系统上运行，包括 Linux、macOS 和 Windows，适合各种部署环境和开发团队的需求。","level":3},{"id":"/tags/ai/edagedb-ai#edgedb-与人工智能的关系","title":"EdgeDB 与人工智能的关系","titles":[],"content":"虽然 EdgeDB 本身并不是一种人工智能技术或产品，但是在某些人工智能应用程序的开发和部署过程中，数据库技术扮演着重要角色。例如，在存储和管理大量的结构化数据时，数据库系统如 EdgeDB 能够为机器学习模型的训练和推断提供有效的支持。","level":3},{"id":"/tags/ai/edagedb-ai#总结","title":"总结","titles":[],"content":"EdgeDB 是一种现代化的关系型数据库管理系统，提供了强大的数据建模和查询能力。它适合于开发人员构建复杂的应用程序和服务，尤其在需要高度结构化和类型安全的数据存储时特别有用。虽然 EdgeDB 自身并不涉及人工智能领域，但在支持和优化人工智能应用程序的数据管理方面，数据库技术具有重要的作用。","level":3},{"id":"/tags/backend/efcore#entity-framework-core","title":"Entity Framework Core","titles":[],"content":"Entity Framework Core（简称EF Core）是一个现代的、跨平台的、开源的对象关系映射（ORM）框架，由微软开发。它允许.NET开发者通过.NET对象与关系型数据库进行交互，而无需编写大部分的数据访问代码。EF Core通过对象关系映射减少了数据访问代码的编写，使得开发者可以更加专注于业务逻辑。EF Core支持数据库的迁移，允许开发者通过代码来管理数据库的版本和结构变化。它还支持将LINQ查询自动转换为SQL命令，使得数据访问更加直观和简单。此外，EF Core具有模型级查询过滤器和数据库上下文池等特性，可以提高查询的效率和性能。EF Core的使用一般需要以下步骤：首先，使用NuGet包管理器安装适用于项目的EF Core包；其次，创建数据库上下文类，该类是EF Core的入口点，用于连接到数据库并管理实体（数据库表的映射对象）；最后，根据需要配置数据库连接字符串和映射的实体。总之，Entity Framework Core是一个功能强大且易于使用的ORM框架，它简化了.NET开发者与关系型数据库的交互过程，提高了开发效率和代码质量。如需更多信息，建议查阅微软官方文档或相关教程。","level":1},{"id":"/tags/backend/elasticsearch#elasticsearch","title":"Elasticsearch","titles":[],"content":"Elasticsearch 是一个分布式、RESTful 风格的搜索和分析引擎，基于开源的 Apache Lucene 项目构建。它最常用于实现复杂的搜索功能和实时数据分析。以下是对 Elasticsearch 的详细介绍：","level":1},{"id":"/tags/backend/elasticsearch#主要特点和功能","title":"主要特点和功能","titles":["Elasticsearch"],"content":"分布式架构 ：\nElasticsearch 设计为分布式系统，能够横向扩展，以适应大规模数据存储和处理需求。数据在集群中的不同节点上分片存储，确保高可用性和可靠性。   全文搜索 ：\n作为搜索引擎，Elasticsearch 提供强大的全文搜索功能，支持多种查询方式（如关键词搜索、布尔查询、模糊搜索等），并能处理自然语言处理（NLP）任务。   实时搜索和分析 ：\nElasticsearch 能够实时索引和搜索数据，这使其非常适合需要快速响应的应用，如实时日志分析和监控。   RESTful API ：\nElasticsearch 提供丰富的 RESTful API，支持通过 HTTP 协议进行数据操作和查询，方便与各种编程语言和框架集成。   丰富的查询语言 ：\n使用 Elasticsearch 的查询 DSL（Domain Specific Language），用户可以构建复杂的查询和过滤器，进行高级数据检索和分析。   集成和扩展性 ：\nElasticsearch 可以与其他工具无缝集成，如 Kibana（用于数据可视化）、Logstash（用于日志收集和处理）和 Beats（用于轻量数据传输），构成完整的 Elastic Stack（ELK Stack）。   强大的分析功能 ：\n支持多种聚合操作，如计数、平均值、最小值、最大值、统计分析和直方图等，适用于复杂的数据分析和商业智能应用。","level":3},{"id":"/tags/backend/elasticsearch#核心概念","title":"核心概念","titles":["Elasticsearch"],"content":"索引（Index） ：\nElasticsearch 中的数据存储单位，类似于关系数据库中的数据库。每个索引包含多个文档，并且每个文档都有一个唯一的 ID。   文档（Document） ：\nElasticsearch 中的数据条目，类似于关系数据库中的行。文档使用 JSON 格式表示，包含各种字段和数据。   分片（Shard） ：\n为了实现水平扩展，Elasticsearch 将索引拆分为多个分片（primary shard），每个分片可以独立存储和搜索。分片可以进一步复制（replica shard）以提高数据的可靠性和查询性能。   节点（Node） ：\nElasticsearch 集群中的一个实例，负责存储数据和处理查询。多个节点可以组成一个集群，共同分担负载和提高容错能力。   集群（Cluster） ：\n一组节点的集合，协同工作来处理数据存储和查询任务。集群中的所有节点共享同一个集群名。","level":3},{"id":"/tags/backend/elasticsearch#使用场景","title":"使用场景","titles":["Elasticsearch"],"content":"日志和事件数据分析 ：\n通过与 Logstash 和 Beats 集成，Elasticsearch 常用于日志和事件数据的收集、存储、搜索和分析，是构建实时监控和告警系统的理想选择。   网站搜索 ：\n提供高性能的全文搜索功能，可以用于实现网站内的内容搜索，提高用户的搜索体验。   实时应用程序监控 ：\n收集和分析应用程序性能指标和日志，帮助运维人员及时发现和解决问题。   商业智能和分析 ：\n使用强大的聚合功能，对业务数据进行深度分析，生成统计报表和可视化图表，支持决策制定。   电子商务和推荐系统 ：\n支持复杂的产品搜索和推荐算法，实现个性化的购物体验和推荐服务。","level":3},{"id":"/tags/backend/elasticsearch#总结","title":"总结","titles":["Elasticsearch"],"content":"Elasticsearch 是一个强大且灵活的搜索和分析引擎，适用于各种需要快速搜索和实时数据分析的应用场景。通过其分布式架构、丰富的查询语言和强大的集成功能，Elasticsearch 成为现代数据驱动应用中不可或缺的工具。","level":3},{"id":"/tags/backend/hangfire#主要特点和功能","title":"主要特点和功能","titles":[],"content":"持久化任务存储 ：\nHangfire 支持将任务持久化存储在各种后端数据库中，如 SQL Server、PostgreSQL、MongoDB 和 Redis。这意味着即使应用程序重启或崩溃，任务也不会丢失，能够在恢复后继续执行。   多种任务类型 ：    火即执行任务（Fire-and-forget job） ：立即执行一次的任务。   延迟任务（Delayed job） ：在指定时间后执行的任务。   定时任务（Recurring job） ：按计划周期性执行的任务。   连续任务（Continuations） ：在另一个任务完成后执行的任务。   自动重试机制 ：\n任务失败时，Hangfire 会自动重试任务执行，确保任务最终完成。重试策略可以根据需要进行配置。   分布式处理 ：\nHangfire 支持在多个服务器上分布式执行任务，利用多个工作节点共同处理任务队列，从而提高任务处理的并发性和可靠性。   实时监控 ：\n提供一个基于 Web 的仪表板，允许开发人员监控任务的执行状态、任务队列、任务历史记录和任务失败原因等。仪表板还支持重新排队和删除任务。   简便的集成 ：\n通过简单的 NuGet 包安装和配置，即可将 Hangfire 集成到现有的 .NET 应用程序中。其直观的 API 使得任务的定义和管理变得非常容易。","level":3},{"id":"/tags/backend/hangfire#使用场景","title":"使用场景","titles":[],"content":"电子邮件通知 ：\n在后台处理电子邮件发送任务，避免阻塞主线程，提高应用程序响应速度。   数据处理和分析 ：\n在后台执行数据处理、转换和分析任务，如批量数据导入、定期数据清理等。   报告生成 ：\n定期生成报表并将结果发送给用户或存储在系统中。   定时任务 ：\n例如，每天凌晨执行系统备份，定期发送提醒通知等。   任务工作流 ：\n组合多个任务形成复杂的工作流，每个任务依赖于前一个任务的完成。","level":3},{"id":"/tags/backend/hangfire#简单示例","title":"简单示例","titles":[],"content":"下面是一个简单的 ASP.NET Core 项目中集成 Hangfire 的示例：安装 Hangfire ：\n在项目中通过 NuGet 包管理器安装 Hangfire：     配置 Hangfire ：\n在    文件中进行配置：     定义任务 ：\n在应用程序中定义一个简单的任务并进行调度：","level":3},{"id":"/tags/backend/hangfire#总结","title":"总结","titles":[],"content":"Hangfire 是一个功能强大的后台任务管理工具，适用于各种 .NET 应用程序。它提供了丰富的任务调度和管理功能，支持任务的持久化存储和分布式执行，简化了后台任务的开发和维护工作。通过 Hangfire，开发人员可以轻松实现高效、可靠的后台任务处理，提高应用程序的性能和用户体验。","level":3},{"id":"/tags/backend/minio#主要特点和功能","title":"主要特点和功能","titles":[],"content":"高性能 ：\nMinIO 采用了高效的 Golang 编写，优化了 I/O 操作，能够在常规硬件上提供非常高的吞吐量和低延迟。它专为大数据处理和机器学习工作负载设计。   S3 兼容性 ：\nMinIO 完全兼容 Amazon S3 API，允许开发者使用现有的 S3 客户端库、应用程序和工具，无需进行任何代码修改。   分布式架构 ：\nMinIO 支持分布式部署，能够在多台服务器上存储数据，实现高可用性和容错能力。分布式部署支持数据冗余和自动故障恢复。   数据保护 ：\nMinIO 提供多种数据保护机制，包括 erasure coding（纠删码）、位旋转和散列校验，确保数据的完整性和持久性。   可扩展性 ：\nMinIO 的架构允许通过添加更多节点来扩展存储容量和性能，适用于大规模数据存储需求。   多租户支持 ：\nMinIO 支持多租户环境，通过策略和访问控制列表（ACL）管理用户权限，确保数据隔离和安全。   简单安装和管理 ：\nMinIO 提供了简单的安装和配置流程，支持 Docker、Kubernetes 等容器化部署，提供了 Web 控制台和 CLI 工具用于管理和监控。","level":3},{"id":"/tags/backend/minio#使用场景","title":"使用场景","titles":[],"content":"大数据存储 ：\nMinIO 可用于存储和管理大规模的非结构化数据，如日志、备份、媒体文件等，适用于大数据分析和处理。   机器学习 ：\n由于其高性能和高可用性，MinIO 是机器学习工作负载的数据存储的理想选择，支持快速的数据读写和处理。   混合云和私有云存储 ：\nMinIO 可以部署在本地数据中心，也可以与公有云集成，适用于构建混合云存储解决方案。   灾难恢复 ：\n通过分布式部署和数据冗余，MinIO 可用于构建高可靠性的灾难恢复解决方案，确保数据在不同地点的备份和恢复。","level":3},{"id":"/tags/backend/minio#安装和使用示例","title":"安装和使用示例","titles":[],"content":"以下是一个在本地安装和使用 MinIO 的简单示例：下载和安装 MinIO ：\n使用官方提供的可执行文件快速启动 MinIO 服务器：     访问 MinIO 控制台 ：\n默认情况下，MinIO 服务器启动后可以通过浏览器访问其控制台，URL 类似于   。使用启动时显示的访问密钥和秘密密钥进行登录。   使用 MinIO 客户端（mc）管理存储 ：\nMinIO 提供了一个命令行工具   ，用于与 MinIO 服务器交互：","level":3},{"id":"/tags/backend/minio#总结","title":"总结","titles":[],"content":"MinIO 是一个强大且灵活的对象存储解决方案，兼容 S3 API，提供高性能、高可用性和可扩展性，适用于各种大规模数据存储和处理场景。通过简单的安装和配置，开发人员和运维人员可以快速部署和管理 MinIO，构建可靠的数据存储基础设施。","level":3},{"id":"/tags/backend/quartz#主要特点和功能","title":"主要特点和功能","titles":[],"content":"丰富的调度能力 ：\nQuartz 支持各种调度需求，包括简单的时间间隔调度、复杂的 Cron 表达式调度、以及基于日历的调度等。     作业和触发器 ：\nQuartz 通过作业（Job）和触发器（Trigger）来定义和控制任务的执行。作业是实际执行的任务逻辑，而触发器则定义了任务的执行时间和条件。     持久化支持 ：\nQuartz 可以将调度信息持久化到数据库中，支持多种数据库，包括 MySQL、PostgreSQL、Oracle 等。这使得任务调度信息可以在应用程序重启后恢复。     分布式调度 ：\nQuartz 支持分布式部署，能够在多个节点之间协调任务调度和执行，提高系统的可靠性和可扩展性。   错过处理和异常处理 ：\nQuartz 提供了灵活的机制来处理任务的错过执行和异常情况，可以配置重试策略、错误处理逻辑等。   插件和扩展 ：\nQuartz 提供了一些内置的插件，并允许开发人员创建自定义插件，以扩展其功能。例如，Quartz 支持邮件通知、JMX 集成等。","level":3},{"id":"/tags/backend/quartz#使用方法","title":"使用方法","titles":[],"content":"引入 Quartz 库 ：\n在 Maven 项目中引入 Quartz 依赖：     创建调度器 ：\n创建和启动一个调度器实例：     定义作业和触发器 ：\n定义一个简单的作业和触发器，并将其调度：     停止调度器 ：\n当不再需要时，可以停止调度器：","level":3},{"id":"/tags/backend/quartz#示例应用场景","title":"示例应用场景","titles":[],"content":"定时报告生成 ：\n定期生成并发送报告，例如每周一早上生成上周的销售报告并发送到相关人员的邮箱。   系统监控和维护任务 ：\n定期执行系统监控和维护任务，例如每晚执行数据库备份、磁盘清理等。   提醒和通知系统 ：\n基于时间的提醒和通知，例如每天下午提醒用户完成每日任务、到期日提醒等。   数据同步 ：\n定期同步不同系统之间的数据，确保数据一致性和及时性。","level":3},{"id":"/tags/backend/quartz#总结","title":"总结","titles":[],"content":"Quartz 是一个强大且灵活的作业调度框架，适用于各种复杂的调度需求。通过其丰富的功能和易用的 API，开发人员可以轻松实现各种定时任务和后台作业，提升应用程序的自动化和可靠性。Quartz 的持久化支持和分布式调度能力使得它在高可用性和大规模系统中表现出色。","level":3},{"id":"/tags/backend/rabbitmq#主要特点和功能","title":"主要特点和功能","titles":[],"content":"支持多种消息协议 ：\nRabbitMQ 支持多种消息传递协议，如 Advanced Message Queuing Protocol (AMQP)、Message Queuing Telemetry Transport (MQTT) 和 Streaming Text Oriented Messaging Protocol (STOMP)。   多语言客户端库 ：\nRabbitMQ 提供了多种编程语言的客户端库，支持 Java、Python、Ruby、.NET、Go、JavaScript 等，方便不同技术栈的应用集成。   消息持久化 ：\nRabbitMQ 支持消息持久化，可以将消息存储在磁盘上，确保在系统崩溃或重启后消息不丢失。   高可用性 ：\nRabbitMQ 支持集群部署和镜像队列，能够在节点发生故障时自动切换和恢复，确保消息服务的高可用性。   灵活的路由机制 ：\nRabbitMQ 提供多种交换器类型（Direct、Fanout、Topic、Headers），支持复杂的消息路由规则，可以根据不同的需求灵活地分发消息。   管理和监控工具 ：\nRabbitMQ 提供了强大的管理和监控工具，如 Web 管理界面、命令行工具和插件，方便管理员进行配置、监控和调试。   扩展性 ：\n通过插件机制，RabbitMQ 可以扩展其功能，支持额外的协议、身份认证方式、日志记录等。","level":3},{"id":"/tags/backend/rabbitmq#核心概念","title":"核心概念","titles":[],"content":"生产者（Producer） ：\n发送消息到 RabbitMQ 的应用程序或服务。生产者将消息发送到交换器（Exchange）。   消费者（Consumer） ：\n从 RabbitMQ 中接收和处理消息的应用程序或服务。消费者从队列（Queue）中获取消息进行处理。   队列（Queue） ：\n存储消息的缓冲区，消费者从队列中接收消息进行处理。队列是消息的实际存储位置。   交换器（Exchange） ：\n接受来自生产者的消息，并根据绑定规则将消息路由到一个或多个队列。交换器类型包括 Direct、Fanout、Topic 和 Headers。   绑定（Binding） ：\n定义交换器和队列之间的路由规则。绑定决定了消息从交换器到队列的传递路径。   消息（Message） ：\n生产者发送的数据信息，包含消息头（Headers）和消息体（Body）。消息头用于存储元数据，消息体是实际的数据内容。","level":3},{"id":"/tags/backend/rabbitmq#使用场景","title":"使用场景","titles":[],"content":"任务队列 ：\n用于在分布式系统中异步处理任务，将任务分发到多个工作进程，平衡负载和提高处理效率。   消息广播 ：\n在发布/订阅模式中，将消息广播给多个消费者，实现实时通知和事件驱动架构。   请求/响应模式 ：\n支持 RPC（远程过程调用）模式，实现服务之间的同步通信和请求响应。   日志收集和分析 ：\n将日志信息发送到 RabbitMQ 进行集中收集和分析，支持实时监控和故障排查。   数据流处理 ：\n用于流数据的传输和处理，支持大数据和实时分析应用。","level":3},{"id":"/tags/backend/rabbitmq#优势","title":"优势","titles":[],"content":"可靠性 ：\n支持消息确认机制、持久化和高可用性，确保消息传输的可靠性和数据不丢失。   灵活性 ：\n多种交换器和绑定规则，支持复杂的消息路由和分发。   可扩展性 ：\n集群和镜像队列支持，能够处理大规模消息传输和高并发场景。   易管理性 ：\n提供丰富的管理工具和插件，方便运维和监控。","level":3},{"id":"/tags/backend/rabbitmq#总结","title":"总结","titles":[],"content":"RabbitMQ 是一个功能强大且灵活的消息中间件，广泛应用于分布式系统中实现异步消息传递和任务处理。通过其可靠性、灵活性和可扩展性，RabbitMQ 能够满足各种高并发和高可用性应用场景的需求，成为现代微服务架构和消息驱动架构中的关键组件。","level":3},{"id":"/tags/backend/websocket#特点和优势","title":"特点和优势","titles":[],"content":"全双工通信 ：\nWebSocket 通过在客户端和服务器之间建立持久连接，实现了全双工通信，即客户端和服务器可以同时发送和接收数据，而无需每次通信都建立新的连接。   低延迟和高效性 ：\n由于建立了持久连接，WebSocket 可以实现较低的延迟，避免了传统的 HTTP 请求和响应模型中频繁建立和关闭连接的开销，从而提高了通信效率。   跨域支持 ：\nWebSocket 支持跨域通信，即在不同的域名下的客户端和服务器之间也可以建立连接和进行数据交换，而不受同源策略的限制。   实时性和即时更新 ：\nWebSocket 适用于需要实时数据传输的应用场景，如即时通讯、实时位置跟踪、在线游戏、股票市场数据更新等，可以实时推送数据给客户端，实现即时更新。   支持多种应用协议 ：\nWebSocket 协议本身是一个通用的协议，不限于特定的应用领域，因此可以支持多种应用的实时通信需求。","level":3},{"id":"/tags/backend/websocket#websocket-的工作原理","title":"WebSocket 的工作原理","titles":[],"content":"握手阶段 ：   客户端通过 HTTP 或 HTTPS 发起 WebSocket 握手请求，请求头中包含特定的 Upgrade 和 Connection 字段，告知服务器希望升级到 WebSocket 协议。  服务器收到请求后，如果支持 WebSocket，会返回状态码 101 Switching Protocols，表示升级成功，此时连接升级为 WebSocket。   数据传输阶段 ：   客户端和服务器之间的连接升级后，可以直接通过发送数据帧（frame）进行通信，数据帧可以是文本帧、二进制帧或控制帧。  客户端和服务器都可以发送数据帧，并且数据帧可以包含应用层协议的数据。   连接关闭阶段 ：   客户端或服务器可以发送关闭帧（close frame）来关闭连接，关闭帧包含关闭状态码和可选的关闭原因。","level":3},{"id":"/tags/backend/websocket#websocket-和-http-的区别","title":"WebSocket 和 HTTP 的区别","titles":[],"content":"连接方式 ：   HTTP 是一种请求-响应协议，每次请求都需要建立新的连接，请求结束后即关闭连接。  WebSocket 建立一次连接后保持持久连接状态，客户端和服务器可以随时进行数据交换。   通信效率 ：   HTTP 在每次请求时都需要重新建立连接和传输头部信息，效率较低。  WebSocket 通过持久连接和数据帧传输，可以实现低延迟和高效率的通信。   实时性 ：   HTTP 通常不适用于需要实时数据传输的应用场景。  WebSocket 适用于实时性要求高的应用，可以实时推送数据给客户端。","level":3},{"id":"/tags/backend/websocket#websocket-的应用场景","title":"WebSocket 的应用场景","titles":[],"content":"即时通讯和聊天应用 ：如在线聊天室、社交应用中的实时消息传递。   实时位置跟踪 ：如地图应用中的实时位置更新和导航信息推送。   在线游戏 ：支持实时多人游戏中的数据传输和状态同步。   金融市场 ：如股票交易平台中的实时股价更新和交易通知。   监控和控制系统 ：如实时监控系统中的数据传输和告警通知。","level":3},{"id":"/tags/backend/websocket#总结","title":"总结","titles":[],"content":"WebSocket 是一种现代化的网络通信协议，通过建立持久连接和全双工通信，实现了低延迟、高效率和实时性的数据传输。它在多种应用场景中广泛应用，为实时数据交换提供了有效的解决方案，成为许多实时应用程序的重要组成部分。","level":3},{"id":"/tags/databases/edgedb#edgedb-的主要特点","title":"EdgeDB 的主要特点","titles":[],"content":"基于图的关系模型 ：\nEdgeDB 使用图模型来表示数据，但仍然保留了关系数据库的优势。这种方法允许更加自然和直观的数据建模，特别是对于复杂的、具有多层嵌套关系的数据结构。   强类型系统 ：\nEdgeDB 提供了强类型系统，这意味着数据类型在数据库模式中有严格的定义和验证。这有助于减少运行时错误并提高数据的一致性和可靠性。   高级查询语言（EdgeQL） ：\nEdgeQL 是 EdgeDB 提供的高级查询语言，设计目标是比 SQL 更加易读和强大。EdgeQL 支持复杂的查询和数据操作，同时简化了多表关联、嵌套选择等操作。   自动迁移 ：\nEdgeDB 具备内置的迁移工具，能够自动生成数据库迁移脚本，帮助开发者轻松管理数据库模式的演变。   内置权限管理 ：\nEdgeDB 提供了细粒度的权限管理，可以基于用户角色设置不同的访问权限，增强了数据安全性。   JSON 支持 ：\nEdgeDB 原生支持 JSON 数据类型，允许开发者存储和查询 JSON 数据，同时保留关系型数据库的特性。","level":3},{"id":"/tags/databases/edgedb#安装和使用","title":"安装和使用","titles":[],"content":"","level":3},{"id":"/tags/databases/edgedb#安装-edgedb","title":"安装 EdgeDB","titles":["安装和使用"],"content":"EdgeDB 支持多种操作系统的安装，包括 macOS、Linux 和 Windows。可以通过以下命令进行安装：","level":4},{"id":"/tags/databases/edgedb#创建和管理数据库","title":"创建和管理数据库","titles":["安装和使用"],"content":"安装完成后，可以通过命令行工具创建并管理 EdgeDB 数据库。","level":4},{"id":"/tags/databases/edgedb#定义模式","title":"定义模式","titles":["安装和使用"],"content":"EdgeDB 使用 SDL（Schema Definition Language）来定义数据库模式。例如：上述定义表示一个    类型，其中包含一个必需的    属性和一个多值的    链接，指向其他    实例。","level":4},{"id":"/tags/databases/edgedb#执行查询","title":"执行查询","titles":["安装和使用"],"content":"可以使用 EdgeQL 进行数据查询和操作。例如，插入和查询数据：","level":4},{"id":"/tags/databases/edgedb#应用场景","title":"应用场景","titles":["安装和使用","执行查询"],"content":"EdgeDB 适用于各种需要复杂数据建模和高效查询的应用场景，包括但不限于：社交网络 ：处理用户之间的关系和互动。   推荐系统 ：基于用户行为和关系进行推荐。   知识图谱 ：存储和查询复杂的知识数据。   内容管理系统 ：管理多层次的内容结构。","level":3},{"id":"/tags/databases/edgedb#总结","title":"总结","titles":["安装和使用","执行查询"],"content":"EdgeDB 通过结合关系型数据库和图数据库的优点，提供了一种现代、高效、灵活的数据库管理解决方案。它的强类型系统、高级查询语言 EdgeQL、自动迁移和内置权限管理等特性，使其在处理复杂数据结构和高效查询方面表现出色。对于需要高性能和复杂数据建模的应用场景，EdgeDB 是一个值得考虑的选择。","level":3},{"id":"/tags/frontend/animate-css#主要特点和功能","title":"主要特点和功能","titles":[],"content":"预定义的动画效果 ：\nAnimate.css 包含了多种预定义的 CSS 动画效果，涵盖了常见的入场（进入）和出场（退出）动画，以及其他一些特效，如旋转、抖动、弹跳等。   轻量级和易用性 ：\nAnimate.css 的文件大小较小，易于集成到现有的网页项目中。用户只需将需要的动画类应用到 HTML 元素上，即可快速实现动画效果，无需深入学习复杂的动画技术。   跨浏览器兼容性 ：\nAnimate.css 经过广泛测试，能够在主流的现代浏览器（如 Chrome、Firefox、Safari、Edge 等）中良好运行，保证了动画效果的一致性和稳定性。   自定义和扩展性 ：\n尽管 Animate.css 提供了一组标准的动画效果，但用户仍可以通过修改现有的动画类或者添加自定义的 CSS 规则，来实现个性化的动画效果。   适用于响应式设计 ：\nAnimate.css 的动画效果可以根据屏幕大小和设备类型进行调整和响应，使其在不同设备上都能呈现出优美的动态效果。","level":3},{"id":"/tags/frontend/animate-css#使用方法","title":"使用方法","titles":[],"content":"引入 Animate.css 文件 ：\n在 HTML 文件中通过链接引入 Animate.css 文件，可以从官方网站直接下载或通过 CDN 获取：     应用动画类 ：\n在需要添加动画效果的 HTML 元素上，添加相应的 Animate.css 类即可。例如，要为一个元素添加淡入动画效果，可以添加类名   ：     触发动画 ：\nAnimate.css 的动画效果默认会在元素加载时自动触发。用户也可以通过 JavaScript 或添加特定的 CSS 类来手动触发或控制动画的开始和结束。","level":3},{"id":"/tags/frontend/animate-css#示例动画效果","title":"示例动画效果","titles":[],"content":"Animate.css 提供了多种动画效果，以下是几个示例：：淡入动画效果，使元素逐渐显示。   ：弹跳效果，使元素以弹簧的方式反复弹跳。   ：旋转进入效果，使元素旋转并逐渐显示。   ：向左滑出效果，使元素向左侧滑动并消失。","level":3},{"id":"/tags/frontend/animate-css#总结","title":"总结","titles":[],"content":"Animate.css 是一个简单易用的 CSS 动画库，为网页设计师和开发者提供了丰富的动画效果，能够快速增添页面的视觉吸引力和交互性。通过 Animate.css，用户可以轻松地实现各种动态效果，改善用户体验，使网页内容更加生动和引人注目。","level":3},{"id":"/tags/frontend/dayjs#安装-dayjs","title":"安装 Day.js","titles":[],"content":"","level":3},{"id":"/tags/frontend/dayjs#使用-npm-安装","title":"使用 npm 安装","titles":["安装 Day.js"],"content":"","level":4},{"id":"/tags/frontend/dayjs#使用-yarn-安装","title":"使用 yarn 安装","titles":["安装 Day.js"],"content":"","level":4},{"id":"/tags/frontend/dayjs#在浏览器中使用","title":"在浏览器中使用","titles":["安装 Day.js"],"content":"通过 CDN 引入 Day.js：","level":4},{"id":"/tags/frontend/dayjs#基本用法","title":"基本用法","titles":["安装 Day.js","在浏览器中使用"],"content":"","level":3},{"id":"/tags/frontend/dayjs#导入-dayjs","title":"导入 Day.js","titles":["安装 Day.js","在浏览器中使用","基本用法"],"content":"在 Node.js 或使用模块化的前端项目中，可以这样导入 Day.js：","level":4},{"id":"/tags/frontend/dayjs#创建日期对象","title":"创建日期对象","titles":["安装 Day.js","在浏览器中使用","基本用法"],"content":"使用 Day.js 创建日期对象非常简单，可以使用当前日期、指定日期字符串、时间戳等多种方式创建。","level":4},{"id":"/tags/frontend/dayjs#格式化日期","title":"格式化日期","titles":["安装 Day.js","在浏览器中使用","基本用法"],"content":"Day.js 提供了    方法将日期对象格式化为指定的字符串格式。","level":4},{"id":"/tags/frontend/dayjs#解析日期","title":"解析日期","titles":["安装 Day.js","在浏览器中使用","基本用法"],"content":"Day.js 可以解析多种格式的日期字符串，并将其转换为日期对象。","level":4},{"id":"/tags/frontend/dayjs#操作日期","title":"操作日期","titles":["安装 Day.js","在浏览器中使用","基本用法"],"content":"Day.js 提供了许多方法来操作日期对象，例如加减天数、月数、年数等。","level":4},{"id":"/tags/frontend/dayjs#比较日期","title":"比较日期","titles":["安装 Day.js","在浏览器中使用","基本用法"],"content":"Day.js 提供了多种比较日期的方法，可以方便地进行日期比较。","level":4},{"id":"/tags/frontend/dayjs#插件支持","title":"插件支持","titles":["安装 Day.js","在浏览器中使用"],"content":"Day.js 的核心非常小巧，但是可以通过插件来扩展其功能。常用插件包括时区支持、相对时间、ISO 8601 解析等。","level":3},{"id":"/tags/frontend/dayjs#安装插件","title":"安装插件","titles":["安装 Day.js","在浏览器中使用","插件支持"],"content":"例如安装相对时间插件：","level":4},{"id":"/tags/frontend/dayjs#使用插件","title":"使用插件","titles":["安装 Day.js","在浏览器中使用","插件支持"],"content":"使用插件时需要先加载并扩展 Day.js：","level":4},{"id":"/tags/frontend/dayjs#常用功能示例","title":"常用功能示例","titles":["安装 Day.js","在浏览器中使用"],"content":"","level":3},{"id":"/tags/frontend/dayjs#计算日期间隔","title":"计算日期间隔","titles":["安装 Day.js","在浏览器中使用","常用功能示例"],"content":"计算两个日期之间的间隔天数、月数或年数。","level":4},{"id":"/tags/frontend/dayjs#转换日期格式","title":"转换日期格式","titles":["安装 Day.js","在浏览器中使用","常用功能示例"],"content":"将日期字符串从一种格式转换为另一种格式。","level":4},{"id":"/tags/frontend/dayjs#获取相对时间","title":"获取相对时间","titles":["安装 Day.js","在浏览器中使用","常用功能示例"],"content":"获取相对时间描述，例如 “2 天前” 或 “刚刚”。","level":4},{"id":"/tags/frontend/dayjs#处理时区","title":"处理时区","titles":["安装 Day.js","在浏览器中使用","常用功能示例"],"content":"使用 Day.js 处理时区需要引入    插件和    插件：然后在代码中使用：","level":4},{"id":"/tags/frontend/dayjs#总结","title":"总结","titles":["安装 Day.js","在浏览器中使用"],"content":"Day.js 是一个轻量级、高性能的日期处理库，其 API 与 Moment.js 类似，便于迁移和使用。通过丰富的插件支持，Day.js 可以灵活地扩展功能，以满足各种日期和时间处理需求。如果你正在寻找一个小体积、快速的日期处理库，Day.js 是一个值得考虑的选择。","level":3},{"id":"/tags/frontend/jquery#主要特点和功能","title":"主要特点和功能","titles":[],"content":"DOM 操作 ：\njQuery 提供了简单而强大的方法来选择和操作 DOM 元素。它支持 CSS 选择器，允许开发人员轻松地查找和操作网页中的元素。     事件处理 ：\njQuery 提供了跨浏览器的事件处理方法，简化了事件绑定和事件处理。     Ajax 支持 ：\njQuery 提供了简洁的 Ajax 方法，方便与服务器进行异步通信，加载数据并更新网页内容。     动画和效果 ：\njQuery 提供了丰富的动画效果和方法，使得网页动画变得简单。     插件扩展 ：\njQuery 的插件机制允许开发人员创建可重用的代码模块，并扩展 jQuery 的功能。社区中有大量的 jQuery 插件可供使用。   跨浏览器兼容 ：\njQuery 处理了很多浏览器兼容性问题，使得代码可以在不同浏览器中一致运行。","level":3},{"id":"/tags/frontend/jquery#使用方法","title":"使用方法","titles":[],"content":"引入 jQuery ：\n可以通过下载 jQuery 库并在 HTML 文件中引用，或者直接使用 CDN 引用。     基本用法 ：\njQuery 使用    符号作为简写，代表 jQuery 对象。通过这个对象，可以访问 jQuery 的各种方法和功能。","level":3},{"id":"/tags/frontend/jquery#常用操作示例","title":"常用操作示例","titles":[],"content":"DOM 操作 ：     事件处理 ：     Ajax 请求 ：     动画效果 ：","level":3},{"id":"/tags/frontend/jquery#总结","title":"总结","titles":[],"content":"jQuery 作为一个功能强大且易于使用的 JavaScript 库，通过简化 DOM 操作、事件处理、Ajax 请求和动画效果，大大提升了前端开发的效率和便捷性。尽管随着现代 JavaScript 和前端框架（如 React、Vue.js 和 Angular）的发展，jQuery 的使用逐渐减少，但它依然是许多项目中的重要工具，并在维护遗留代码和简单项目中发挥着关键作用。","level":3},{"id":"/tags/frontend/momentjs#安装-momentjs","title":"安装 Moment.js","titles":[],"content":"","level":3},{"id":"/tags/frontend/momentjs#使用-npm-安装","title":"使用 npm 安装","titles":["安装 Moment.js"],"content":"","level":4},{"id":"/tags/frontend/momentjs#使用-yarn-安装","title":"使用 yarn 安装","titles":["安装 Moment.js"],"content":"","level":4},{"id":"/tags/frontend/momentjs#在浏览器中使用","title":"在浏览器中使用","titles":["安装 Moment.js"],"content":"通过 CDN 引入 Moment.js：","level":4},{"id":"/tags/frontend/momentjs#基本用法","title":"基本用法","titles":["安装 Moment.js","在浏览器中使用"],"content":"","level":3},{"id":"/tags/frontend/momentjs#导入-momentjs","title":"导入 Moment.js","titles":["安装 Moment.js","在浏览器中使用","基本用法"],"content":"在 Node.js 或使用模块化的前端项目中，可以这样导入 Moment.js：","level":4},{"id":"/tags/frontend/momentjs#创建日期对象","title":"创建日期对象","titles":["安装 Moment.js","在浏览器中使用","基本用法"],"content":"使用 Moment.js 创建日期对象非常简单，可以使用当前日期、指定日期字符串、时间戳等多种方式创建。","level":4},{"id":"/tags/frontend/momentjs#格式化日期","title":"格式化日期","titles":["安装 Moment.js","在浏览器中使用","基本用法"],"content":"Moment.js 提供了丰富的格式化选项，可以使用    方法将日期对象格式化为指定的字符串格式。","level":4},{"id":"/tags/frontend/momentjs#解析日期","title":"解析日期","titles":["安装 Moment.js","在浏览器中使用","基本用法"],"content":"Moment.js 可以解析多种格式的日期字符串，并将其转换为日期对象。","level":4},{"id":"/tags/frontend/momentjs#操作日期","title":"操作日期","titles":["安装 Moment.js","在浏览器中使用","基本用法"],"content":"Moment.js 提供了许多方法来操作日期对象，例如加减天数、月数、年数等。","level":4},{"id":"/tags/frontend/momentjs#比较日期","title":"比较日期","titles":["安装 Moment.js","在浏览器中使用","基本用法"],"content":"Moment.js 提供了多种比较日期的方法，可以方便地进行日期比较。","level":4},{"id":"/tags/frontend/momentjs#处理时区","title":"处理时区","titles":["安装 Moment.js","在浏览器中使用","基本用法"],"content":"Moment.js 还有一个扩展库   ，可以方便地处理时区。使用   ：","level":4},{"id":"/tags/frontend/momentjs#常用功能示例","title":"常用功能示例","titles":["安装 Moment.js","在浏览器中使用"],"content":"","level":3},{"id":"/tags/frontend/momentjs#计算日期间隔","title":"计算日期间隔","titles":["安装 Moment.js","在浏览器中使用","常用功能示例"],"content":"计算两个日期之间的间隔天数、月数或年数。","level":4},{"id":"/tags/frontend/momentjs#转换日期格式","title":"转换日期格式","titles":["安装 Moment.js","在浏览器中使用","常用功能示例"],"content":"将日期字符串从一种格式转换为另一种格式。","level":4},{"id":"/tags/frontend/momentjs#获取相对时间","title":"获取相对时间","titles":["安装 Moment.js","在浏览器中使用","常用功能示例"],"content":"获取相对时间描述，例如 “2 天前” 或 “刚刚”。","level":4},{"id":"/tags/frontend/momentjs#总结","title":"总结","titles":["安装 Moment.js","在浏览器中使用"],"content":"Moment.js 是一个功能强大的日期处理库，虽然它已经进入维护模式，但其丰富的功能和简单的 API 仍然使它在许多项目中被广泛使用。通过本文介绍的安装方法、基本用法和常用功能示例，你可以轻松地在你的项目中集成和使用 Moment.js 来处理各种日期和时间需求。考虑到 Moment.js 的维护状态，如果你正在开始一个新项目，可能会考虑使用更现代的替代库如 Luxon 或 date-fns。","level":3},{"id":"/tags/frontend/p5js#主要特点和功能","title":"主要特点和功能","titles":[],"content":"简化的图形绘制 ：\np5.js 提供了一组易于使用的函数，用于绘制基本的图形和形状，如线条、矩形、椭圆、弧形等。它隐藏了复杂的 Canvas API，使得绘图变得简单。     丰富的交互功能 ：\np5.js 提供了大量的事件处理函数，使得处理用户交互（如鼠标、键盘）变得容易。     动画和实时更新 ：\n使用    和    函数，可以轻松创建动画。   函数会被连续调用，从而更新画面。     支持多媒体 ：\np5.js 支持加载和操作图像、视频、音频等多媒体内容，适用于创意多媒体项目。     扩展和插件 ：\np5.js 拥有大量的插件和扩展库，如 p5.sound、p5.dom 等，提供了更多的功能和特性。","level":3},{"id":"/tags/frontend/p5js#使用方法","title":"使用方法","titles":[],"content":"引入 p5.js ：\n可以通过 HTML 文件中的    标签引入 p5.js：     基本结构 ：\np5.js 程序通常包含    和    两个主要函数：    ：在程序开始时运行一次，用于初始化设置。   ：连续运行，用于绘制和更新画面。","level":3},{"id":"/tags/frontend/p5js#常用功能示例","title":"常用功能示例","titles":[],"content":"绘制基本形状 ：     处理用户输入 ：     加载和显示图像 ：","level":3},{"id":"/tags/frontend/p5js#总结","title":"总结","titles":[],"content":"p5.js 是一个强大且易于使用的 JavaScript 库，专为创意编程和艺术项目设计。它简化了图形绘制、交互处理和动画制作，使得即使是编程初学者也能快速上手并创作出丰富多彩的作品。通过其广泛的功能和社区支持，p5.js 成为创意编码领域的重要工具。","level":3},{"id":"/tags/langs/java#_1-跨平台性","title":"1. 跨平台性","titles":[],"content":"Java 的最大特点之一是其跨平台能力，通常称为“编写一次，到处运行”（Write Once, Run Anywhere，简称 WORA）。这得益于 Java 虚拟机（Java Virtual Machine，JVM），它将 Java 编译后的字节码（bytecode）转换为特定平台上的机器码，从而实现了跨平台运行。","level":3},{"id":"/tags/langs/java#_2-面向对象","title":"2. 面向对象","titles":[],"content":"Java 是一种纯粹的面向对象编程语言，强调对象的概念和重用。主要的面向对象特性包括：封装（Encapsulation）：  将数据和行为封装在对象中，保护数据不被外界随意修改。   继承（Inheritance）：  通过继承机制，实现代码重用和扩展。   多态（Polymorphism）：  同一操作在不同对象上的不同表现。","level":3},{"id":"/tags/langs/java#_3-简单和易用","title":"3. 简单和易用","titles":[],"content":"Java 摒弃了 C++ 中复杂的特性（如指针、多重继承等），并提供了丰富的标准库（Java Standard Library），使得开发人员可以专注于业务逻辑而不是底层实现。","level":3},{"id":"/tags/langs/java#_4-安全性","title":"4. 安全性","titles":[],"content":"Java 在设计时考虑了安全性，特别是在网络环境中的应用。Java 提供了多层次的安全机制，包括字节码验证、类加载器和安全管理器。","level":3},{"id":"/tags/langs/java#_5-高性能","title":"5. 高性能","titles":[],"content":"尽管 Java 是解释执行的语言，但通过即时编译技术（Just-In-Time Compilation，JIT），Java 的运行性能得到了极大的提升。此外，Java 也支持多线程编程，能够充分利用多核处理器的性能。","level":3},{"id":"/tags/langs/java#_6-丰富的标准库","title":"6. 丰富的标准库","titles":[],"content":"Java 提供了丰富的标准库，涵盖了数据结构、算法、网络编程、数据库连接、图形用户界面等各个方面。这些库极大地方便了开发人员的工作，提高了开发效率。","level":3},{"id":"/tags/langs/java#_7-应用领域","title":"7. 应用领域","titles":[],"content":"Java 广泛应用于各种软件开发领域，包括但不限于：企业级应用：  如 Java EE（Java Enterprise Edition）用于构建大型企业级应用。   移动应用：  如 Android 应用开发主要使用 Java 语言。   Web 应用：  使用 Java 的 Spring、Struts 等框架开发动态 Web 应用。   大数据处理：  如 Hadoop、Apache Spark 等大数据框架使用 Java 开发。   嵌入式系统：  Java 也用于一些嵌入式系统的开发。","level":3},{"id":"/tags/langs/java#_8-生态系统","title":"8. 生态系统","titles":[],"content":"Java 拥有庞大的生态系统和活跃的社区。开源框架和工具如 Spring、Hibernate、Apache Maven、Gradle 等极大地丰富了 Java 的功能，促进了 Java 的发展。","level":3},{"id":"/tags/langs/java#_9-发展历史","title":"9. 发展历史","titles":[],"content":"1995 年：  Java 1.0 发布。   1998 年：  Java 2 (J2SE 1.2) 发布，引入了 Swing 库、集合框架等。   2004 年：  Java 5.0 发布，引入了泛型、增强型 for 循环等重要特性。   2011 年：  Oracle 收购 Sun Microsystems 后，发布了 Java 7。   2014 年：  Java 8 发布，引入了 Lambda 表达式、Stream API 等现代特性。   2017 年及以后：  Java 9、10、11 等版本陆续发布，引入了模块化系统、局部变量类型推断等特性。","level":3},{"id":"/tags/langs/java#总结","title":"总结","titles":[],"content":"Java 作为一种成熟的编程语言，凭借其跨平台、面向对象、简单、安全、高性能等优点，成为了许多开发者的首选工具。无论是在企业级开发、移动开发、Web 开发还是大数据处理领域，Java 都发挥着重要作用。","level":3},{"id":"/tags/textformats/json5#主要特点和功能","title":"主要特点和功能","titles":[],"content":"更灵活的语法 ：\nJSON5 支持 JSON 中不允许的一些语法，如支持在对象和数组的末尾添加逗号，以及支持注释（单行注释    和多行注释   ）。   更丰富的数据类型 ：\nJSON5 支持 JSON 中未定义的一些数据类型，如字符串可以使用单引号    包裹，可以包含 JavaScript 的特殊字符（如反斜杠   ）而不需要转义。   支持对象键的引号省略 ：\n在 JSON5 中，对象的键名可以不强制使用双引号括起来，除非键名包含特殊字符或不符合标识符的命名规则。   支持正则表达式字面量 ：\nJSON5 允许在对象中使用正则表达式字面量，这在原生的 JSON 中是不支持的。   跨平台和易读性 ：\nJSON5 与标准 JSON 兼容，可以在现有的 JSON 解析器中使用，同时也更易读和编写，使得人们在处理和编辑 JSON 数据时更加高效。","level":3},{"id":"/tags/textformats/json5#使用方法","title":"使用方法","titles":[],"content":"JSON5 的语法相对于标准的 JSON 来说更加灵活，但需要注意以下几点：语法规范 ：JSON5 的语法规范可以在其官方网站（  https://json5.org/）上查看和学习。   解析器支持 ：大部分现代编程语言都有对 JSON5 的解析支持，例如 JavaScript 中可以使用    方法来解析 JSON5 格式的数据。   工具支持 ：有许多在线工具和编辑器支持 JSON5 格式，能够帮助用户验证和格式化 JSON5 数据。","level":3},{"id":"/tags/textformats/json5#应用场景","title":"应用场景","titles":[],"content":"JSON5 主要适用于需要在 JSON 的基础上提供更多语法灵活性和可读性的场景，例如：配置文件 ：使用 JSON5 编写和维护复杂的配置文件，能够更方便地添加注释和结尾逗号。   数据交换 ：在数据交换和通信中，JSON5 可以更好地支持复杂数据结构和数据类型的表示。   JavaScript 应用 ：特别是在与 JavaScript 紧密集成的应用程序中，JSON5 的特性可以更自然地与 JavaScript 对象和数组进行交互。","level":3},{"id":"/tags/textformats/json5#总结","title":"总结","titles":[],"content":"JSON5 是 JSON 的一种扩展格式，通过引入更多的语法和功能，使得 JSON 数据的编写和阅读更加灵活和方便。它保留了 JSON 的兼容性和简洁性，同时提供了额外的特性，适用于需要更复杂数据结构和更人性化编写风格的应用场景。","level":3},{"id":"/tags/textformats/md#主要特点和语法","title":"主要特点和语法","titles":[],"content":"简洁和易读性 ：\nMarkdown 的语法非常简洁直观，使得用户可以快速上手，不需要复杂的编程知识。例如，使用    表示标题，   或    表示斜体或粗体文本。   纯文本格式 ：\nMarkdown 是纯文本格式，因此可以在任何文本编辑器中编写，不受特定软件的限制。   与HTML兼容 ：\nMarkdown 可以直接嵌入HTML标记，可以利用HTML的强大功能来增强文档的表现力。   语法简单明了 ：\nMarkdown 的语法基本上可以分为以下几类：   标题：使用    表示一级标题到六级标题。  段落和换行：使用空行分隔段落，行末加两个空格表示强制换行。  列表：使用   、   或    开头表示无序列表，使用数字加    表示有序列表。  强调和格式：使用    或    表示斜体，使用    或    表示粗体，使用反引号 ` 表示代码块。  链接和图片：使用    表示链接，使用    表示图片。   扩展功能 ：\nMarkdown 支持多种扩展语法，例如：   表格：使用    和    表示表格。  任务列表：使用    或    表示任务列表。","level":3},{"id":"/tags/textformats/md#应用场景","title":"应用场景","titles":[],"content":"博客和静态网站 ：\n许多博客平台和静态网站生成器（如 Jekyll、Hugo）都支持Markdown格式，用户可以使用Markdown编写和发布内容。   技术文档 ：\n开发者经常使用Markdown编写项目文档、API文档和README文件，GitHub等代码托管平台也广泛支持Markdown格式。   笔记和文档 ：\n个人用户可以使用Markdown格式来撰写笔记、学习记录和个人文档，保持文档的整洁和结构化。   电子邮件 ：\n有些邮件客户端和服务商支持Markdown格式，用户可以在邮件中使用Markdown来排版和格式化内容。   论坛和社交媒体 ：\n一些论坛和社交平台允许用户使用Markdown格式来发布帖子和评论，使得内容更易读和美观。","level":3},{"id":"/tags/textformats/md#总结","title":"总结","titles":[],"content":"Markdown作为一种轻量级的标记语言，不仅简化了HTML的书写，还具有简洁、易读、扩展性强等优点，使其在各种场景下都有广泛的应用。无论是开发者、写作人员还是个人用户，Markdown都能提供简便快捷、高效美观的文本编辑和发布体验。","level":3},{"id":"/tags/textformats/mermaid#主要特点和功能","title":"主要特点和功能","titles":[],"content":"文本描述语言 ：\nMermaid 使用简单的文本描述语言来定义图表，使得用户可以快速创建和编辑复杂的流程图、序列图和其他类型的图表。   多种图表类型 ：\nMermaid 支持多种常见的图表类型，包括但不限于：   流程图（Flowchart）  序列图（Sequence Diagram）  甘特图（Gantt Chart）  类图（Class Diagram）  状态图（State Diagram）  链接数据图（Entity Relationship Diagram）   轻量化和集成 ：\nMermaid 是一个轻量级的工具，易于集成到各种应用和网页中。它可以直接嵌入到 Markdown、HTML 和其他文档中，并支持动态更新和调整。   跨平台和开源 ：\nMermaid 是开源的工具，支持跨平台使用，可以在 Windows、macOS 和 Linux 等操作系统上运行。   自定义样式和布局 ：\n用户可以通过自定义选项和配置文件调整图表的样式、布局和外观，以满足不同需求和设计风格。","level":3},{"id":"/tags/textformats/mermaid#使用方法","title":"使用方法","titles":[],"content":"安装和集成 ：\nMermaid 可以通过 npm 包管理工具进行安装，或者直接在浏览器端使用。详细的安装和使用说明可以在 Mermaid 的官方网站   https://mermaid-js.github.io/mermaid/#/  上找到。   语法示例 ：\n下面是一个简单的 Mermaid 流程图的示例：    这段代码表示一个简单的流程图，节点 A 指向节点 B 和节点 C，节点 B 和节点 C 再分别指向节点 D。   在线编辑器 ：\nMermaid 提供了一个在线编辑器   https://mermaid-js.github.io/mermaid-live-editor/  ，可以实时预览和编辑 Mermaid 图表，帮助用户快速调试和生成图表。","level":3},{"id":"/tags/textformats/mermaid#应用场景","title":"应用场景","titles":[],"content":"软件开发 ：开发团队可以使用 Mermaid 来绘制和共享架构图、流程图和序列图，帮助团队成员理解和协作。   项目管理 ：项目管理人员可以利用 Mermaid 创建和管理甘特图，跟踪项目进度和资源分配。   教育和培训 ：教育工作者可以利用 Mermaid 制作教学资料，图解复杂概念和流程。   文档编写 ：技术文档撰写者可以通过 Mermaid 在文档中插入可视化的图表，提高文档的表现力和可理解性。","level":3},{"id":"/tags/textformats/mermaid#总结","title":"总结","titles":[],"content":"Mermaid 是一个功能强大且易于使用的图表绘制工具，适用于多种场景下的流程图、序列图和甘特图等需求。它通过简单的文本描述语言和丰富的图表类型，帮助用户快速创建和展示复杂的数据流程和关系，是软件开发、项目管理和教育培训等领域中的有力工具。","level":3},{"id":"/tags/textformats/xsl#_1-xsltxsl-transformations","title":"1. XSLT（XSL Transformations）","titles":[],"content":"XSLT 是 XSL 的一部分，用于将 XML 文档转换成其他格式，如 HTML、XML 或纯文本。XSLT 使用一种基于模板和模式匹配的声明性编程风格。","level":3},{"id":"/tags/textformats/xsl#主要特点和用途","title":"主要特点和用途：","titles":["1. XSLT（XSL Transformations）"],"content":"模板匹配和转换：  使用模板来匹配 XML 文档的元素，并生成输出结果。   XPath 表达式：  使用 XPath 语言来选择和操作 XML 文档中的节点。   变量和函数：  支持变量和函数的定义，增强了转换的灵活性和复用性。   递归处理和条件分支：  支持递归处理和条件分支，可以根据需要动态调整转换逻辑。","level":4},{"id":"/tags/textformats/xsl#_2-xpathxml-path-language","title":"2. XPath（XML Path Language）","titles":["1. XSLT（XSL Transformations）","主要特点和用途："],"content":"XPath 是 XSLT 的一部分，用于在 XML 文档中定位和选择节点。它提供了一组表达式，允许开发者通过路径或模式来访问 XML 文档的各个部分。","level":3},{"id":"/tags/textformats/xsl#主要特点和用途-1","title":"主要特点和用途：","titles":["1. XSLT（XSL Transformations）","主要特点和用途：","2. XPath（XML Path Language）"],"content":"路径表达式：  使用路径表达式描述节点在文档中的位置，类似于文件系统路径。   谓词：  可以使用谓词来过滤节点，根据特定条件选择节点。   函数库：  提供了一系列内置函数，用于在 XPath 表达式中执行字符串操作、数学计算、日期处理等。   轴：  支持不同类型的轴，如子节点、父节点、兄弟节点等，扩展了节点选择的灵活性。","level":4},{"id":"/tags/textformats/xsl#_3-xsl-foxsl-formatting-objects","title":"3. XSL-FO（XSL Formatting Objects）","titles":["1. XSLT（XSL Transformations）","主要特点和用途："],"content":"XSL-FO 是 XSL 的另一部分，用于定义文档的格式化和排版规则，以便生成输出的打印或显示形式。XSL-FO 主要用于描述文档的外观和样式，如页面布局、文本格式、图像和表格等。","level":3},{"id":"/tags/textformats/xsl#主要特点和用途-2","title":"主要特点和用途：","titles":["1. XSLT（XSL Transformations）","主要特点和用途：","3. XSL-FO（XSL Formatting Objects）"],"content":"页面序列和布局：  定义页面的顺序、页眉页脚、页面边距等布局属性。   块和行内对象：  描述文本块、图像、表格和其他对象的布局和样式。   属性和属性集：  使用属性和属性集来设置对象的格式、间距和对齐方式。   多语言支持：  提供多语言文本的处理和排版能力，支持不同语言和文化的排版需求。","level":4},{"id":"/tags/textformats/xsl#使用场景","title":"使用场景：","titles":["1. XSLT（XSL Transformations）","主要特点和用途："],"content":"数据转换和整合：  XSLT 用于将 XML 数据转换成不同格式，如 HTML 或其他 XML 结构，适用于数据交换和整合。   动态网页生成：  结合 XSLT 和 XPath 可以根据 XML 数据生成动态网页内容。   打印和报告生成：  使用 XSL-FO 可以生成具有复杂格式和布局要求的打印输出或电子报告。   数据查询和分析：  XPath 可用于查询和分析 XML 数据，从中提取有用信息或执行计算。总之，XSL 家族的语言提供了丰富的工具和技术，用于 XML 文档的转换、呈现和格式化，适用于各种应用场景，从简单的数据转换到复杂的文档排版和打印输出。","level":3},{"id":"/tags/tools/apisix#apisix-的主要特点","title":"APISIX 的主要特点","titles":[],"content":"高性能 ：\nAPISIX 基于 NGINX 和 LuaJIT 构建，能够提供高吞吐量和低延迟的 API 请求处理能力。其性能在众多 API 网关解决方案中表现优异。   动态配置 ：\nAPISIX 支持热更新配置，无需重启服务即可对路由、插件等进行动态修改。这使得系统更加灵活，能够快速响应业务需求的变化。   丰富的插件系统 ：\nAPISIX 提供了丰富的插件，可以实现认证、限流、日志、监控、缓存、变更请求和响应等功能。用户还可以根据需求开发自定义插件。   多协议支持 ：\n除了常见的 HTTP/HTTPS 协议，APISIX 还支持 TCP、UDP、gRPC、WebSocket 等协议，适用于多种应用场景。   强大的路由机制 ：\nAPISIX 支持多种路由匹配方式，包括精确匹配、前缀匹配、正则匹配、条件匹配等，能够灵活定义流量转发规则。   可扩展性 ：\n通过插件机制和 Lua 脚本，APISIX 具备极高的可扩展性。开发者可以轻松扩展功能以满足特定业务需求。   原生支持服务发现 ：\nAPISIX 支持与多种服务发现系统集成，如 Nacos、Consul、Eureka、Kubernetes 等，实现服务的自动注册和发现。   监控和可观测性 ：\nAPISIX 集成了 Prometheus、SkyWalking 等监控工具，提供丰富的监控指标和可观测性，帮助用户及时了解系统状态和性能瓶颈。","level":3},{"id":"/tags/tools/apisix#安装和使用","title":"安装和使用","titles":[],"content":"","level":3},{"id":"/tags/tools/apisix#安装-apisix","title":"安装 APISIX","titles":["安装和使用"],"content":"APISIX 支持多种安装方式，包括源码安装、Docker 安装和使用 Kubernetes Helm Chart 安装。以下是使用 Docker 安装的示例：","level":4},{"id":"/tags/tools/apisix#配置和管理-apisix","title":"配置和管理 APISIX","titles":["安装和使用"],"content":"APISIX 提供了 Dashboard 和 Admin API 两种管理方式。以下是通过 Admin API 配置路由和插件的示例：","level":4},{"id":"/tags/tools/apisix#使用-dashboard","title":"使用 Dashboard","titles":["安装和使用"],"content":"APISIX Dashboard 是一个基于 Web 的图形界面，用户可以通过该界面方便地进行配置管理。","level":4},{"id":"/tags/tools/apisix#应用场景","title":"应用场景","titles":["安装和使用","使用 Dashboard"],"content":"APISIX 适用于多种应用场景，包括但不限于：微服务架构 ：在微服务架构中充当 API 网关，管理和路由内部和外部的 API 请求。   安全和认证 ：通过插件实现 API 的认证和授权，保护后端服务的安全。   流量控制 ：对 API 请求进行限流、熔断等流量控制，保障服务稳定性。   数据缓存 ：缓存频繁访问的 API 响应，减少后端服务负载，提高响应速度。   日志和监控 ：集成日志和监控系统，实时监控 API 的使用情况和性能。","level":3},{"id":"/tags/tools/apisix#总结","title":"总结","titles":["安装和使用","使用 Dashboard"],"content":"Apache APISIX 是一个功能强大、性能优越的 API 网关，提供了丰富的功能和灵活的扩展性。它能够帮助企业高效地管理和监控 API 请求，确保服务的高可用性和安全性。通过其动态配置、插件系统和多协议支持，APISIX 可以适应各种复杂的应用场景，是一个值得考虑的 API 管理解决方案。","level":3},{"id":"/tags/tools/n8n#n8n-的主要特点","title":"N8N 的主要特点","titles":[],"content":"开源和自托管 ：\nN8N 是完全开源的，用户可以免费使用并部署在自己的服务器上。这提供了高度的灵活性和控制，尤其对于那些关心数据隐私和安全的用户。   直观的可视化界面 ：\nN8N 提供了一个直观的图形用户界面，用户可以通过拖放方式轻松创建和管理工作流。每个工作流节点代表一个任务或操作，这使得复杂的自动化流程变得简单易懂。   丰富的节点类型 ：\nN8N 支持多种节点类型，包括常见的 HTTP 请求、文件操作、数据库查询、电子邮件发送等。此外，还支持集成各种第三方服务，如 Google Sheets、Slack、GitHub、Trello 等。   条件逻辑和控制流 ：\nN8N 支持在工作流中添加条件逻辑和控制流节点，使用户能够根据特定条件执行不同的操作。这使得工作流更加灵活和强大。   数据转换和处理 ：\nN8N 允许用户在工作流中对数据进行转换和处理。用户可以通过内置的函数和表达式编辑器对数据进行各种操作。   扩展性 ：\nN8N 支持通过自定义节点和插件扩展其功能。开发者可以根据需要编写自己的节点，集成特定的服务或实现特定的功能。","level":3},{"id":"/tags/tools/n8n#安装和使用","title":"安装和使用","titles":[],"content":"","level":3},{"id":"/tags/tools/n8n#安装-n8n","title":"安装 N8N","titles":["安装和使用"],"content":"N8N 可以通过多种方式进行安装，包括 Docker、npm 和直接运行代码。以下是使用 Docker 安装的示例：上述命令将启动 N8N，并在本地的 5678 端口上提供服务。","level":4},{"id":"/tags/tools/n8n#创建和管理工作流","title":"创建和管理工作流","titles":["安装和使用"],"content":"安装并启动 N8N 后，可以通过浏览器访问 N8N 的界面（默认地址为   ）。在界面中，用户可以创建新的工作流并添加各种节点。","level":4},{"id":"/tags/tools/n8n#示例工作流","title":"示例工作流","titles":["安装和使用","创建和管理工作流"],"content":"以下是一个简单的工作流示例，展示了从 HTTP 请求获取数据并发送到 Slack 的流程：HTTP 请求节点 ：\n配置一个 HTTP 请求节点，设置请求 URL 和方法。例如，GET 请求   。   数据处理节点 ：\n添加一个函数节点，对 HTTP 请求返回的数据进行处理。例如，提取特定字段或进行格式化。   Slack 通知节点 ：\n配置一个 Slack 节点，设置 Slack Webhook URL 和消息内容。将处理后的数据作为消息内容发送到 Slack。","level":5},{"id":"/tags/tools/n8n#应用场景","title":"应用场景","titles":["安装和使用","创建和管理工作流"],"content":"N8N 适用于各种自动化需求，以下是一些常见的应用场景：数据同步 ：在不同系统或服务之间同步数据，如从数据库导出数据到 Google Sheets。   通知和报警 ：根据特定事件或条件发送通知和报警，如监控服务器状态并在异常时发送邮件或 Slack 消息。   任务自动化 ：自动化重复性任务，如每天定时备份数据库或清理日志文件。   集成和连接 ：连接和集成各种第三方服务，实现跨平台的数据流和操作，如从 Trello 卡片创建 GitHub Issue。","level":3},{"id":"/tags/tools/n8n#总结","title":"总结","titles":["安装和使用","创建和管理工作流"],"content":"N8N 是一个功能强大且灵活的工作流自动化工具，通过其直观的可视化界面和丰富的节点类型，使用户能够轻松创建和管理复杂的自动化任务和流程。无论是个人用户还是企业团队，N8N 都可以帮助他们提高效率，减少手动操作，优化工作流程。由于其开源和自托管的特性，N8N 也特别适合那些对数据隐私和安全有较高要求的用户。","level":3},{"id":"/tags/tools/redis-desktop#redisdesktopmanager","title":"RedisDesktopManager","titles":[],"content":"Redis Desktop Manager（RDM）是一个用于管理 Redis 数据库的桌面客户端应用程序。它提供了图形用户界面（GUI），使用户可以方便地连接、操作和管理 Redis 实例，而无需使用命令行界面（CLI）。以下是对 Redis Desktop Manager 的详细介绍：","level":2},{"id":"/tags/tools/redis-desktop#主要特点和功能","title":"主要特点和功能","titles":["RedisDesktopManager"],"content":"多平台支持 ：\nRedis Desktop Manager 提供了适用于 Windows、Mac OS 和 Linux 的客户端应用程序，支持跨平台使用。   连接管理 ：\n用户可以通过 Redis Desktop Manager 轻松地管理多个 Redis 数据库实例的连接。它支持基本的连接信息配置，如主机地址、端口号、认证密码等。   数据库操作 ：    数据浏览和编辑 ：通过 GUI 界面查看 Redis 中存储的数据结构（如字符串、列表、哈希表等），支持数据的编辑和更新操作。   键管理 ：可以查看和管理 Redis 中的键（keys），包括删除键、重命名键等操作。   数据导入导出 ：支持数据的导入和导出，方便用户在不同的 Redis 实例之间迁移数据或备份数据。   性能监控和统计 ：\nRedis Desktop Manager 提供了实时的性能监控和统计信息，包括连接状态、内存使用情况、命令执行情况等，帮助用户监控和优化 Redis 数据库的性能。   脚本执行 ：\n支持用户通过 Lua 脚本执行复杂的 Redis 操作，如事务、批量操作等，提升了数据处理的灵活性和效率。   插件和扩展 ：\nRedis Desktop Manager 提供了插件系统，允许用户根据需要扩展和定制功能，增强应用的适用性和用户体验。   安全性和权限管理 ：\n支持通过密码或者其他认证方式连接到 Redis 数据库，并且可以限制用户对数据库的操作权限，保障数据的安全性。","level":3},{"id":"/tags/tools/redis-desktop#使用场景","title":"使用场景","titles":["RedisDesktopManager"],"content":"开发者和运维人员 ：用于开发和测试过程中的 Redis 数据库管理，提供便捷的数据查看和操作。   系统管理员 ：用于监控和管理生产环境中的 Redis 数据库，进行性能优化和故障排除。   数据分析师和应用程序员 ：用于处理和分析 Redis 中的数据，支持数据的导入导出和快速查询。","level":3},{"id":"/tags/tools/redis-desktop#总结","title":"总结","titles":["RedisDesktopManager"],"content":"Redis Desktop Manager 是一个功能丰富的 Redis 客户端应用程序，通过提供直观的 GUI 界面和丰富的管理功能，简化了 Redis 数据库的连接、操作和管理过程。它适用于各种使用场景，帮助用户提高 Redis 数据库的使用效率和管理效果。","level":3},{"id":"/tags/tools/typora#主要特点和功能","title":"主要特点和功能","titles":[],"content":"所见即所得编辑 ：\nTypora 提供了实时预览功能，即在编辑 Markdown 文本时，右侧即时显示渲染后的效果，用户可以直观地查看最终显示效果，无需切换视图。   全面的 Markdown 支持 ：\nTypora 支持标准的 Markdown 语法，包括标题、段落、列表、引用、代码块、表格、链接等，用户可以方便地使用这些语法来撰写文档。   智能功能和快捷键 ：\nTypora 提供了许多智能功能和快捷键，如自动补全、快速插入表格、链接、图片等，使得编辑过程更加高效。   多种主题和界面样式 ：\nTypora 提供了多种内置主题，用户可以根据个人喜好选择合适的主题，同时也支持自定义主题，满足不同用户的视觉需求。   导出多种格式 ：\nTypora 支持将 Markdown 文档导出为多种格式，包括 HTML、PDF、Word、纯文本等，用户可以根据需求选择合适的导出格式。   图表和数学公式支持 ：\nTypora 支持插入图表和数学公式，用户可以使用 Markdown 扩展语法（如 LaTeX 公式）轻松插入数学公式和复杂的图表。   跨平台和同步 ：\nTypora 可以在 Windows、macOS 和 Linux 系统上运行，并支持云同步功能，如 Dropbox 和 Google Drive，用户可以方便地在不同设备间同步和访问文档。   代码块高亮 ：\nTypora 支持对代码块进行语法高亮显示，提高代码可读性和理解性。","level":3},{"id":"/tags/tools/typora#使用方法","title":"使用方法","titles":[],"content":"安装和启动 ：\n用户可以从 Typora 官网（  https://typora.io/）下载适用于自己操作系统的安装包，安装完成后即可启动  Typora。   编辑和预览 ：\n在 Typora 编辑界面中，左侧为 Markdown 文本编辑区域，右侧为实时预览区域，用户可以即时查看编辑后的文档效果。   导出文档 ：\n在编辑完成后，用户可以通过菜单或快捷键选择导出格式，将 Markdown 文档导出为 HTML、PDF 或其他格式。   自定义设置 ：\nTypora 允许用户自定义界面风格、主题和快捷键，以及其他编辑器的偏好设置，使得用户体验更加个性化。","level":3},{"id":"/tags/tools/typora#应用场景","title":"应用场景","titles":[],"content":"技术文档和博客 ：\n开发者和写作人员可以使用 Typora 编写和管理技术文档、博客文章等。   学术写作 ：\n学术界的研究人员和学生可以利用 Typora 编写论文、笔记和学术报告，支持数学公式的插入使其尤为适用。   团队协作 ：\n团队成员可以使用 Typora 共同编辑 Markdown 文档，并通过云同步功能实现文档的共享和访问。   个人笔记 ：\n个人用户可以使用 Typora 记录和管理日常笔记，通过标签、目录等功能进行组织和管理。","level":3},{"id":"/tags/tools/typora#总结","title":"总结","titles":[],"content":"Typora 是一款优秀的 Markdown 编辑器，结合其所见即所得的编辑模式、丰富的功能和跨平台支持，使得它成为许多用户首选的 Markdown 编辑工具。无论是写作、编辑、技术文档制作还是学术写作，Typora 都能提供高效、直观且愉悦的写作体验。","level":3}]