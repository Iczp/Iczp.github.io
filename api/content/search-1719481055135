[{"id":"/#安装","title":"安装","titles":[],"content":"安装依赖This page corresponds to the    route of your website. You can delete it or create another file in the    directory.Try to navigate to   about . These 2 pages are rendered by the    component.","level":2},{"id":"/#yamlyml","title":"Yaml/yml","titles":[],"content":"","level":2},{"id":"/docs/guide#指南","title":"指南","titles":[],"content":"","level":1},{"id":"/docs/wmsxwd#我们所向住的","title":"我们所向住的","titles":[],"content":"不好说...","level":2},{"id":"/about/about#vvllnetvite-vue-link-lab主要记录一些相关开发文档的资源和信息","title":"VVLL.net（Vite Vue Link Lab）主要记录一些相关开发文档的资源和信息。","titles":[],"content":"以下是该网站的主要内容和特点：Vite ：网站涵盖了关于 Vite 的开发文档和指南，介绍了 Vite 作为一个现代化的构建工具的特性和用法，帮助开发者快速了解和使用 Vite 进行项目开发。   Vue ：网站包含了关于 Vue.js 框架的开发文档和教程，涵盖了 Vue 的基础知识、组件开发、状态管理等方面的内容，帮助开发者掌握 Vue.js 的使用技巧。   Link Lab ：Link Lab 部分提供了有关前端开发中常用的链接、资源和工具，包括前端框架、UI 库、插件等相关内容，帮助开发者发现和使用与前端开发相关的资源。通过 VVLL.net，开发者可以获取关于 Vite、Vue 和前端开发相关的最新资讯、文档和教程，帮助他们更好地理解和应用这些技术，提升前端开发能力和效率。","level":2},{"id":"/about/pkg#以下是packagejson-的配置信息","title":"以下是  package.json  的配置信息","titles":[],"content":"如题","level":2},{"id":"/authors/iczp#iczpnet思源-10000intrycn","title":"IczpNet(思源) <10000#intry.cn>","titles":[],"content":"","level":1},{"id":"/authors/iczp#_1-域名","title":"1. 域名","titles":["IczpNet(思源) <10000#intry.cn>"],"content":"https://vvll.netq  ddd","level":3},{"id":"/authors/zhongpei#zhongpei心雨-10000intrycn","title":"Zhongpei(心雨) <10000#intry.cn>","titles":[],"content":"q  ddd","level":1},{"id":"/blog/regex#正则表达式手册regex","title":"正则表达式手册(Regex)","titles":[],"content":"正则表达式（Regular Expressions,简称 Regex）是一种用于匹配字符串的模式。它在文本处理、数据验证和提取等方面非常强大和灵活。以下是详细的 Regex 语法手册,并附有示例说明。","level":1},{"id":"/blog/regex#基本字符匹配","title":"基本字符匹配","titles":["正则表达式手册(Regex)"],"content":"字符 ：直接匹配字符本身。例如：\n     匹配字符串 \"a\"。    匹配字符串 \"abc\"。","level":3},{"id":"/blog/regex#元字符","title":"元字符","titles":["正则表达式手册(Regex)"],"content":"：匹配除换行符以外的任意单个字符。     匹配 \"aab\", \"acb\" 等。    ：转义字符,用于转义元字符,使其失去特殊意义。     匹配 \"a.b\"。","level":3},{"id":"/blog/regex#字符类","title":"字符类","titles":["正则表达式手册(Regex)"],"content":"：匹配方括号内的任意一个字符。     匹配 \"a\", \"b\", \"c\" 中的任意一个。    ：匹配不在方括号内的任意一个字符。     匹配除 \"a\", \"b\", \"c\" 以外的任意一个字符。   范围 ：在方括号内使用    指定字符范围。     匹配小写字母。    匹配数字。","level":3},{"id":"/blog/regex#预定义字符类","title":"预定义字符类","titles":["正则表达式手册(Regex)"],"content":"：匹配任何数字,相当于   。     匹配任何三位数字,如 \"123\"。    ：匹配任何非数字字符,相当于   。     匹配 \"a\", \"-\" 等非数字字符。    ：匹配任何字母、数字或下划线,相当于   。     匹配一个或多个字母、数字或下划线。    ：匹配任何非字母、数字或下划线字符,相当于   。     匹配 \"!\", \"@\" 等特殊字符。    ：匹配任何空白字符（包括空格、制表符、换行符等）。     匹配 \" \", \"\\t\" 等。    ：匹配任何非空白字符,相当于   。     匹配 \"a\", \"1\" 等非空白字符。","level":3},{"id":"/blog/regex#数量词","title":"数量词","titles":["正则表达式手册(Regex)"],"content":"：匹配前面的字符零次或多次。     匹配 \"\", \"a\", \"aa\" 等。    ：匹配前面的字符一次或多次。     匹配 \"a\", \"aa\" 等。    ：匹配前面的字符零次或一次。     匹配 \"\", \"a\"。    ：匹配前面的字符恰好 n 次。     匹配 \"aaa\"。    ：匹配前面的字符至少 n 次。     匹配 \"aa\", \"aaa\" 等。    ：匹配前面的字符至少 n 次,但不超过 m 次。     匹配 \"aa\", \"aaa\", \"aaaa\"。","level":3},{"id":"/blog/regex#边界匹配","title":"边界匹配","titles":["正则表达式手册(Regex)"],"content":"：匹配字符串的开始。     匹配以 \"abc\" 开头的字符串。    ：匹配字符串的结束。     匹配以 \"abc\" 结尾的字符串。    ：匹配单词边界。     匹配单词 \"word\"。    ：匹配非单词边界。     匹配 \"password\" 中的 \"word\"。","level":3},{"id":"/blog/regex#分组和引用","title":"分组和引用","titles":["正则表达式手册(Regex)"],"content":"：分组,用于提取子字符串或应用数量词。     匹配 \"abc\", \"abcabc\"。    ,   , ... ：反向引用,用于匹配之前的捕获组。     匹配 \"abab\"。","level":3},{"id":"/blog/regex#或匹配","title":"或匹配","titles":["正则表达式手册(Regex)"],"content":"：匹配左边或右边的字符。\n     匹配 \"a\" 或 \"b\"。","level":3},{"id":"/blog/regex#零宽断言","title":"零宽断言","titles":["正则表达式手册(Regex)"],"content":"：正向前瞻断言,要求接下来的字符与 ... 匹配,但不消耗这些字符。     匹配 \"a\" 仅当其后跟着 \"b\"。    ：负向前瞻断言,要求接下来的字符不与 ... 匹配。     匹配 \"a\" 仅当其后不跟着 \"b\"。    ：正向后瞻断言,要求前面的字符与 ... 匹配,但不消耗这些字符。     匹配 \"b\" 仅当其前面是 \"a\"。    ：负向后瞻断言,要求前面的字符不与 ... 匹配。     匹配 \"b\" 仅当其前面不是 \"a\"。","level":3},{"id":"/blog/regex#贪婪与懒惰匹配","title":"贪婪与懒惰匹配","titles":["正则表达式手册(Regex)"],"content":"贪婪匹配 ：尽可能多地匹配字符,默认行为。     匹配 \"a\" 开头和 \"b\" 结尾的最长字符串。   懒惰匹配 ：尽可能少地匹配字符,在量词后加    实现。     匹配 \"a\" 开头和 \"b\" 结尾的最短字符串。","level":3},{"id":"/blog/regex#示例汇总","title":"示例汇总","titles":["正则表达式手册(Regex)"],"content":"匹配邮箱地址 ：     解释：匹配类似 \"  example@example.com \" 的邮箱地址。   匹配电话号码 ：     解释：匹配类似 \"123-456-7890\" 的电话号码。   匹配日期（YYYY-MM-DD） ：     解释：匹配类似 \"2024-06-17\" 的日期格式。","level":3},{"id":"/notes/css/css-protips#css-专业技巧","title":"CSS 专业技巧","titles":[],"content":"https://github.com/AllThingsSmitty/css-protips/blob/master/translations/zh-CN/README.md一个帮你提升 CSS 技巧的收藏集。✅对于其他收藏集合可以查看   @sindresorhus  创建的收藏集合   Awesome Lists .","level":1},{"id":"/notes/css/css-protips#目录","title":"目录","titles":["CSS 专业技巧"],"content":"专业技巧   支持情况","level":2},{"id":"/notes/css/css-protips#专业技巧","title":"专业技巧","titles":["CSS 专业技巧"],"content":"CSS 专业技巧     目录   专业技巧    使用 CSS 复位    演示   继承      演示   使用  而不是重置所有属性   使用    选择器来决定表单是否显示边框    演示   检查字体是否在本地安裝   为    元素添加行高    演示   为表单元素设置     演示   垂直居中任何元素    演示   逗号分隔列表   使用负的    来选择元素    演示   使用 SVG 图标   使用 “形似猫头鹰” 的选择器    演示   使用    来建立纯 CSS 的滑块   创造格子等宽的表格    演示   利用 Flexbox 去除多余的外边距   利用属性选择器来选择空链接    演示   给 “默认” 链接定义样式   固定比例盒子    演示   为图裂定义样式   用    来调整全局大小；用    来调整局部大小   隐藏没有静音、自动播放的影片   使用选择器  灵活控制字体大小    演示   为更好的移动体验，为表单元素设置字体大小   使用指针事件来控制鼠标事件   在用作间距的换行符上设置    使用    隐藏空 HTML 元素   支持情况","level":2},{"id":"/notes/css/css-protips#使用-css-复位","title":"使用 CSS 复位","titles":["CSS 专业技巧","专业技巧"],"content":"CSS 复位可以在不同的浏览器上保持一致的样式风格。您可以使用 CSS reset 库  Normalize 等，也可以使用一个更简化的复位方法：现在元素的 margin 和 padding 已为 0，  可以管理您的 CSS 盒模型布局。","level":3},{"id":"/notes/css/css-protips#演示","title":"演示","titles":["CSS 专业技巧","专业技巧","使用 CSS 复位"],"content":"注意：如果你遵循接下来  继承   讲解的这个技巧, 你不需要在以上代码中添加    属性。回目录","level":4},{"id":"/notes/css/css-protips#继承-box-sizing","title":"继承   box-sizing","titles":["CSS 专业技巧","专业技巧"],"content":"从    元素继承    ：如此在插件或其它组件里改变    变得简单。","level":3},{"id":"/notes/css/css-protips#演示-1","title":"演示","titles":["CSS 专业技巧","专业技巧","继承   box-sizing"],"content":"回目录","level":4},{"id":"/notes/css/css-protips#使用unset而不是重置所有属性","title":"使用  unset 而不是重置所有属性","titles":["CSS 专业技巧","专业技巧"],"content":"重置元素的属性时，不需要重置每个单独的属性：你可以用  简写來指定所有元素的属性。 将该值设置为  会将元素的属性更改为其初始值：回目录","level":3},{"id":"/notes/css/css-protips#使用-not-选择器来决定表单是否显示边框","title":"使用   :not()  选择器来决定表单是否显示边框","titles":["CSS 专业技巧","专业技巧"],"content":"先为元素添加边框为最后一个元素去除边框不过不要这么做，使用    伪类来达到同样的效果：CSS 选择器以人类描述它的方式定义边界。","level":3},{"id":"/notes/css/css-protips#演示-2","title":"演示","titles":["CSS 专业技巧","专业技巧","使用   :not()  选择器来决定表单是否显示边框"],"content":"回目录","level":4},{"id":"/notes/css/css-protips#检查字体是否在本地安裝","title":"检查字体是否在本地安裝","titles":["CSS 专业技巧","专业技巧"],"content":"您可以在远程获取字体之前检查是否在本地安装了字体，这也是一个很好的性能提示。亚当·阿盖尔（Adam Argyle）的帽子技巧，分享了这个技巧和  例子 。回目录","level":3},{"id":"/notes/css/css-protips#为-body-元素添加行高","title":"为   body  元素添加行高","titles":["CSS 专业技巧","专业技巧"],"content":"不必为每一个   ，   元素逐一添加   ，直接添加到    元素：文本元素可以很容易地继承    的样式。","level":3},{"id":"/notes/css/css-protips#演示-3","title":"演示","titles":["CSS 专业技巧","专业技巧","为   body  元素添加行高"],"content":"回目录","level":4},{"id":"/notes/css/css-protips#为表单元素设置focus","title":"为表单元素设置  :focus","titles":["CSS 专业技巧","专业技巧"],"content":"有视力的键盘用戶依靠焦点来确定键盘事件在页面中的位置。 使表单元素的焦点脱颖而出，然后与浏览器的默认实现保持一致：","level":3},{"id":"/notes/css/css-protips#演示-4","title":"演示","titles":["CSS 专业技巧","专业技巧","为表单元素设置  :focus"],"content":"回目录","level":4},{"id":"/notes/css/css-protips#垂直居中任何元素","title":"垂直居中任何元素","titles":["CSS 专业技巧","专业技巧"],"content":"不！这绝不是黑魔法，真的可以垂直居中任何元素：...还有 CSS Grid:这还不够？垂直方向，水平方向？任何元素，任何时间，任何地点？CSS-Tricks   有篇好文  讲到了各种居中的技巧。","level":3},{"id":"/notes/css/css-protips#演示-5","title":"演示","titles":["CSS 专业技巧","专业技巧","垂直居中任何元素"],"content":"回目录","level":4},{"id":"/notes/css/css-protips#逗号分隔列表","title":"逗号分隔列表","titles":["CSS 专业技巧","专业技巧"],"content":"使列表的每项都由逗号分隔：因最后一项不加逗号，可以使用    伪类。注意：  这一技巧对于无障碍，特别是屏幕阅读器而言并不理想。而且复制粘贴并不会带走 CSS 生成的内容，需要注意。回目录","level":3},{"id":"/notes/css/css-protips#使用负的-nth-child-来选择元素","title":"使用负的   nth-child  来选择元素","titles":["CSS 专业技巧","专业技巧"],"content":"使用负的    可以选择 1 至 n 个元素。或许你已经掌握了  如何使用   这个技巧，试下这个：如此简单！","level":3},{"id":"/notes/css/css-protips#演示-6","title":"演示","titles":["CSS 专业技巧","专业技巧","使用负的   nth-child  来选择元素"],"content":"回目录","level":4},{"id":"/notes/css/css-protips#使用-svg-图标","title":"使用 SVG 图标","titles":["CSS 专业技巧","专业技巧"],"content":"没有理由不使用 SVG 图标：SVG 在所有分辨率下都可以良好缩放，并且支持所有   IE9  以后的浏览器，丢掉你的 .png，.jpg，或 .gif-jif-whatev 文件吧。注意：  针对仅有图标的按钮，如果 SVG 没有加载成功的话，以下样式对无障碍有所帮助：回目录","level":3},{"id":"/notes/css/css-protips#使用-形似猫头鹰-的选择器","title":"使用 “形似猫头鹰” 的选择器","titles":["CSS 专业技巧","专业技巧"],"content":"这个名字可能比较陌生，不过通用选择器 (  ) 和 相邻兄弟选择器 (  ) 一起使用，效果非凡：在此示例中，文档流中的所有的相邻兄弟元素将都将设置    的样式。更多 “形似猫头鹰” 的选择器，可参考   A List Apart  上面   Heydon Pickering 的文章","level":3},{"id":"/notes/css/css-protips#演示-7","title":"演示","titles":["CSS 专业技巧","专业技巧","使用 “形似猫头鹰” 的选择器"],"content":"回目录","level":4},{"id":"/notes/css/css-protips#使用-max-height-来建立纯-css-的滑块","title":"使用   max-height  来建立纯 CSS 的滑块","titles":["CSS 专业技巧","专业技巧"],"content":"与 overflow hidden 一起来建立纯 CSS 的滑块：鼠标移入滑块元素时增大它的    值，便可以显示溢出部分。回目录","level":3},{"id":"/notes/css/css-protips#创造格子等宽的表格","title":"创造格子等宽的表格","titles":["CSS 专业技巧","专业技巧"],"content":"可以让每个格子保持等宽：无痛的 table 布局。","level":3},{"id":"/notes/css/css-protips#演示-8","title":"演示","titles":["CSS 专业技巧","专业技巧","创造格子等宽的表格"],"content":"回目录","level":4},{"id":"/notes/css/css-protips#利用-flexbox-去除多余的外边距","title":"利用 Flexbox 去除多余的外边距","titles":["CSS 专业技巧","专业技巧"],"content":"与其使用   ，   ， 和    去除列之间多余的间隙，不如使用 flexbox 的    属性：列之间的间隙总是均匀相等。回目录","level":3},{"id":"/notes/css/css-protips#利用属性选择器来选择空链接","title":"利用属性选择器来选择空链接","titles":["CSS 专业技巧","专业技巧"],"content":"当    元素没有文本内容，但有    属性的时候，显示它的    属性：相当简便。","level":3},{"id":"/notes/css/css-protips#演示-9","title":"演示","titles":["CSS 专业技巧","专业技巧","利用属性选择器来选择空链接"],"content":"回目录","level":4},{"id":"/notes/css/css-protips#给-默认-链接定义样式","title":"给 “默认” 链接定义样式","titles":["CSS 专业技巧","专业技巧"],"content":"给 “默认” 链接定义样式：通过 CMS 系统插入的链接，通常没有    属性，以上样式可以甄别它们，而且不会影响其它样式。回目录","level":3},{"id":"/notes/css/css-protips#固定比例盒子","title":"固定比例盒子","titles":["CSS 专业技巧","专业技巧"],"content":"要创建具有固定比例的一个盒子，所有你需要做的就是给 div 的顶部或底部设置一个 padding：使用 20％ 的 padding-bottom 使得框等于其宽度的 20％ 的高度。与视口宽度无关，子元素的 div 将保持其宽高比（100％/ 20％= 5:1）。","level":3},{"id":"/notes/css/css-protips#演示-10","title":"演示","titles":["CSS 专业技巧","专业技巧","固定比例盒子"],"content":"回目录","level":4},{"id":"/notes/css/css-protips#为图裂定义样式","title":"为图裂定义样式","titles":["CSS 专业技巧","专业技巧"],"content":"只要一点 CSS 就可以美化破损的图片：以添加伪元素的法则来显示用户信息和 URL 的引用：了解更多关于这类样式的技巧   Ire Aderinokun  的   原帖 .回目录","level":3},{"id":"/notes/css/css-protips#用-rem-来调整全局大小用-em-来调整局部大小","title":"用   rem  来调整全局大小；用   em  来调整局部大小","titles":["CSS 专业技巧","专业技巧"],"content":"在根元素设置基本字体大小后 (  ), 使用    设置文本元素的字体大小:然后设置模块的字体大小为   :现在，每个模块变得独立，更容易、灵活的样式便于维护。回目录","level":3},{"id":"/notes/css/css-protips#隐藏没有静音自动播放的影片","title":"隐藏没有静音、自动播放的影片","titles":["CSS 专业技巧","专业技巧"],"content":"这是一个自定义用户样式表的不错的技巧。避免在加载页面时自动播放。如果没有静音，则不显示视频：再次，我们利用了     的优点。回目录","level":3},{"id":"/notes/css/css-protips#使用选择器root灵活控制字体大小","title":"使用选择器  :root 灵活控制字体大小","titles":["CSS 专业技巧","专业技巧"],"content":"在响应式布局中，字体大小应需要根据不同的视口进行调整。你可以计算字体大小根据视口高度的字体大小和宽度，这时需要用到  :现在，您可以使用","level":3},{"id":"/notes/css/css-protips#演示-11","title":"演示","titles":["CSS 专业技巧","专业技巧","使用选择器  :root 灵活控制字体大小"],"content":"回目录","level":4},{"id":"/notes/css/css-protips#为更好的移动体验为表单元素设置字体大小","title":"为更好的移动体验，为表单元素设置字体大小","titles":["CSS 专业技巧","专业技巧"],"content":"当触发  的下拉列表时，为了避免表单元素在移动浏览器（iOS Safari 和其它）上的缩放，加上  ：💃回目录","level":3},{"id":"/notes/css/css-protips#使用指针事件来控制鼠标事件","title":"使用指针事件来控制鼠标事件","titles":["CSS 专业技巧","专业技巧"],"content":"指针事件 允许您指定鼠标如何与其触摸的元素进行交互。 要禁用按钮上的默认指针事件，例如：就这么简单。回目录","level":3},{"id":"/notes/css/css-protips#在用作间距的换行符上设置display-none","title":"在用作间距的换行符上设置  display: none","titles":["CSS 专业技巧","专业技巧"],"content":"正如  Harry Roberts 指出 ，这有助于防止 CMS 用户使用额外的换行符回目录","level":3},{"id":"/notes/css/css-protips#使用-empty-隐藏空-html-元素","title":"使用   :empty  隐藏空 HTML 元素","titles":["CSS 专业技巧","专业技巧"],"content":"如果你有空的 HTML 元素，即内容尚未由 CMS 设置或动态注入（例如：  ）并且它会在你的布局上创建不需要的空间，使用    伪类隐藏布局上的元素。注意：请记住，带有空格的元素不会被视为空元素，例如   。回目录","level":3},{"id":"/notes/css/css-protips#支持情况","title":"支持情况","titles":["CSS 专业技巧","专业技巧"],"content":"这些技巧适用于最新版的 Chrome, Firefox, Safari, 以及 Edge。","level":3},{"id":"/notes/dotnet/iczp-nuget#iczpnet-nuget-包","title":"IczpNet Nuget 包","titles":[],"content":"https://www.nuget.org/packages?q=IczpNet","level":1},{"id":"/notes/dotnet/iczp-nuget#iczpnetabptrees","title":"IczpNet.AbpTrees","titles":["IczpNet Nuget 包"],"content":"An abp module that provides standard tree structure entity implement.","level":2},{"id":"/notes/dotnet/iczp-nuget#create-project-by-abp-cli","title":"Create project by Abp Cli","titles":["IczpNet Nuget 包","IczpNet.AbpTrees"],"content":"","level":3},{"id":"/notes/dotnet/iczp-nuget#build","title":"Build","titles":["IczpNet Nuget 包","IczpNet.AbpTrees"],"content":"https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-build","level":3},{"id":"/notes/dotnet/iczp-nuget#public-to-nugetorg","title":"Public to Nuget.org","titles":["IczpNet Nuget 包","IczpNet.AbpTrees"],"content":"Installation","level":3},{"id":"/notes/dotnet/iczp-nuget#install-the-following-nuget-packages-see-how","title":"Install the following NuGet packages. (see how)","titles":["IczpNet Nuget 包","IczpNet.AbpTrees","Public to Nuget.org"],"content":"IczpNet.AbpTrees.Domain  IczpNet.AbpTrees.Application  IczpNet.AbpTrees.Application.Contracts  IczpNet.AbpTrees.Domain.Shared","level":5},{"id":"/notes/dotnet/iczp-nuget#add-dependsontypeofabptreesxxxmodule-attribute-to-configure-the-module-dependencies","title":"Add   DependsOn(typeof(AbpTreesXxxModule))  attribute to configure the module dependencies.","titles":["IczpNet Nuget 包","IczpNet.AbpTrees","Public to Nuget.org"],"content":"","level":5},{"id":"/notes/dotnet/iczp-nuget#internal-structure","title":"Internal structure","titles":["IczpNet Nuget 包"],"content":"","level":2},{"id":"/notes/dotnet/iczp-nuget#iczpnetabptreesdomain","title":"IczpNet.AbpTrees.Domain","titles":["IczpNet Nuget 包","Internal structure"],"content":"","level":4},{"id":"/notes/dotnet/iczp-nuget#itreeentity","title":"ITreeEntity","titles":["IczpNet Nuget 包","Internal structure","IczpNet.AbpTrees.Domain"],"content":"","level":5},{"id":"/notes/dotnet/iczp-nuget#treeentity","title":"TreeEntity","titles":["IczpNet Nuget 包","Internal structure","IczpNet.AbpTrees.Domain"],"content":"","level":5},{"id":"/notes/dotnet/iczp-nuget#itreemanager","title":"ITreeManager","titles":["IczpNet Nuget 包","Internal structure","IczpNet.AbpTrees.Domain"],"content":"","level":5},{"id":"/notes/dotnet/iczp-nuget#treemanager","title":"TreeManager","titles":["IczpNet Nuget 包","Internal structure","IczpNet.AbpTrees.Domain"],"content":"","level":5},{"id":"/notes/dotnet/iczp-nuget#iczpnetabptreesapplicationcontracts","title":"IczpNet.AbpTrees.Application.Contracts","titles":["IczpNet Nuget 包","Internal structure","IczpNet.AbpTrees.Domain"],"content":"","level":4},{"id":"/notes/dotnet/iczp-nuget#itreeappservice","title":"ITreeAppService","titles":["IczpNet Nuget 包","Internal structure","IczpNet.AbpTrees.Domain","IczpNet.AbpTrees.Application.Contracts"],"content":"","level":5},{"id":"/notes/dotnet/iczp-nuget#dtos","title":"Dtos","titles":["IczpNet Nuget 包","Internal structure","IczpNet.AbpTrees.Domain"],"content":"","level":4},{"id":"/notes/dotnet/iczp-nuget#itreegetlistinput","title":"ITreeGetListInput","titles":["IczpNet Nuget 包","Internal structure","IczpNet.AbpTrees.Domain","Dtos"],"content":"","level":5},{"id":"/notes/dotnet/iczp-nuget#itreeinput","title":"ITreeInput","titles":["IczpNet Nuget 包","Internal structure","IczpNet.AbpTrees.Domain","Dtos"],"content":"","level":5},{"id":"/notes/dotnet/iczp-nuget#treegetlistinput","title":"TreeGetListInput","titles":["IczpNet Nuget 包","Internal structure","IczpNet.AbpTrees.Domain","Dtos"],"content":"","level":5},{"id":"/notes/dotnet/iczp-nuget#iczpnetabptreesapplication","title":"IczpNet.AbpTrees.Application","titles":["IczpNet Nuget 包","Internal structure","IczpNet.AbpTrees.Domain"],"content":"","level":4},{"id":"/notes/dotnet/iczp-nuget#treeappservice","title":"TreeAppService","titles":["IczpNet Nuget 包","Internal structure","IczpNet.AbpTrees.Domain","IczpNet.AbpTrees.Application"],"content":"","level":5},{"id":"/notes/dotnet/iczp-nuget#usage","title":"Usage","titles":["IczpNet Nuget 包"],"content":"https://github.com/Iczp/AbpTrees/tree/master/Example","level":2},{"id":"/notes/dotnet/iczp-nuget#create-a-entity","title":"Create a entity","titles":["IczpNet Nuget 包","Usage"],"content":"Create a entity     and implement   .","level":4},{"id":"/notes/dotnet/iczp-nuget#create-model","title":"Create Model","titles":["IczpNet Nuget 包","Usage"],"content":"Create    and implement    in project","level":4},{"id":"/notes/dotnet/iczp-nuget#repository","title":"Repository","titles":["IczpNet Nuget 包","Usage"],"content":"","level":4},{"id":"/notes/dotnet/iczp-nuget#create-dto","title":"Create Dto","titles":["IczpNet Nuget 包","Usage"],"content":"","level":4},{"id":"/notes/dotnet/iczp-nuget#interface-crud","title":"interface CRUD","titles":["IczpNet Nuget 包","Usage"],"content":"IDepartmentAppSevice and implement   ,","level":4},{"id":"/notes/dotnet/iczp-nuget#application-crud","title":"Application CRUD","titles":["IczpNet Nuget 包","Usage"],"content":"","level":4},{"id":"/notes/dotnet/iczp-nuget#dto-mapper","title":"Dto Mapper","titles":["IczpNet Nuget 包","Usage"],"content":"","level":4},{"id":"/notes/dotnet/iczp-nuget#add-migration-iczpnetabptreesdemohttpapihost","title":"Add-Migration   IczpNet.AbpTreesDemo.HttpApi.Host","titles":["IczpNet Nuget 包","Usage"],"content":"Select Project   , Set Run Start.  Open PM      Add Controller","level":4},{"id":"/notes/dotnet/iczp-nuget#run","title":"Run","titles":["IczpNet Nuget 包"],"content":"Set as Startup Project:   ConnectionStrings:     Set PM(Package Management Console) default Project:   add-migration and update database","level":2},{"id":"/notes/dotnet/iczp-nuget#upgrade-v1013add-property-childrencount","title":"Upgrade v1.0.13(Add Property ChildrenCount)","titles":["IczpNet Nuget 包","Run"],"content":"","level":4},{"id":"/notes/dotnet/push-nuget#在net-core-中发布包到-nuget-主要包含以下步骤","title":"在.NET Core 中发布包到 NuGet 主要包含以下步骤：","titles":[],"content":"","level":1},{"id":"/notes/dotnet/push-nuget#一准备工作","title":"一、准备工作","titles":["在.NET Core 中发布包到 NuGet 主要包含以下步骤："],"content":"在 NuGet 官方注册一个账号，或者直接使用微软账号登录。","level":2},{"id":"/notes/dotnet/push-nuget#二创建项目并生成-nuget-包","title":"二、创建项目并生成 NuGet 包","titles":["在.NET Core 中发布包到 NuGet 主要包含以下步骤："],"content":"创建一个类库项目。这通常是一个.NET Standard 或.NET Core 类库，确保项目的兼容性。  编写代码。实现你想要在 NuGet 包中提供的功能。  配置 NuGet 包信息。在项目文件中（通常是.csproj），你需要设置一些 NuGet 包的元数据，如包 ID、版本、作者、描述等。这些可以在  标签内设置，例如：生成 NuGet 包。在命令行中使用  命令来生成 NuGet 包。确保你在项目的根目录下运行此命令。这将生成一个.nupkg 文件，这就是你的 NuGet 包。","level":2},{"id":"/notes/dotnet/push-nuget#三上传发布到-nuget","title":"三、上传发布到 NuGet","titles":["在.NET Core 中发布包到 NuGet 主要包含以下步骤："],"content":"","level":2},{"id":"/notes/dotnet/push-nuget#","title":"","titles":["在.NET Core 中发布包到 NuGet 主要包含以下步骤："],"content":"上传 NuGet 包。使用 NuGet 的命令行工具  或者通过 NuGet 的官方网站来上传你的.nupkg 文件。如果你使用命令行工具，需要确保你已经安装了 NuGet CLI，并且已经登录到你的 NuGet 账号。其中，  是你的 NuGet 包文件名，  是 NuGet 的官方推送源，  是你在 NuGet 账号中生成的 API 密钥。等待后台处理。上传完成后，NuGet 会进行后台处理，包括验证包的有效性、扫描病毒等。处理完成后，你的包就会显示在 NuGet 的包列表中。  在 NuGet 或 Visual Studio 中查看和引用。你的包发布后，其他开发者就可以在 NuGet 官方网站搜索到你的包，并在他们的项目中进行引用。同时，在 Visual Studio 的 NuGet 包管理器中也可以搜索和安装你的包。","level":2},{"id":"/notes/dotnet/push-nuget#四参考","title":"四、参考","titles":["在.NET Core 中发布包到 NuGet 主要包含以下步骤："],"content":"","level":2},{"id":"/notes/git/git-repo/likes#github-常用仓库","title":"Github 常用仓库","titles":[],"content":"","level":2},{"id":"/notes/git/git-repo/likes#表格组件","title":"表格组件","titles":["Github 常用仓库"],"content":"","level":3},{"id":"/notes/git/git-repo/likes#wolf-table","title":"wolf-table","titles":["Github 常用仓库","表格组件"],"content":"A web-based(canvas) JavaScript Tablehttps://github.com/wolf-table/table","level":4},{"id":"/notes/git/git-repo/likes#web-skills","title":"web-skills","titles":["Github 常用仓库","表格组件"],"content":"https://github.com/andreasbm/web-skills","level":3},{"id":"/notes/git/git-repo/likes#css-tricks","title":"css-tricks","titles":["Github 常用仓库","表格组件"],"content":"https://css-tricks.com/","level":3},{"id":"/notes/git/git-repo/likes#awesome","title":"awesome","titles":["Github 常用仓库","表格组件"],"content":"https://github.com/sindresorhus/awesome","level":3},{"id":"/notes/git/git-repo/likes#shiki","title":"shiki","titles":["Github 常用仓库","表格组件"],"content":"https://github.com/shikijs/shiki  https://shiki.style/","level":3},{"id":"/notes/git/tutorial/basic#git-版本控制","title":"Git 版本控制","titles":[],"content":"Git 是一个分布式版本控制系统，可以帮助开发者管理代码的版本。以下是一个基本的 Git 教程，涵盖常见的命令和使用场景。","level":2},{"id":"/notes/git/tutorial/basic#安装-git","title":"安装 Git","titles":["Git 版本控制"],"content":"Windows : 可以从   Git for Windows  下载并安装。   macOS : 可以使用 Homebrew 安装：\n     Linux : 使用包管理器安装，例如在 Ubuntu 上：","level":3},{"id":"/notes/git/tutorial/basic#基本配置","title":"基本配置","titles":["Git 版本控制"],"content":"安装完成后，进行一些基本的配置：","level":3},{"id":"/notes/git/tutorial/basic#创建新的仓库","title":"创建新的仓库","titles":["Git 版本控制"],"content":"初始化一个新的 Git 仓库 ：\n     克隆一个现有的仓库 ：","level":3},{"id":"/notes/git/tutorial/basic#基本操作","title":"基本操作","titles":["Git 版本控制"],"content":"查看仓库状态 ：     添加文件到暂存区 ：    添加所有文件：     提交更改 ：     查看提交历史 ：","level":3},{"id":"/notes/git/tutorial/basic#分支操作","title":"分支操作","titles":["Git 版本控制"],"content":"创建新分支 ：     切换分支 ：     合并分支 ：\n首先切换到目标分支（例如   ），然后执行：     删除分支 ：","level":3},{"id":"/notes/git/tutorial/basic#远程操作","title":"远程操作","titles":["Git 版本控制"],"content":"查看远程仓库 ：     添加远程仓库 ：     推送到远程仓库 ：    第一次推送    分支：     从远程仓库拉取更新 ：","level":3},{"id":"/notes/git/tutorial/basic#常见操作示例","title":"常见操作示例","titles":["Git 版本控制"],"content":"创建一个新的仓库并推送到 GitHub ：     从 GitHub 克隆一个仓库并创建新分支 ：这些基本操作和命令应该可以帮助你开始使用 Git。如果需要更详细的信息，可以参考   Pro Git 书  或 Git 官方文档。","level":3},{"id":"/notes/git/tutorial/gitignore#gitignore-文件的详细说明","title":".gitignore  文件的详细说明","titles":[],"content":"文件用于告诉 Git 哪些文件或目录不应该被版本控制。以下是    文件的详细说明和一些常见的使用示例。","level":2},{"id":"/notes/git/tutorial/gitignore#基本语法","title":"基本语法","titles":[".gitignore  文件的详细说明"],"content":"注释 ：以    开头的行是注释。     忽略文件 ：直接写文件名或路径。     忽略目录 ：在目录名后面加上   。     通配符 ：     匹配零个或多个字符。    匹配单个字符。    匹配方括号内的任意一个字符。     递归匹配 ：用    表示递归匹配所有子目录。     取反 ：在规则前加    表示例外规则。","level":3},{"id":"/notes/git/tutorial/gitignore#常见示例","title":"常见示例","titles":[".gitignore  文件的详细说明"],"content":"","level":3},{"id":"/notes/git/tutorial/gitignore#一般用途","title":"一般用途","titles":[".gitignore  文件的详细说明","常见示例"],"content":"","level":4},{"id":"/notes/git/tutorial/gitignore#python-项目","title":"Python 项目","titles":[".gitignore  文件的详细说明","常见示例"],"content":"","level":4},{"id":"/notes/git/tutorial/gitignore#java-项目","title":"Java 项目","titles":[".gitignore  文件的详细说明","常见示例"],"content":"","level":4},{"id":"/notes/git/tutorial/gitignore#nodejs-项目","title":"Node.js 项目","titles":[".gitignore  文件的详细说明","常见示例"],"content":"","level":4},{"id":"/notes/git/tutorial/gitignore#创建-gitignore-文件","title":"创建 .gitignore 文件","titles":[".gitignore  文件的详细说明","常见示例"],"content":"在项目根目录创建    文件 ：     打开    文件并添加需要忽略的文件和目录 。   保存    文件并提交更改 ：","level":3},{"id":"/notes/git/tutorial/gitignore#在线生成-gitignore-文件","title":"在线生成   .gitignore  文件","titles":[".gitignore  文件的详细说明","常见示例"],"content":"可以使用   gitignore.io  网站，根据项目类型生成    文件。输入项目类型如   ,   ,    等，即可生成相应的    内容。希望这些信息能帮助你更好地使用    文件来管理项目中的文件和目录。","level":3},{"id":"/notes/hybrid/clipboard#剪切版clipboard的使用","title":"剪切版(Clipboard)的使用","titles":[],"content":"","level":1},{"id":"/notes/hybrid/clipboard#vueuse","title":"Vueuse","titles":["剪切版(Clipboard)的使用"],"content":"https://vueuse.org/core/useClipboard/#useclipboard","level":2},{"id":"/notes/hybrid/clipboard#组件使用","title":"组件使用","titles":["剪切版(Clipboard)的使用"],"content":"该函数还通过包提供了无渲染组件版本@vueuse/components。详细了解用法。","level":2},{"id":"/notes/hybrid/icon#图标","title":"图标","titles":[],"content":"","level":2},{"id":"/notes/hybrid/icon#trees","title":"Trees","titles":["图标"],"content":"Trees","level":3},{"id":"/notes/hybrid/icon#trees-1","title":"Trees-1","titles":["图标","Trees"],"content":"Trees-1","level":4},{"id":"/notes/js/dayjs#安装","title":"安装","titles":[],"content":"可以通过 npm 或 yarn 安装 Day.js：或者","level":3},{"id":"/notes/js/dayjs#基本用法","title":"基本用法","titles":[],"content":"以下是 Day.js 的一些基本用法示例：","level":3},{"id":"/notes/js/dayjs#导入-dayjs","title":"导入 Day.js","titles":["基本用法"],"content":"","level":4},{"id":"/notes/js/dayjs#获取当前日期和时间","title":"获取当前日期和时间","titles":["基本用法"],"content":"","level":4},{"id":"/notes/js/dayjs#解析日期","title":"解析日期","titles":["基本用法"],"content":"","level":4},{"id":"/notes/js/dayjs#格式化日期","title":"格式化日期","titles":["基本用法"],"content":"","level":4},{"id":"/notes/js/dayjs#操作日期","title":"操作日期","titles":["基本用法"],"content":"","level":4},{"id":"/notes/js/dayjs#比较日期","title":"比较日期","titles":["基本用法"],"content":"","level":4},{"id":"/notes/js/dayjs#使用插件","title":"使用插件","titles":["基本用法","比较日期"],"content":"Day.js 提供了多种插件，可以扩展其功能。使用插件前需要加载并使用它们。","level":3},{"id":"/notes/js/dayjs#加载插件","title":"加载插件","titles":["基本用法","比较日期","使用插件"],"content":"","level":4},{"id":"/notes/js/dayjs#常用插件","title":"常用插件","titles":["基本用法","比较日期","使用插件"],"content":"Advanced Format : 提供更多的日期格式化选项。   Relative Time : 支持相对时间显示（如 \"3 hours ago\"）。   UTC : 提供 UTC 时间支持。   Timezone : 提供时区支持。   Duration : 提供时间间隔的支持。","level":4},{"id":"/notes/js/dayjs#示例","title":"示例","titles":["基本用法","比较日期"],"content":"","level":3},{"id":"/notes/js/dayjs#使用-advanced-format-插件","title":"使用 Advanced Format 插件","titles":["基本用法","比较日期","示例"],"content":"","level":4},{"id":"/notes/js/dayjs#使用-utc-插件","title":"使用 UTC 插件","titles":["基本用法","比较日期","示例"],"content":"","level":4},{"id":"/notes/js/dayjs#使用-timezone-插件","title":"使用 Timezone 插件","titles":["基本用法","比较日期","示例"],"content":"","level":4},{"id":"/notes/js/dayjs#注意事项","title":"注意事项","titles":["基本用法","比较日期"],"content":"Day.js 默认是不可变的，这意味着每次操作都会返回一个新的 Day.js 对象，而不是修改原来的对象。  Day.js 不支持本地化的时间差（  ），可以使用插件来实现这类功能。Day.js 提供了丰富的功能和灵活的插件机制，使其成为处理日期和时间的强大工具，同时保持了库的轻量级和高性能。","level":3},{"id":"/notes/nodejs/npm-template#发布包到-npm-使用以库或模板来简化流程","title":"发布包到 npm 使用以库或模板来简化流程","titles":[],"content":"发布包到 npm，可以使用以下库或模板来简化流程：","level":2},{"id":"/notes/nodejs/npm-template#库","title":"库","titles":["发布包到 npm 使用以库或模板来简化流程"],"content":"np   一个简化 npm 发布流程的工具。  地址：  np   semantic-release   自动化的版本管理和发布工具，适用于持续集成环境。  地址：  semantic-release   release-it   一个命令行工具，用于在发布时处理版本控制、打包和发布。  地址：  release-it","level":3},{"id":"/notes/nodejs/npm-template#模板","title":"模板","titles":["发布包到 npm 使用以库或模板来简化流程"],"content":"npm-package-template   一个包含基本配置的 npm 包模板，适用于快速启动新项目。  地址：  npm-package-template   typescript-npm-package-template   一个适用于 TypeScript 项目的 npm 包模板，包含 TypeScript 配置、测试和打包脚本。  地址：  typescript-npm-package-template   create-ts-lib   一个用于创建 TypeScript 库的脚手架工具，配置良好并包含最佳实践。  地址：  create-ts-lib","level":3},{"id":"/notes/nodejs/npm-template#发布流程简述","title":"发布流程简述","titles":["发布包到 npm 使用以库或模板来简化流程"],"content":"初始化项目     开发和测试代码   使用上述模板之一初始化项目结构和配置。  编写代码和单元测试。   配置发布工具   使用   、   或    进行版本管理和发布。   发布到 npm使用这些库和模板可以极大简化发布 npm 包的流程，并确保发布过程的一致性和质量。","level":3},{"id":"/notes/nodejs/publish#发布-npm-包","title":"发布 NPM 包","titles":[],"content":"发布 NPM 包","level":1},{"id":"/notes/nodejs/publish#发布流程","title":"发布流程","titles":["发布 NPM 包"],"content":"注册账号    登录账号    创建项目    发布项目","level":2},{"id":"/notes/nodejs/publish#注册账号","title":"注册账号","titles":["发布 NPM 包"],"content":"","level":2},{"id":"/notes/nodejs/publish#测试","title":"测试","titles":["发布 NPM 包","注册账号"],"content":"","level":3},{"id":"/notes/nuxt/nuxt-tailwind#nuxt3-中使用-tailwind-css","title":"Nuxt3 中使用 Tailwind CSS","titles":[],"content":"创建项目 如果您尚未设置 Nuxt 项目，请先创建一个新的 Nuxt 项目。最常见的方法是使用  Nuxt 命令行界面 。  终端     安装 Tailwind CSS 通过 npm 安装  及其对等依赖项，然后运行 init 命令生成文件  。  终端     将 Tailwind 添加到你的 PostCSS 配置中 将  和添加  到文件中的对象。         配置模板路径 在您的文件中添加所有模板文件的路径   。       将 Tailwind 指令添加到你的 CSS 创建一个  文件并   为 Tailwind 的每个层添加指令。  主.css     全局添加 CSS 文件 将新创建的内容添加  到文件  中的数组中  。       开始构建过程 使用 运行您的构建过程  。  终端     开始在你的项目中使用 Tailwind 开始使用 Tailwind 的实用程序类来设置您的内容样式。","level":1},{"id":"/notes/tools/ai#_1-语言模型和对话系统","title":"1. 语言模型和对话系统","titles":[],"content":"OpenAI : GPT-4, ChatGPT   Google : Bard (基于 LaMDA), Google Assistant   Microsoft : Azure OpenAI Service (整合 OpenAI 的模型), Cortana   Amazon : Alexa   Apple : Siri","level":3},{"id":"/notes/tools/ai#_2-计算机视觉","title":"2. 计算机视觉","titles":[],"content":"NVIDIA : DeepStream SDK, Jetson 设备   Google : Google Cloud Vision AI   Microsoft : Azure Computer Vision   IBM : Watson Visual Recognition   Clarifai : AI 平台专注于图像和视频分析","level":3},{"id":"/notes/tools/ai#_3-语音识别和生成","title":"3. 语音识别和生成","titles":[],"content":"Google : Google Cloud Speech-to-Text, Google Text-to-Speech   Microsoft : Azure Speech Service   Amazon : Transcribe, Polly   IBM : Watson Speech to Text, Text to Speech   Nuance Communications : Dragon NaturallySpeaking","level":3},{"id":"/notes/tools/ai#_4-推荐系统","title":"4. 推荐系统","titles":[],"content":"Netflix : 内容推荐算法   Spotify : 音乐推荐系统   Amazon : 商品推荐引擎   YouTube : 视频推荐系统   Alibaba : 电子商务推荐系统","level":3},{"id":"/notes/tools/ai#_5-自动驾驶和辅助驾驶","title":"5. 自动驾驶和辅助驾驶","titles":[],"content":"Tesla : Autopilot, Full Self-Driving (FSD)   Waymo : Waymo Driver   NVIDIA : Drive AI 平台   Uber ATG : 自动驾驶技术（已被 Aurora 收购）   Baidu : Apollo 自动驾驶平台","level":3},{"id":"/notes/tools/ai#_6-医疗健康-ai","title":"6. 医疗健康 AI","titles":[],"content":"IBM Watson Health : 医疗诊断和治疗建议   Google Health : 基于 AI 的医疗研究和产品   Philips : HealthSuite AI   Butterfly Network : AI 超声波成像   Zebra Medical Vision : 医疗影像分析","level":3},{"id":"/notes/tools/ai#_7-金融科技-ai","title":"7. 金融科技 AI","titles":[],"content":"Kensho : 数据分析和金融市场预测   Numerai : 对冲基金数据科学竞赛平台   Zest AI : 信用评分和风险管理   Affirm : AI 驱动的贷款和信用服务   Sentifi : 金融市场情绪分析","level":3},{"id":"/notes/tools/ai#_8-工业和制造业-ai","title":"8. 工业和制造业 AI","titles":[],"content":"Siemens : MindSphere AI 平台   GE : Predix 平台   IBM : Maximo AI 资产管理   Rockwell Automation : FactoryTalk Analytics   Uptake : 工业数据分析平台","level":3},{"id":"/notes/tools/ai#_9-教育和学习-ai","title":"9. 教育和学习 AI","titles":[],"content":"Coursera : 个性化学习推荐   Duolingo : AI 驱动的语言学习   Khan Academy : 自适应学习平台   Quizlet : 学习辅助工具   Squirrel AI : 自适应学习系统","level":3},{"id":"/notes/tools/ai#_10-安全和监控-ai","title":"10. 安全和监控 AI","titles":[],"content":"Darktrace : 网络安全 AI   CrowdStrike : 网络威胁检测和响应   Securonix : 安全信息和事件管理 (SIEM)   Verkada : 智能监控摄像头   Clearview AI : 面部识别技术（有争议）","level":3},{"id":"/notes/tools/ai#总结","title":"总结","titles":[],"content":"市场上的 AI 产品和技术覆盖了广泛的应用领域，从语言处理和计算机视觉到医疗、金融、工业和教育等各个方面。每个领域都有一些领先的公司和产品，通过不断创新和优化，推动着 AI 技术的发展和普及。这些技术的应用不仅提高了各行各业的效率和质量，也在改变着我们的生活方式。","level":3},{"id":"/notes/tools/colors-generator#tailwind-css-颜色生成器","title":"Tailwind CSS 颜色生成器","titles":[],"content":"Tailwind CSS Color Generator   https://uicolors.app/","level":2},{"id":"/notes/tools/img2svg#图片转-svg","title":"图片转 Svg","titles":[],"content":"https://picsvg.com/","level":2},{"id":"/notes/tools/img2svg#png-to-svg","title":"Png to SVG","titles":[],"content":"https://www.pngtosvg.com/","level":2},{"id":"/notes/tools/svg2img#svg-转图片-png","title":"SVG 转图片 PNG","titles":[],"content":"https://svgtopng.com/zh/SVG 的优点和缺点\n在网络上使用 SVG 图像有很多优点。 它们与分辨率无关，这意味着它们可以被缩放到任何尺寸而不损失质量。 由于 SVG 是由 W3C 开发的开放标准，现代浏览器，如 Mozilla Firefox、Opera、Apple Safari 和 Google Chrome，可以原生显示这些类型的图像。 另外，如前所述，它们可以以任何分辨率打印，并可以用矢量设计工具进行编辑。但是，使用 SVG 格式也有一些缺点。 它的支持没有光栅图像格式那么广泛，这意味着虽然现代浏览器可以显示 SVG 图像，但旧的浏览器可能无法显示。 不同的开发平台和库可能对 SVG 功能有不同的解释，甚至对 SVG 的支持非常有限，甚至没有。 另外，SVG 不能用于有很多细节的复杂图像，比如照片。","level":1},{"id":"/notes/ts/array/includes#typescript-中的数组-arrayprototypeincludes-方法","title":"TypeScript 中的数组 Array.prototype.includes 方法","titles":[],"content":"Array.prototype.includes 方法用于判断数组是否包含某个指定的值，返回一个布尔值。它是 ES2016 引入的一部分，TypeScript 支持这一特性。在 TypeScript 中，   方法用于判断数组是否包含某个指定的值，返回一个布尔值。它是 ES2016 引入的一部分，TypeScript 支持这一特性。以下是    方法的详细用法介绍：","level":2},{"id":"/notes/ts/array/includes#基本语法","title":"基本语法","titles":["TypeScript 中的数组 Array.prototype.includes 方法"],"content":"：需要在数组中搜索的元素。     (可选)：开始搜索的索引位置。如果未提供，默认从数组的第一个元素开始。","level":3},{"id":"/notes/ts/array/includes#返回值","title":"返回值","titles":["TypeScript 中的数组 Array.prototype.includes 方法"],"content":"如果数组中包含指定的元素，返回   ，否则返回   。","level":3},{"id":"/notes/ts/array/includes#示例","title":"示例","titles":["TypeScript 中的数组 Array.prototype.includes 方法"],"content":"","level":3},{"id":"/notes/ts/array/includes#简单示例","title":"简单示例","titles":["TypeScript 中的数组 Array.prototype.includes 方法","示例"],"content":"","level":4},{"id":"/notes/ts/array/includes#从指定索引位置开始搜索","title":"从指定索引位置开始搜索","titles":["TypeScript 中的数组 Array.prototype.includes 方法","示例"],"content":"","level":4},{"id":"/notes/ts/array/includes#搜索对象","title":"搜索对象","titles":["TypeScript 中的数组 Array.prototype.includes 方法","示例"],"content":"注意：   方法使用的是严格相等（  ）比较。因此，对于对象类型的数组，   方法检查的是引用相等。","level":4},{"id":"/notes/ts/array/includes#在-typescript-中的类型检查","title":"在 TypeScript 中的类型检查","titles":["TypeScript 中的数组 Array.prototype.includes 方法","示例"],"content":"TypeScript 会根据数组的类型自动推断    方法的参数类型。如果传入不匹配的类型，TypeScript 编译器会报错。","level":3},{"id":"/notes/ts/array/includes#使用-includes-方法处理联合类型数组","title":"使用   includes  方法处理联合类型数组","titles":["TypeScript 中的数组 Array.prototype.includes 方法","示例"],"content":"如果数组的类型是联合类型，   方法可以检查所有可能的类型。","level":3},{"id":"/notes/ts/array/includes#总结","title":"总结","titles":["TypeScript 中的数组 Array.prototype.includes 方法","示例"],"content":"方法在 TypeScript 中非常有用，用于检查数组是否包含某个元素，并且它支持类型检查和类型推断。通过了解其用法，可以在开发中更方便地处理数组包含关系的判断。","level":3},{"id":"/notes/ts/array/to-dictionary#typescript-中的数组转换成对象字典","title":"TypeScript 中的数组转换成对象字典","titles":[],"content":"将 TypeScript 中的数组转换成对象字典，可以通过遍历数组并根据需要将每个元素映射到对象的键值对来实现。下面是一个示例代码，将数组转换为对象字典：假设有一个数组   ，每个元素是一个用户对象，具有    和    属性。我们将这个数组转换为一个以    为键，用户对象为值的字典。输出结果：在这个示例中，我们使用    方法遍历数组，并将每个用户对象添加到字典中。   的初始值是一个空对象   ，类型是   。如果键是字符串类型，可以相应地调整类型定义：这样可以根据数组中的数据创建一个对象字典，并可以通过指定的键快速查找值。","level":1},{"id":"/notes/ts/book/basic-types#基础类型","title":"基础类型","titles":[],"content":"TypeScript 提供了一组丰富的基本类型，这些类型帮助我们在编写代码时获得更好的类型检查和代码补全。以下是 TypeScript 的一些基础类型及其用法示例。","level":2},{"id":"/notes/ts/book/basic-types#_1-布尔值-boolean","title":"1. 布尔值 (boolean)","titles":["基础类型"],"content":"布尔值类型表示逻辑值：   或   。","level":3},{"id":"/notes/ts/book/basic-types#_2-数字-number","title":"2. 数字 (number)","titles":["基础类型"],"content":"和 JavaScript 一样，TypeScript 中所有的数字都是浮点数。TypeScript 支持十进制、十六进制、二进制和八进制字面量。","level":3},{"id":"/notes/ts/book/basic-types#_3-字符串-string","title":"3. 字符串 (string)","titles":["基础类型"],"content":"表示文本数据的类型。可以使用双引号 (  ) 或单引号 (  ) 表示字符串。还支持模板字符串，它可以跨行并且嵌入表达式。","level":3},{"id":"/notes/ts/book/basic-types#_4-数组-array","title":"4. 数组 (array)","titles":["基础类型"],"content":"可以用两种方式定义数组。第一种方式，可以在元素类型后面接上   。第二种方式是使用泛型数组类型，  。","level":3},{"id":"/notes/ts/book/basic-types#_5-元组-tuple","title":"5. 元组 (tuple)","titles":["基础类型"],"content":"元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。访问已知索引的元素会得到正确的类型：","level":3},{"id":"/notes/ts/book/basic-types#_6-枚举-enum","title":"6. 枚举 (enum)","titles":["基础类型"],"content":"枚举类型用于定义一组命名的常量。TypeScript 提供了数字枚举和字符串枚举。默认情况下，从    开始为元素编号。可以手动更改成员的值。","level":3},{"id":"/notes/ts/book/basic-types#_7-any","title":"7. Any","titles":["基础类型"],"content":"类型是为了那些在编程阶段还不清楚类型的变量而设计的。使用    类型，可以跳过类型检查。","level":3},{"id":"/notes/ts/book/basic-types#_8-unknown","title":"8. Unknown","titles":["基础类型"],"content":"类型是 TypeScript 3.0 中引入的，它表示类型不确定的值。与    不同，   类型只能在确定其类型后才能进行操作。","level":3},{"id":"/notes/ts/book/basic-types#_9-void","title":"9. Void","titles":["基础类型"],"content":"某种程度上来说，   类型像是与    类型相反，它表示没有任何类型。通常用于表示函数没有返回值。","level":3},{"id":"/notes/ts/book/basic-types#_10-null-和-undefined","title":"10. Null 和 Undefined","titles":["基础类型"],"content":"TypeScript 里，   和    有自己的类型分别叫做    和   。默认情况下，这两种类型是所有类型的子类型。也就是说，你可以把    和    赋值给其他类型的变量。","level":3},{"id":"/notes/ts/book/basic-types#_11-never","title":"11. Never","titles":["基础类型"],"content":"类型表示的是那些永不存在的值的类型。例如，那些总是会抛出异常或根本不会有返回值的函数表达式或箭头函数表达式的返回值类型。","level":3},{"id":"/notes/ts/book/basic-types#_12-object","title":"12. Object","titles":["基础类型"],"content":"表示非原始类型，也就是除   ，  ，  ，  ，   或    之外的类型。","level":3},{"id":"/notes/ts/book/basic-types#总结","title":"总结","titles":["基础类型"],"content":"这些基本类型构成了 TypeScript 类型系统的基础。通过理解和使用这些基本类型，可以编写更安全、更健壮的代码。在实际开发中，TypeScript 的类型系统能够帮助你捕获许多潜在的错误，并提高代码的可维护性和可读性。","level":3},{"id":"/notes/ts/book/basic-types#参考","title":"参考","titles":["基础类型"],"content":"https://www.typescriptlang.org/docs/handbook/2/basic-types.html","level":3},{"id":"/notes/ts/book/variable-declarations#变量声明","title":"变量声明","titles":[],"content":"在 TypeScript 中，变量的声明和作用域规则与 JavaScript 相似，但增加了一些额外的类型检查和语法糖。下面详细介绍 TypeScript 的变量声明、作用域规则、捕获变量的怪异之处、块作用域、重定义及屏蔽、块级作用域变量的获取等内容。","level":2},{"id":"/notes/ts/book/variable-declarations#_1-变量声明","title":"1. 变量声明","titles":["变量声明"],"content":"TypeScript 支持   、   和    三种变量声明方式。","level":3},{"id":"/notes/ts/book/variable-declarations#var-声明","title":"var 声明","titles":["变量声明","1. 变量声明"],"content":"声明的变量具有函数作用域或全局作用域。","level":4},{"id":"/notes/ts/book/variable-declarations#let-声明","title":"let 声明","titles":["变量声明","1. 变量声明"],"content":"声明的变量具有块级作用域，避免了    变量声明带来的一些问题。","level":4},{"id":"/notes/ts/book/variable-declarations#const-声明","title":"const 声明","titles":["变量声明","1. 变量声明"],"content":"声明的是常量，必须初始化且不可重新赋值。它也是块级作用域。","level":4},{"id":"/notes/ts/book/variable-declarations#_2-作用域规则","title":"2. 作用域规则","titles":["变量声明","1. 变量声明"],"content":"TypeScript 中的作用域规则分为全局作用域、函数作用域和块级作用域。","level":3},{"id":"/notes/ts/book/variable-declarations#全局作用域","title":"全局作用域","titles":["变量声明","1. 变量声明","2. 作用域规则"],"content":"在最外层定义的变量具有全局作用域。","level":4},{"id":"/notes/ts/book/variable-declarations#函数作用域","title":"函数作用域","titles":["变量声明","1. 变量声明","2. 作用域规则"],"content":"在函数内部定义的变量具有函数作用域，只在函数内部可见。","level":4},{"id":"/notes/ts/book/variable-declarations#块级作用域","title":"块级作用域","titles":["变量声明","1. 变量声明","2. 作用域规则"],"content":"用    或    声明的变量在块级作用域内可见。","level":4},{"id":"/notes/ts/book/variable-declarations#_3-捕获变量的怪异之处","title":"3. 捕获变量的怪异之处","titles":["变量声明","1. 变量声明"],"content":"在 JavaScript 中，   声明的变量有变量提升和函数作用域，这可能导致一些意想不到的行为。使用    可以避免这个问题，因为它具有块级作用域。","level":3},{"id":"/notes/ts/book/variable-declarations#_4-重定义及屏蔽","title":"4. 重定义及屏蔽","titles":["变量声明","1. 变量声明"],"content":"在 TypeScript 中，可以重定义同一作用域内的变量，这可能导致意想不到的行为。使用    或    可以避免这种情况。","level":3},{"id":"/notes/ts/book/variable-declarations#_5-块级作用域变量的获取","title":"5. 块级作用域变量的获取","titles":["变量声明","1. 变量声明"],"content":"在嵌套的块级作用域中，内层作用域可以访问外层作用域的变量。在块级作用域中，如果内层作用域中有与外层作用域同名的变量，内层变量会屏蔽外层变量。","level":3},{"id":"/notes/ts/book/variable-declarations#_6-使用闭包捕获变量","title":"6. 使用闭包捕获变量","titles":["变量声明","1. 变量声明"],"content":"在使用闭包时，要特别注意变量的捕获方式。可以通过立即执行函数表达式（IIFE）来创建新的作用域，以捕获每次迭代的变量。","level":3},{"id":"/notes/ts/book/variable-declarations#总结","title":"总结","titles":["变量声明","1. 变量声明"],"content":"TypeScript 的变量声明和作用域规则提供了更严格的类型检查和更明确的作用域控制，避免了许多 JavaScript 中常见的问题。通过理解和使用这些规则，可以编写更可靠和可维护的代码。","level":3},{"id":"/notes/ts/book/variable-declarations#参考","title":"参考","titles":["变量声明","1. 变量声明"],"content":"https://www.typescriptlang.org/docs/handbook/variable-declarations.html","level":3},{"id":"/notes/ts/book/variable-deconstruction#变量解构","title":"变量解构","titles":[],"content":"在 TypeScript 中，变量解构是一种简洁的语法，允许从数组或对象中提取值，并将其赋值给变量。解构可以提高代码的可读性和可维护性。以下是 TypeScript 中变量解构的详细介绍，包括数组解构、对象解构、解构赋值中的默认值、嵌套解构和函数参数解构。","level":2},{"id":"/notes/ts/book/variable-deconstruction#_1-数组解构","title":"1. 数组解构","titles":["变量解构"],"content":"数组解构允许你将数组中的元素解构为变量。你还可以跳过某些元素：数组解构也支持使用剩余变量收集其余元素：","level":3},{"id":"/notes/ts/book/variable-deconstruction#_2-对象解构","title":"2. 对象解构","titles":["变量解构"],"content":"对象解构允许你将对象的属性解构为变量。你也可以使用不同的变量名来解构对象的属性：","level":3},{"id":"/notes/ts/book/variable-deconstruction#_3-默认值","title":"3. 默认值","titles":["变量解构"],"content":"在解构过程中，你可以为变量指定默认值，当属性未定义时使用默认值。同样，数组解构也支持默认值：","level":3},{"id":"/notes/ts/book/variable-deconstruction#_4-嵌套解构","title":"4. 嵌套解构","titles":["变量解构"],"content":"对象和数组中嵌套的属性也可以解构。","level":3},{"id":"/notes/ts/book/variable-deconstruction#_5-函数参数解构","title":"5. 函数参数解构","titles":["变量解构"],"content":"解构可以用于函数参数，这样可以直接从参数中提取需要的属性或元素。","level":3},{"id":"/notes/ts/book/variable-deconstruction#数组解构","title":"数组解构","titles":["变量解构","5. 函数参数解构"],"content":"","level":4},{"id":"/notes/ts/book/variable-deconstruction#对象解构","title":"对象解构","titles":["变量解构","5. 函数参数解构"],"content":"","level":4},{"id":"/notes/ts/book/variable-deconstruction#示例","title":"示例","titles":["变量解构","5. 函数参数解构"],"content":"以下是一个综合示例，演示如何在函数参数中使用对象解构和默认值：","level":3},{"id":"/notes/ts/book/variable-deconstruction#_6-结合类型和接口","title":"6. 结合类型和接口","titles":["变量解构","5. 函数参数解构"],"content":"使用 TypeScript 类型和接口与解构结合，可以更好地保证类型安全。","level":3},{"id":"/notes/ts/book/variable-deconstruction#总结","title":"总结","titles":["变量解构","5. 函数参数解构"],"content":"TypeScript 的解构赋值使得从数组和对象中提取数据变得更加简洁和清晰。通过使用解构赋值，可以编写更加简洁和具可读性的代码，尤其是在处理复杂数据结构时。此外，结合 TypeScript 的类型系统，解构赋值不仅提供了简洁的语法，还保证了类型安全。","level":3},{"id":"/notes/ts/book/interface#interface","title":"interface","titles":[],"content":"在 TypeScript 中，接口（  ）用于定义对象的结构类型。接口是一个关键的概念，它帮助你定义对象的类型和形状，从而使代码更易于理解和维护。下面详细介绍 TypeScript 接口的作用、核心原则、类型、实现、继承及一些注意事项。","level":2},{"id":"/notes/ts/book/interface#_1-接口的作用","title":"1. 接口的作用","titles":["interface"],"content":"接口的主要作用是定义对象的类型。它描述了对象应该具有的属性和方法。接口不会在编译后的 JavaScript 中生成代码，仅在编译时进行类型检查。","level":3},{"id":"/notes/ts/book/interface#_2-核心原则","title":"2. 核心原则","titles":["interface"],"content":"TypeScript 的核心原则是基于结构类型系统，即类型是基于其成员来定义的。接口描述了一个对象的形状，并且是面向类型检查的契约。","level":3},{"id":"/notes/ts/book/interface#_3-定义和使用接口","title":"3. 定义和使用接口","titles":["interface"],"content":"","level":3},{"id":"/notes/ts/book/interface#基本接口","title":"基本接口","titles":["interface","3. 定义和使用接口"],"content":"","level":4},{"id":"/notes/ts/book/interface#_4-接口中的属性和方法","title":"4. 接口中的属性和方法","titles":["interface","3. 定义和使用接口"],"content":"接口不仅可以描述对象的属性，还可以描述对象的方法。","level":3},{"id":"/notes/ts/book/interface#_5-接口的可选属性和只读属性","title":"5. 接口的可选属性和只读属性","titles":["interface","3. 定义和使用接口"],"content":"","level":3},{"id":"/notes/ts/book/interface#可选属性","title":"可选属性","titles":["interface","3. 定义和使用接口","5. 接口的可选属性和只读属性"],"content":"接口中的可选属性使用    标记。","level":4},{"id":"/notes/ts/book/interface#只读属性","title":"只读属性","titles":["interface","3. 定义和使用接口","5. 接口的可选属性和只读属性"],"content":"接口中的只读属性使用    标记，表示属性不可修改。","level":4},{"id":"/notes/ts/book/interface#_6-接口的继承","title":"6. 接口的继承","titles":["interface","3. 定义和使用接口"],"content":"接口可以通过    关键字继承其他接口，从而实现接口的扩展。","level":3},{"id":"/notes/ts/book/interface#_7-混合类型接口","title":"7. 混合类型接口","titles":["interface","3. 定义和使用接口"],"content":"接口可以描述具有多种类型的对象，例如既有属性又有方法的对象。","level":3},{"id":"/notes/ts/book/interface#_8-实现接口","title":"8. 实现接口","titles":["interface","3. 定义和使用接口"],"content":"类可以实现一个接口，用    关键字。","level":3},{"id":"/notes/ts/book/interface#_9-接口与类型别名","title":"9. 接口与类型别名","titles":["interface","3. 定义和使用接口"],"content":"虽然接口和类型别名（  ）都可以定义对象类型，但接口更适合用于描述对象的结构和行为，而类型别名更适合用于组合简单类型或联合类型。","level":3},{"id":"/notes/ts/book/interface#_10-注意事项","title":"10. 注意事项","titles":["interface","3. 定义和使用接口"],"content":"接口合并 ：在 TypeScript 中，接口可以自动合并，这在声明全局类型时非常有用。     可选属性检查 ：当使用可选属性时，要注意检查该属性是否存在。     严格类型检查 ：在严格模式下，TypeScript 会对接口进行严格的类型检查，这有助于捕捉潜在的错误。","level":3},{"id":"/notes/ts/book/interface#readonly-vs-const","title":"readonly vs const","titles":["interface","3. 定义和使用接口"],"content":"在 TypeScript 中，   和    都用于创建不可修改的值，但它们应用的场景有所不同，具体区别如下：","level":3},{"id":"/notes/ts/book/interface#readonly","title":"readonly","titles":["interface","3. 定义和使用接口","readonly vs const"],"content":"用于属性级别，用来表示一个属性只读，即不能修改其值。","level":4},{"id":"/notes/ts/book/interface#对象属性中的使用","title":"对象属性中的使用：","titles":["interface","3. 定义和使用接口","readonly vs const"],"content":"","level":4},{"id":"/notes/ts/book/interface#类中的使用","title":"类中的使用：","titles":["interface","3. 定义和使用接口","readonly vs const"],"content":"","level":4},{"id":"/notes/ts/book/interface#const","title":"const","titles":["interface","3. 定义和使用接口","readonly vs const"],"content":"用于变量声明，表示一个常量，一旦声明，其值不能重新赋值。","level":4},{"id":"/notes/ts/book/interface#变量声明中的使用","title":"变量声明中的使用：","titles":["interface","3. 定义和使用接口","readonly vs const"],"content":"","level":4},{"id":"/notes/ts/book/interface#区别","title":"区别：","titles":["interface","3. 定义和使用接口","readonly vs const"],"content":"作用范围 ：     可以用于对象的属性以及类的属性，表示属性只读。    只能用于变量的声明，表示变量的值只读。   赋值时机 ：     的值可以在运行时或构造函数中赋值。    的值必须在声明时立即赋值，并且不能再次赋值。   使用场景 ：   如果需要将一个属性标记为不可修改，应该使用   。  如果需要声明一个常量值，应该使用   。在实际使用中，根据变量或属性的需要确定是使用    还是    是很重要的。","level":4},{"id":"/notes/ts/book/interface#总结","title":"总结","titles":["interface","3. 定义和使用接口"],"content":"TypeScript 的接口是一种强大的工具，用于定义对象的结构类型、确保类型安全、实现面向对象编程的抽象和继承。通过使用接口，可以编写更可读、可维护的代码，并提高开发效率。希望这些示例和注意事项能帮助你更好地理解和使用 TypeScript 的接口。","level":3},{"id":"/notes/ts/book/interface#参考","title":"参考","titles":["interface","3. 定义和使用接口"],"content":"https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html#interfaces","level":3},{"id":"/notes/ts/book/classes#class","title":"Class","titles":[],"content":"在 TypeScript 中，类（Class）是面向对象编程的核心概念之一，它提供了一种结构化的方式来定义对象的蓝图，包括属性和方法。下面详细介绍 TypeScript 中类的定义、构造函数、属性、方法、继承、访问修饰符等相关内容。","level":2},{"id":"/notes/ts/book/classes#_1-定义类","title":"1. 定义类","titles":["Class"],"content":"在 TypeScript 中定义一个类使用    关键字，类可以包含属性和方法。","level":3},{"id":"/notes/ts/book/classes#_2-构造函数","title":"2. 构造函数","titles":["Class"],"content":"类的构造函数使用    关键字定义，用于初始化对象的实例。在构造函数中，可以初始化类的属性。","level":3},{"id":"/notes/ts/book/classes#_3-属性和方法","title":"3. 属性和方法","titles":["Class"],"content":"类可以包含实例属性和方法，也可以包含静态属性和方法（通过    关键字定义）。","level":3},{"id":"/notes/ts/book/classes#_4-继承","title":"4. 继承","titles":["Class"],"content":"类可以通过    关键字进行继承另一个类，子类（派生类）可以继承父类（基类）的属性和方法，并且可以扩展或重写它们。","level":3},{"id":"/notes/ts/book/classes#_5-访问修饰符","title":"5. 访问修饰符","titles":["Class"],"content":"TypeScript 支持访问修饰符来控制类的成员（属性和方法）的访问权限。主要的访问修饰符包括   、   和   。：默认的访问修饰符，成员在类内外都可以访问。   ：成员只能在类内部访问。   ：成员在类内部和继承的子类中可以访问。","level":3},{"id":"/notes/ts/book/classes#_6-抽象类","title":"6. 抽象类","titles":["Class"],"content":"抽象类用于定义其他类继承的基类，不能被实例化。抽象类的方法在子类中必须被实现（除非它们自己也是抽象的）。","level":3},{"id":"/notes/ts/book/classes#_7-使用类实现接口","title":"7. 使用类实现接口","titles":["Class"],"content":"类可以使用    关键字来实现接口，一个类可以实现多个接口。","level":3},{"id":"/notes/ts/book/classes#总结","title":"总结","titles":["Class"],"content":"在 TypeScript 中，类是面向对象编程的基础，它允许你组织代码以对象为中心，并通过继承和访问修饰符等机制实现代码的组织和封装。理解和熟练使用类是 TypeScript 中的重要一环，能够帮助你编写结构清晰、易于维护的代码。","level":3},{"id":"/notes/ts/book/classes#参考","title":"参考","titles":["Class"],"content":"https://www.typescriptlang.org/docs/handbook/2/classes.html","level":3},{"id":"/notes/ts/book/functions#基本函数","title":"基本函数","titles":[],"content":"在 TypeScript 中，函数的定义与 JavaScript 类似，但可以指定参数和返回值的类型。和    指定了参数的类型。    表示函数的返回值类型。","level":3},{"id":"/notes/ts/book/functions#可选参数和默认参数","title":"可选参数和默认参数","titles":[],"content":"TypeScript 支持函数参数的可选性和默认值。","level":3},{"id":"/notes/ts/book/functions#可选参数","title":"可选参数","titles":["可选参数和默认参数"],"content":"在参数名后加    表示该参数是可选的。表示    是一个可选参数，如果不传该参数，函数调用仍然有效。","level":4},{"id":"/notes/ts/book/functions#默认参数","title":"默认参数","titles":["可选参数和默认参数"],"content":"在参数定义时赋予默认值。表示    的默认值是 \"Hello\"。","level":4},{"id":"/notes/ts/book/functions#剩余参数","title":"剩余参数","titles":["可选参数和默认参数","默认参数"],"content":"TypeScript 支持剩余参数，它允许我们将不确定数量的参数作为数组传递。表示    是一个包含所有剩余参数的数组。","level":3},{"id":"/notes/ts/book/functions#函数类型","title":"函数类型","titles":["可选参数和默认参数","默认参数"],"content":"可以使用类型别名来定义函数类型，这在传递回调函数时特别有用。定义了一个函数类型别名   。    表示    是一个符合    类型的函数。","level":3},{"id":"/notes/ts/book/functions#箭头函数","title":"箭头函数","titles":["可选参数和默认参数","默认参数"],"content":"TypeScript 支持箭头函数，它们语法简洁，并且可以保留    的指向。","level":3},{"id":"/notes/ts/book/functions#重载","title":"重载","titles":["可选参数和默认参数","默认参数"],"content":"TypeScript 支持函数重载，即同名函数可以有多个不同的签名。前两行定义了两个不同的签名：   和   。  最后一行是函数的具体实现。","level":3},{"id":"/notes/ts/book/functions#函数中的-this","title":"函数中的 this","titles":["可选参数和默认参数","默认参数"],"content":"在 TypeScript 中，我们可以明确地指定函数内部    的类型。明确了    的类型，使得函数内部的    更加可控。","level":3},{"id":"/notes/ts/book/functions#泛型函数","title":"泛型函数","titles":["可选参数和默认参数","默认参数"],"content":"TypeScript 支持泛型函数，可以处理不同类型的参数。使用了泛型   ，表示函数可以接受任意类型的参数，并返回相同类型的值。    和    是泛型函数的具体应用。通过以上介绍，TypeScript 函数的各种特性和用法可以帮助我们编写更健壮和可维护的代码。","level":3},{"id":"/notes/ts/book/functions#参考","title":"参考","titles":["可选参数和默认参数","默认参数"],"content":"https://www.typescriptlang.org/docs/handbook/2/functions.html","level":3},{"id":"/notes/ts/book/generics#_1-泛型概述","title":"1. 泛型概述","titles":[],"content":"泛型（Generics）允许定义函数、类或接口时不指定具体类型，而是在使用时再指定具体类型。这种方式使得代码在保持类型安全的同时，具有更高的灵活性。","level":3},{"id":"/notes/ts/book/generics#_2-泛型变量","title":"2. 泛型变量","titles":[],"content":"泛型变量用来捕获传递给函数、类或接口的类型。中的    就是泛型变量。  调用时指定具体类型，例如   。","level":3},{"id":"/notes/ts/book/generics#_3-泛型类型","title":"3. 泛型类型","titles":[],"content":"泛型类型用于定义包含一个或多个类型参数的类型。定义了一个泛型类型别名。    使用泛型类型别名定义变量。","level":3},{"id":"/notes/ts/book/generics#_4-泛型类","title":"4. 泛型类","titles":[],"content":"泛型类允许类在实例化时指定类型。定义了一个泛型类。    实例化时指定具体类型。","level":3},{"id":"/notes/ts/book/generics#_5-泛型约束","title":"5. 泛型约束","titles":[],"content":"泛型约束用于限制泛型类型的范围。表示泛型类型    必须满足    接口的约束。  这样可以确保    类型具有    属性。","level":3},{"id":"/notes/ts/book/generics#_6-学习技巧","title":"6. 学习技巧","titles":[],"content":"要掌握 TypeScript 泛型，可以采用以下学习技巧：从简单示例入手 ：理解基本概念后，再逐步复杂化。   阅读官方文档 ：TypeScript 官方文档是最权威的学习资源，涵盖了泛型的方方面面。   实践练习 ：多写代码，尝试将常见的非泛型代码改写成泛型代码。   阅读开源项目代码 ：学习他人如何在大型项目中使用泛型。   使用TypeScript Playground ：在  TypeScript Playground  上实验代码，快速验证想法。","level":3},{"id":"/notes/ts/book/generics#综合示例","title":"综合示例","titles":[],"content":"以下是一个综合示例，展示了如何使用泛型函数、泛型接口和泛型类：通过这些示例，可以全面理解 TypeScript 中泛型的使用和优势。多加练习，可以更好地掌握和应用泛型，使代码更加通用和可复用。","level":3},{"id":"/notes/ts/book/generics#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/2/generics.html#handbook-content","level":3},{"id":"/notes/ts/book/enums#数字枚举","title":"数字枚举","titles":[],"content":"数字枚举是 TypeScript 中最常见的枚举类型。默认情况下，枚举成员的值从    开始递增。你也可以手动指定枚举成员的值，后续成员的值会从这个指定值开始递增。","level":3},{"id":"/notes/ts/book/enums#字符串枚举","title":"字符串枚举","titles":[],"content":"字符串枚举的每个成员必须用字符串字面量进行初始化。这种方式提供了更清晰的语义。","level":3},{"id":"/notes/ts/book/enums#异构枚举","title":"异构枚举","titles":[],"content":"异构枚举允许混合使用字符串和数字成员。这种用法较少见，但在某些特定场景下可能会有用。","level":3},{"id":"/notes/ts/book/enums#计算和常量成员","title":"计算和常量成员","titles":[],"content":"枚举成员可以是常量或计算值。常量成员是在编译时计算出的值，而计算成员则是在运行时计算的。","level":3},{"id":"/notes/ts/book/enums#常量枚举","title":"常量枚举","titles":[],"content":"常量枚举使用    关键字定义，编译时会被完全移除。常量枚举只在性能优化上有用，特别是在频繁使用的情况下。编译后的代码将不包含枚举定义，而是直接使用其值：","level":3},{"id":"/notes/ts/book/enums#反向映射","title":"反向映射","titles":[],"content":"数字枚举成员不仅创建从名字到值的映射，还创建从值到名字的反向映射。反向映射仅适用于数字枚举成员，字符串枚举成员不提供这种特性。","level":3},{"id":"/notes/ts/book/enums#枚举成员类型","title":"枚举成员类型","titles":[],"content":"枚举成员类型可以作为单独的类型使用，尤其在需要特定值的场景下。","level":3},{"id":"/notes/ts/book/enums#总结","title":"总结","titles":[],"content":"TypeScript 枚举提供了一种灵活和强大的方式来定义一组命名常量，使代码更加可读和易于维护。以下是总结的几点：数字枚举 ：默认从    开始递增，可以手动指定值。   字符串枚举 ：每个成员用字符串字面量初始化，提供清晰的语义。   异构枚举 ：允许混合字符串和数字成员。   计算和常量成员 ：支持在编译时和运行时计算的成员。   常量枚举 ：使用    关键字定义，编译时移除以优化性能。   反向映射 ：数字枚举成员支持从名字到值和从值到名字的反向映射。   枚举成员类型 ：可以作为单独的类型使用。通过掌握这些特性，你可以更有效地使用 TypeScript 枚举来构建强类型的应用程序。","level":3},{"id":"/notes/ts/book/enums#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/enums.html#handbook-content","level":3},{"id":"/notes/ts/book/type-inference#基本类型推论","title":"基本类型推论","titles":[],"content":"当变量被声明并初始化时，TypeScript 会根据初始化的值推断出变量的类型。即使没有显式地声明类型，TypeScript 也能够推断出变量的类型。例如，   被推断为   ，因为它被初始化为   。","level":3},{"id":"/notes/ts/book/type-inference#最佳通用类型","title":"最佳通用类型","titles":[],"content":"当推断数组的类型时，TypeScript 会基于数组元素的类型推断出数组的类型。如果数组中有不同类型的元素，TypeScript 会推断出一个包含所有可能类型的联合类型。","level":3},{"id":"/notes/ts/book/type-inference#上下文类型","title":"上下文类型","titles":[],"content":"当变量的类型由其上下文决定时，称为上下文类型。这个机制通常出现在函数参数和返回值、回调函数等场景中。在上述代码中，   的类型被推断为   ，因为    事件处理函数的上下文决定了    的类型。","level":3},{"id":"/notes/ts/book/type-inference#返回值类型推论","title":"返回值类型推论","titles":[],"content":"当函数有返回值时，TypeScript 可以基于    语句自动推断出返回值的类型。在这个例子中，   函数的返回值类型被推断为   。","level":3},{"id":"/notes/ts/book/type-inference#上下文类型与回调函数","title":"上下文类型与回调函数","titles":[],"content":"当回调函数作为参数传递给另一个函数时，TypeScript 可以推断出回调函数参数的类型。在这里，   的回调函数参数    的类型被推断为   ，因为    是一个   。","level":3},{"id":"/notes/ts/book/type-inference#上下文类型与类型别名","title":"上下文类型与类型别名","titles":[],"content":"在使用类型别名时，TypeScript 也会进行类型推论。在这个例子中，   被推断为    类型，因为它被初始化为一个符合    类型的对象。","level":3},{"id":"/notes/ts/book/type-inference#类型推论的局限性","title":"类型推论的局限性","titles":[],"content":"虽然类型推论可以极大地减少显式类型声明的需要，但在某些情况下，显式声明类型仍然是必要的。复杂对象 ：当对象结构复杂时，显式声明类型可以提高代码可读性。   外部接口 ：在与外部接口交互时，显式声明类型可以避免潜在的类型错误。   默认参数 ：在函数的默认参数中，显式声明类型可以使函数更易于理解。","level":3},{"id":"/notes/ts/book/type-inference#强制类型推断","title":"强制类型推断","titles":[],"content":"有时，TypeScript 无法推断出正确的类型，或者推断出的类型不符合预期。在这种情况下，可以使用类型断言来强制指定类型。","level":3},{"id":"/notes/ts/book/type-inference#总结","title":"总结","titles":[],"content":"TypeScript 的类型推论机制能够在大多数情况下自动推断出变量的类型，从而减少显式类型声明的需要。理解和利用类型推论可以使代码更加简洁和易读。以下是一些关键点：基本类型推论 ：基于初始化值推断类型。   最佳通用类型 ：在数组和联合类型中推断出最合适的类型。   上下文类型 ：根据上下文环境推断类型，如事件处理和回调函数。   返回值类型推论 ：基于    语句推断函数的返回值类型。   类型断言 ：在需要时强制指定类型。通过熟练掌握这些机制，可以在 TypeScript 中更好地利用类型系统的强大功能。","level":3},{"id":"/notes/ts/book/type-inference#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/type-inference.html","level":3},{"id":"/notes/ts/book/type-compatibility#_1-基本规则","title":"1. 基本规则","titles":[],"content":"在 TypeScript 中，一个类型    可以赋值给另一个类型   ，当且仅当    兼容   。类型兼容性主要取决于两个方面：结构兼容性 ：即一个类型的属性集合是否是另一个类型属性集合的子集。   可分配性 ：即一个类型的值是否可以赋值给另一个类型。","level":3},{"id":"/notes/ts/book/type-compatibility#_2-接口兼容性","title":"2. 接口兼容性","titles":[],"content":"当判断两个接口类型的兼容性时，TypeScript 会检查一个接口的属性是否可以包含在另一个接口中。在这个例子中，   包含    所有的属性，因此    类型可以赋值给    类型。","level":3},{"id":"/notes/ts/book/type-compatibility#_3-类兼容性","title":"3. 类兼容性","titles":[],"content":"类的兼容性与接口类似，但还会考虑到类的静态成员和构造函数。只考虑实例成员和方法。","level":3},{"id":"/notes/ts/book/type-compatibility#_4-函数兼容性","title":"4. 函数兼容性","titles":[],"content":"函数的兼容性检查主要涉及参数和返回值的类型。在检查函数兼容性时，TypeScript 会执行双向检查。参数 ：参数类型必须兼容（逆变）。   返回值 ：返回值类型必须兼容（协变）。","level":3},{"id":"/notes/ts/book/type-compatibility#_5-泛型兼容性","title":"5. 泛型兼容性","titles":[],"content":"泛型类型的兼容性与普通类型相似，TypeScript 会检查实际使用时泛型参数的兼容性。","level":3},{"id":"/notes/ts/book/type-compatibility#_6-枚举兼容性","title":"6. 枚举兼容性","titles":[],"content":"不同枚举类型之间不兼容，但可以将枚举类型与数字类型相互赋值。","level":3},{"id":"/notes/ts/book/type-compatibility#_7-高级类型兼容性","title":"7. 高级类型兼容性","titles":[],"content":"","level":3},{"id":"/notes/ts/book/type-compatibility#联合类型和交叉类型","title":"联合类型和交叉类型","titles":["7. 高级类型兼容性"],"content":"联合类型（Union Types） ：A | B 表示 A 或 B 的类型，可以兼容 A 或 B 的类型。   交叉类型（Intersection Types） ：A & B 表示同时是 A 和 B 的类型。","level":4},{"id":"/notes/ts/book/type-compatibility#_8-typescript-中类型兼容性总结","title":"8. TypeScript 中类型兼容性总结","titles":["7. 高级类型兼容性","联合类型和交叉类型"],"content":"结构化类型系统 ：基于成员结构判断类型兼容性。   接口和类 ：成员类型兼容即可赋值，类需注意静态成员和构造函数。   函数 ：参数类型逆变，返回值类型协变。   泛型 ：实际使用时泛型参数需兼容。   枚举 ：与数字类型互相兼容，不同枚举类型不兼容。   联合类型和交叉类型 ：分别表示可选类型和组合类型。通过理解和掌握 TypeScript 的类型兼容性机制，可以编写出更安全、可维护的代码，同时也可以更灵活地利用类型系统的强大功能。","level":3},{"id":"/notes/ts/book/type-compatibility#参考","title":"参考","titles":["7. 高级类型兼容性","联合类型和交叉类型"],"content":"https://www.typescriptlang.org/docs/handbook/type-compatibility.html#handbook-content","level":3},{"id":"/notes/ts/book/advanced-types#typescript-高级类型","title":"TypeScript 高级类型","titles":[],"content":"TypeScript 高级类型是 TypeScript 类型系统中的一些高级特性和技巧，用于编写更复杂和灵活的代码。以下是 TypeScript 高级类型的详细介绍，包括交叉类型、联合类型、类型别名、类型断言、字面量类型、可辨识联合、类型守卫、映射类型和条件类型。","level":2},{"id":"/notes/ts/book/advanced-types#_1-交叉类型intersection-types","title":"1. 交叉类型（Intersection Types）","titles":["TypeScript 高级类型"],"content":"交叉类型    表示同时是    和    类型的类型。它通常用于将多个类型的成员结合在一起。","level":3},{"id":"/notes/ts/book/advanced-types#_2-联合类型union-types","title":"2. 联合类型（Union Types）","titles":["TypeScript 高级类型"],"content":"联合类型    表示可以是    或    类型的类型。它通常用于表示一个值可以有多种类型。","level":3},{"id":"/notes/ts/book/advanced-types#_3-类型别名type-aliases","title":"3. 类型别名（Type Aliases）","titles":["TypeScript 高级类型"],"content":"类型别名用于给类型起一个新的名字。它可以简化复杂类型的使用。","level":3},{"id":"/notes/ts/book/advanced-types#_4-字面量类型literal-types","title":"4. 字面量类型（Literal Types）","titles":["TypeScript 高级类型"],"content":"字面量类型允许你指定一个变量只能有特定的值。它通常与联合类型结合使用来实现枚举的效果。","level":3},{"id":"/notes/ts/book/advanced-types#_5-可辨识联合discriminated-unions","title":"5. 可辨识联合（Discriminated Unions）","titles":["TypeScript 高级类型"],"content":"可辨识联合是 TypeScript 中的一种模式，用于类型安全地处理联合类型。它通常由联合类型、字面量类型和类型守卫结合实现。","level":3},{"id":"/notes/ts/book/advanced-types#_6-类型守卫type-guards","title":"6. 类型守卫（Type Guards）","titles":["TypeScript 高级类型"],"content":"类型守卫是一些表达式，用于在运行时检查类型，并在特定的代码块中缩小类型范围。常见的类型守卫包括   、   和自定义类型谓词。","level":3},{"id":"/notes/ts/book/advanced-types#_7-映射类型mapped-types","title":"7. 映射类型（Mapped Types）","titles":["TypeScript 高级类型"],"content":"映射类型用于基于旧类型创建新类型。它遍历旧类型的属性，并基于其创建新的类型。","level":3},{"id":"/notes/ts/book/advanced-types#_8-条件类型conditional-types","title":"8. 条件类型（Conditional Types）","titles":["TypeScript 高级类型"],"content":"条件类型用于根据某个条件表达式生成不同的类型。","level":3},{"id":"/notes/ts/book/advanced-types#_9-索引类型index-types","title":"9. 索引类型（Index Types）","titles":["TypeScript 高级类型"],"content":"定义 ：索引类型用于获取对象属性的类型。用法 ：使用    和索引访问操作符   。说明 ：   操作符获取对象的键，   获取对象属性的类型。","level":3},{"id":"/notes/ts/book/advanced-types#高级类型示例","title":"高级类型示例","titles":["TypeScript 高级类型"],"content":"结合使用多个高级类型特性可以创建更复杂的类型定义。","level":2},{"id":"/notes/ts/book/advanced-types#高级类型总结","title":"高级类型总结","titles":["TypeScript 高级类型"],"content":"TypeScript 高级类型提供了一些强大而灵活的工具，用于创建复杂且类型安全的代码。通过理解和利用这些特性，你可以编写更健壮和可维护的 TypeScript 代码。以下是关键点：交叉类型 ：将多个类型合并为一个类型。   联合类型 ：表示值可以是多种类型之一。   类型别名 ：给复杂类型起一个简洁的名字。   字面量类型 ：指定变量只能有特定的值。   可辨识联合 ：安全处理联合类型。   类型守卫 ：在运行时检查并缩小类型范围。   映射类型 ：基于旧类型创建新类型。   条件类型 ：根据条件生成不同的类型。通过掌握这些高级类型特性，你可以更加灵活和精确地描述代码中的数据结构和行为。","level":2},{"id":"/notes/ts/book/advanced-types#参考","title":"参考","titles":["TypeScript 高级类型"],"content":"https://www.typescriptlang.org/docs/handbook/type-compatibility.html#advanced-topics","level":2},{"id":"/notes/ts/book/symbols#_1-创建-symbol","title":"1. 创建 Symbol","titles":[],"content":"可以使用    函数来创建一个新的 Symbol。每个 Symbol 都是唯一的，即使它们的描述相同。","level":3},{"id":"/notes/ts/book/symbols#_2-使用-symbol-作为对象属性键","title":"2. 使用 Symbol 作为对象属性键","titles":[],"content":"由于 Symbol 是唯一的，它们非常适合作为对象属性键，以避免属性名冲突。","level":3},{"id":"/notes/ts/book/symbols#_3-全局-symbol-注册表","title":"3. 全局 Symbol 注册表","titles":[],"content":"可以使用    和    在全局注册表中创建和查找 Symbols。这样即使在不同的模块中也可以共享同一个 Symbol。","level":3},{"id":"/notes/ts/book/symbols#_4-内置的-well-known-symbols","title":"4. 内置的 Well-Known Symbols","titles":[],"content":"JavaScript 和 TypeScript 定义了一些内置的 Symbol，这些 Symbol 被称为 Well-Known Symbols，它们可以用来修改内置行为。例如，   用于定义对象的默认迭代器。","level":3},{"id":"/notes/ts/book/symbols#_5-symbol-属性不可枚举","title":"5. Symbol 属性不可枚举","titles":[],"content":"使用    或    循环时，Symbol 属性不会被枚举出来。但是可以使用    来获取对象的 Symbol 属性。","level":3},{"id":"/notes/ts/book/symbols#_6-使用-symbol-实现私有属性","title":"6. 使用 Symbol 实现私有属性","titles":[],"content":"尽管 TypeScript 提供了    关键字，但在运行时它不会真正将属性隐藏。使用 Symbol 可以实现某种程度的私有属性，因为 Symbol 属性不会被意外访问或覆盖。","level":3},{"id":"/notes/ts/book/symbols#_7-使用-symbol-实现枚举类型的扩展","title":"7. 使用 Symbol 实现枚举类型的扩展","titles":[],"content":"Symbol 也可以用于扩展枚举类型，使其更灵活和安全。","level":3},{"id":"/notes/ts/book/symbols#_8-示例总结","title":"8. 示例总结","titles":[],"content":"综合以上使用方式，Symbols 可以在以下场景中大显身手：避免对象属性名冲突 ：使用 Symbol 作为对象属性键，确保属性的唯一性。   创建私有属性 ：虽然不是完全的私有，但可以避免意外的访问或覆盖。   使用全局 Symbol 注册表 ：在多个模块之间共享同一个 Symbol。   修改内置行为 ：通过 Well-Known Symbols 修改内置对象的行为。   增强枚举类型 ：使用 Symbol 实现更灵活和安全的枚举类型扩展。通过合理使用 Symbols，可以大大提升代码的健壮性和可维护性。","level":3},{"id":"/notes/ts/book/symbols#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/symbols.html#handbook-content","level":3},{"id":"/notes/ts/book/iterators-and-generators#_1-迭代器-iterators","title":"1. 迭代器 (Iterators)","titles":[],"content":"定义 ：迭代器是一个对象，它实现了    接口，该接口包含一个    方法，返回一个包含    和    属性的对象。基本用法 ：说明 ：   类实现了一个简单的迭代器，它生成从    到    的值。","level":3},{"id":"/notes/ts/book/iterators-and-generators#_2-可迭代对象-iterable","title":"2. 可迭代对象 (Iterable)","titles":[],"content":"定义 ：一个对象被认为是可迭代的，如果它实现了    接口，这意味着它有一个    属性，返回一个迭代器。基本用法 ：说明 ：   类实现了    接口，使得其实例可以使用    循环进行迭代。","level":3},{"id":"/notes/ts/book/iterators-and-generators#_3-生成器-generators","title":"3. 生成器 (Generators)","titles":[],"content":"定义 ：生成器是一种特殊类型的函数，它可以暂停和恢复其执行。生成器函数使用    语法定义，内部使用    表达式来生成值。基本用法 ：说明 ：   函数每次    一个值，当没有更多值时，返回   。","level":3},{"id":"/notes/ts/book/iterators-and-generators#_4-使用生成器实现可迭代对象","title":"4. 使用生成器实现可迭代对象","titles":[],"content":"定义和用法 ：生成器函数可以用于实现    接口，使得自定义迭代逻辑更加简单。说明 ：   类使用生成器函数实现了    接口，使得迭代逻辑更简洁。","level":3},{"id":"/notes/ts/book/iterators-and-generators#_5-生成器的高级用法","title":"5. 生成器的高级用法","titles":[],"content":"生成器除了简单地生成序列，还可以通过    表达式和    方法之间的双向通信，实现更复杂的迭代逻辑。双向通信 ：说明 ：生成器函数    演示了如何在调用    时向生成器发送值，并在生成器中接收这些值。","level":3},{"id":"/notes/ts/book/iterators-and-generators#_6-异步生成器-async-generators","title":"6. 异步生成器 (Async Generators)","titles":[],"content":"定义 ：异步生成器函数使用    语法定义，允许在生成器函数中使用    表达式，从而处理异步操作。基本用法 ：说明 ：   异步生成器函数每秒生成一个值，通过    循环进行异步迭代。","level":3},{"id":"/notes/ts/book/iterators-and-generators#总结","title":"总结","titles":[],"content":"TypeScript 中的迭代器和生成器提供了强大的工具来处理序列和异步操作：迭代器 ：通过实现    接口自定义迭代行为。   可迭代对象 ：实现    接口，使对象可以被    循环迭代。   生成器 ：使用    定义，使用    表达式生成值，提供暂停和恢复执行的能力。   异步生成器 ：使用    定义，允许在生成器中使用异步操作。通过理解和应用这些特性，你可以编写更加灵活和高效的代码，处理复杂的迭代逻辑和异步操作。","level":3},{"id":"/notes/ts/book/iterators-and-generators#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#handbook-content","level":3},{"id":"/notes/ts/book/modules#_1-模块基础","title":"1. 模块基础","titles":[],"content":"模块的定义 ：在 TypeScript 中，一个文件就是一个模块。模块中的代码默认是私有的，只有通过导出（export）的内容才能在其他模块中使用。基本用法 ：","level":3},{"id":"/notes/ts/book/modules#导出和导入","title":"导出和导入","titles":["1. 模块基础"],"content":"导出 (Export) ：可以通过    关键字将变量、函数、类、接口等导出。导入 (Import) ：可以通过    关键字从其他模块中导入导出的内容。","level":4},{"id":"/notes/ts/book/modules#_2-默认导出default-exports","title":"2. 默认导出（Default Exports）","titles":["1. 模块基础","导出和导入"],"content":"默认导出是指一个模块可以有一个默认导出，使用    语法。说明 ：默认导出的内容在导入时不需要使用花括号   ，并且可以使用任意名字进行导入。","level":3},{"id":"/notes/ts/book/modules#_3-重命名导入和导出","title":"3. 重命名导入和导出","titles":["1. 模块基础","导出和导入"],"content":"可以在导出和导入时对标识符进行重命名，以避免命名冲突或提升代码可读性。导出时重命名 ：导入时重命名 ：","level":3},{"id":"/notes/ts/book/modules#_4-重新导出re-exporting","title":"4. 重新导出（Re-Exporting）","titles":["1. 模块基础","导出和导入"],"content":"重新导出可以将一个模块的所有内容或部分内容重新导出，以便在其他模块中使用。重新导出所有内容 ：重新导出部分内容 ：","level":3},{"id":"/notes/ts/book/modules#_5-动态导入","title":"5. 动态导入","titles":["1. 模块基础","导出和导入"],"content":"动态导入允许在运行时按需加载模块，使用    语法。说明 ：动态导入返回一个   ，适合用于按需加载、代码分割和性能优化。","level":3},{"id":"/notes/ts/book/modules#_6-命名空间namespaces","title":"6. 命名空间（Namespaces）","titles":["1. 模块基础","导出和导入"],"content":"命名空间用于将一组相关的代码组织在一起，它是 TypeScript 提供的另一种模块化方式，但在现代开发中更推荐使用模块（ES 模块）。","level":3},{"id":"/notes/ts/book/modules#_7-模块解析","title":"7. 模块解析","titles":["1. 模块基础","导出和导入"],"content":"TypeScript 提供了两种模块解析策略：  经典（Classic）  和   节点（Node） 。默认情况下，TypeScript 使用节点解析策略。节点解析策略 ：遵循 Node.js 的模块解析逻辑，支持相对路径和包路径导入。","level":3},{"id":"/notes/ts/book/modules#_8-配置模块","title":"8. 配置模块","titles":["1. 模块基础","导出和导入"],"content":"在    文件中，可以通过    配置模块相关选项。说明 ：通过    和    选项，可以配置路径别名，简化模块导入路径。","level":3},{"id":"/notes/ts/book/modules#_9-高级用法示例","title":"9. 高级用法示例","titles":["1. 模块基础","导出和导入"],"content":"结合以上各种模块特性，可以实现复杂的模块组织和依赖管理。示例 ：","level":3},{"id":"/notes/ts/book/modules#总结","title":"总结","titles":["1. 模块基础","导出和导入"],"content":"TypeScript 模块通过导出和导入机制帮助开发者将代码组织成逻辑单元，提高代码可维护性和重用性。默认导出、重命名导入导出、动态导入、命名空间等高级特性使得模块的使用更加灵活和强大。通过合理配置和使用这些特性，可以构建清晰、模块化和高效的 TypeScript 项目。","level":3},{"id":"/notes/ts/book/modules#参考","title":"参考","titles":["1. 模块基础","导出和导入"],"content":"https://www.typescriptlang.org/docs/handbook/modules/introduction.html#handbook-content","level":3},{"id":"/notes/ts/book/namespaces#typescript-namespaces-命名空间","title":"TypeScript Namespaces (命名空间)","titles":[],"content":"Namespaces(命名空间) 是 TypeScript 提供的一种组织代码的方法，特别适用于大型项目。通过使用 namespaces，可以将代码分隔成不同的模块，从而避免全局命名空间污染并提升代码的可读性和可维护性。","level":3},{"id":"/notes/ts/book/namespaces#基本语法","title":"基本语法","titles":[],"content":"","level":3},{"id":"/notes/ts/book/namespaces#声明-namespace","title":"声明 Namespace","titles":["基本语法"],"content":"Namespace 使用    关键字进行声明，并可以包含变量、函数、类、接口和子命名空间等。在这个示例中，   包含一个类   ，一个函数    和一个常量   。需要注意的是，必须使用    关键字导出这些成员，否则它们在命名空间外部将不可访问。","level":4},{"id":"/notes/ts/book/namespaces#使用-namespace","title":"使用 Namespace","titles":["基本语法"],"content":"可以通过点符号访问命名空间中的导出成员：","level":4},{"id":"/notes/ts/book/namespaces#嵌套-namespace","title":"嵌套 Namespace","titles":["基本语法","使用 Namespace"],"content":"命名空间可以嵌套，这对于分层次组织代码非常有用。","level":3},{"id":"/notes/ts/book/namespaces#合并-namespaces","title":"合并 Namespaces","titles":["基本语法","使用 Namespace"],"content":"在 TypeScript 中，命名空间可以进行合并。这意味着你可以在多个文件中定义同一个命名空间，它们会被合并在一起。这在大型项目中非常有用。","level":3},{"id":"/notes/ts/book/namespaces#示例合并命名空间","title":"示例：合并命名空间","titles":["基本语法","使用 Namespace","合并 Namespaces"],"content":"文件   ：文件   ：在编译和使用时，   将包含两个函数    和   ：","level":4},{"id":"/notes/ts/book/namespaces#外部模块与-namespaces","title":"外部模块与 Namespaces","titles":["基本语法","使用 Namespace"],"content":"现代 TypeScript 项目通常使用 ES6 模块（即外部模块）来组织代码，而不是命名空间。模块提供了更好的作用域隔离和更灵活的加载机制。","level":3},{"id":"/notes/ts/book/namespaces#namespaces-的使用场景","title":"Namespaces 的使用场景","titles":["基本语法","使用 Namespace"],"content":"虽然外部模块在现代 TypeScript 项目中更为常见，但命名空间在以下场景中仍然有用：全局库 ：对于希望在全局范围内使用的库，命名空间是一个不错的选择。   旧代码迁移 ：在将旧的 JavaScript 项目迁移到 TypeScript 时，命名空间可以帮助逐步组织和隔离代码。   简单项目 ：对于小型项目或简单的脚本，命名空间可以快速组织代码而不需要配置模块加载器。","level":3},{"id":"/notes/ts/book/namespaces#示例项目","title":"示例项目","titles":["基本语法","使用 Namespace"],"content":"以下是一个完整示例，展示了如何在 TypeScript 项目中使用命名空间：","level":3},{"id":"/notes/ts/book/namespaces#文件结构","title":"文件结构","titles":["基本语法","使用 Namespace","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces#mynamespacets","title":"myNamespace.ts","titles":["基本语法","使用 Namespace","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces#indexts","title":"index.ts","titles":["基本语法","使用 Namespace","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces#编译和运行","title":"编译和运行","titles":["基本语法","使用 Namespace"],"content":"使用    命令编译 TypeScript 文件：这会将所有 TypeScript 文件编译为一个单独的 JavaScript 文件   ，并可以在浏览器中运行。","level":3},{"id":"/notes/ts/book/namespaces#总结","title":"总结","titles":["基本语法","使用 Namespace"],"content":"Namespaces 是 TypeScript 提供的一种组织代码的方法，特别适用于大型项目。尽管在现代 TypeScript 项目中，模块化的方式更为常见，但命名空间在某些特定场景中仍然有其优势。理解和灵活运用命名空间和模块，可以帮助你更好地组织和管理你的 TypeScript 代码。","level":3},{"id":"/notes/ts/book/namespaces#参考","title":"参考","titles":["基本语法","使用 Namespace"],"content":"https://www.typescriptlang.org/docs/handbook/namespaces.html#handbook-content","level":3},{"id":"/notes/ts/book/namespaces-and-modules#namespaces-modules命名空间和模块","title":"Namespaces & Modules(命名空间和模块)","titles":[],"content":"在 TypeScript 中，   和    是用于组织和管理代码的两种主要机制。虽然它们在某些方面具有相似性，但它们有不同的用途和应用场景。以下是对 TypeScript 中    和    的详细介绍，包括它们的用法、差异和最佳实践。","level":2},{"id":"/notes/ts/book/namespaces-and-modules#namespaces","title":"Namespaces","titles":["Namespaces & Modules(命名空间和模块)"],"content":"","level":3},{"id":"/notes/ts/book/namespaces-and-modules#什么是-namespaces","title":"什么是 Namespaces?","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"Namespaces 是 TypeScript 中的一个内部模块系统，用于将相关代码组织在一起，以避免全局命名空间的污染。它们使用    关键字定义，可以包含类、接口、函数和变量等。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#声明和使用-namespaces","title":"声明和使用 Namespaces","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#声明-namespace","title":"声明 Namespace","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","声明和使用 Namespaces"],"content":"","level":5},{"id":"/notes/ts/book/namespaces-and-modules#使用-namespace","title":"使用 Namespace","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","声明和使用 Namespaces"],"content":"","level":5},{"id":"/notes/ts/book/namespaces-and-modules#嵌套-namespaces","title":"嵌套 Namespaces","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","声明和使用 Namespaces"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#modules","title":"Modules","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"","level":3},{"id":"/notes/ts/book/namespaces-and-modules#什么是-modules","title":"什么是 Modules?","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Modules"],"content":"Modules 是 TypeScript 和 JavaScript 中的外部模块系统，通过文件和文件夹来组织代码。它们符合 ES6 标准，并使用    和    语法导入和导出模块。模块在模块范围内具有自己的作用域，不会污染全局命名空间。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#声明和使用-modules","title":"声明和使用 Modules","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Modules"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#声明-module","title":"声明 Module","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Modules","声明和使用 Modules"],"content":"创建一个名为    的文件：","level":5},{"id":"/notes/ts/book/namespaces-and-modules#使用-module","title":"使用 Module","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Modules","声明和使用 Modules"],"content":"创建一个名为    的文件：","level":5},{"id":"/notes/ts/book/namespaces-and-modules#differences-between-namespaces-and-modules","title":"Differences between Namespaces and Modules","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"","level":3},{"id":"/notes/ts/book/namespaces-and-modules#用途","title":"用途","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Differences between Namespaces and Modules"],"content":"Namespaces ：适用于在同一个文件或全局范围内组织代码，通常用于小型项目或旧项目的代码组织。   Modules ：适用于大型项目，通过文件和文件夹组织代码，符合现代 JavaScript 标准，支持更好的作用域隔离和模块加载。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#语法","title":"语法","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Differences between Namespaces and Modules"],"content":"Namespaces ：使用    关键字定义，通过点符号访问命名空间成员。   Modules ：使用    和    关键字导入和导出模块成员。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#作用域","title":"作用域","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Differences between Namespaces and Modules"],"content":"Namespaces ：在全局作用域中定义，所有导出的成员在全局可访问。   Modules ：在模块作用域中定义，导出的成员需要显式导入才能访问。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#加载机制","title":"加载机制","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Differences between Namespaces and Modules"],"content":"Namespaces ：不依赖模块加载器，直接在全局作用域中可用。   Modules ：依赖模块加载器（如 CommonJS、AMD、ES6 模块），需要正确的模块解析配置。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#best-practices","title":"Best Practices","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"","level":3},{"id":"/notes/ts/book/namespaces-and-modules#何时使用-namespaces","title":"何时使用 Namespaces","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Best Practices"],"content":"小型项目或简单脚本。  需要在全局范围内共享代码的库或工具。  将现有的 JavaScript 代码迁移到 TypeScript。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#何时使用-modules","title":"何时使用 Modules","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","Best Practices"],"content":"大型项目或复杂应用。  需要模块化加载和作用域隔离。  现代 JavaScript 开发环境，使用构建工具（如 Webpack、Rollup）。","level":4},{"id":"/notes/ts/book/namespaces-and-modules#示例项目","title":"示例项目","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"","level":3},{"id":"/notes/ts/book/namespaces-and-modules#文件结构","title":"文件结构","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#mynamespacets","title":"myNamespace.ts","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#indexts","title":"index.ts","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#mymodulemodule1ts","title":"myModule/module1.ts","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#mymodulemodule2ts","title":"myModule/module2.ts","titles":["Namespaces & Modules(命名空间和模块)","Namespaces","示例项目"],"content":"","level":4},{"id":"/notes/ts/book/namespaces-and-modules#总结","title":"总结","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"Namespaces 和 Modules 是 TypeScript 提供的两种组织代码的机制。Namespaces 适用于小型项目或需要全局共享代码的场景，而 Modules 则适用于大型项目，通过模块化加载和作用域隔离来组织代码。在现代开发中，Modules 更加符合 JavaScript 标准，并且是推荐的代码组织方式。理解这两者的差异和应用场景，能够帮助你更好地组织和管理 TypeScript 项目。","level":3},{"id":"/notes/ts/book/namespaces-and-modules#参考","title":"参考","titles":["Namespaces & Modules(命名空间和模块)","Namespaces"],"content":"https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html#handbook-content","level":3},{"id":"/notes/ts/book/module-resolution#_1-模块解析的种类","title":"1. 模块解析的种类","titles":[],"content":"TypeScript 支持两种主要的模块解析策略：Classic 模式 ：也称为相对路径模式或相对路径引用模式。   Node 模式 ：也称为非相对路径模式或模块解析模式。","level":3},{"id":"/notes/ts/book/module-resolution#_2-classic-模式","title":"2. Classic 模式","titles":[],"content":"Classic 模式是 TypeScript 的旧模块解析策略，主要用于处理在 TypeScript 刚刚推出时的模块系统。它的特点包括：相对路径引用 ：使用相对路径或者以    或    开头的路径来引用模块。   baseUrl 和 paths 配置 ：通过    中的    和    配置来映射模块名称到实际路径。   不支持 Node 模块解析 ：不会考虑 Node.js 中    的结构，主要用于处理不符合 CommonJS 或 AMD 模块规范的模块系统。示例    配置：","level":3},{"id":"/notes/ts/book/module-resolution#_3-node-模式","title":"3. Node 模式","titles":[],"content":"Node 模式是目前推荐的模块解析策略，特点包括：非相对路径引用 ：使用非相对路径来引用模块，如模块名称（如   ）。   Node.js 核心模块解析 ：可以直接引用 Node.js 核心模块（如   ）。   支持   ：支持像 Node.js 一样的    结构，可以从当前文件的目录结构中自动解析出依赖模块。示例    配置：","level":3},{"id":"/notes/ts/book/module-resolution#_4-配置-tsconfigjson","title":"4. 配置   tsconfig.json","titles":[],"content":"在    中，通过    字段可以指定使用哪种模块解析策略。可以选择的值包括：：使用 Node 模块解析策略。   ：使用 Classic 模块解析策略。示例：","level":3},{"id":"/notes/ts/book/module-resolution#_5-模块解析过程","title":"5. 模块解析过程","titles":[],"content":"无论是 Classic 模式还是 Node 模式，模块解析过程一般包括以下步骤：相对路径解析 ：如果模块引用以    或    开头，TypeScript 将根据相对路径寻找对应的模块文件。   baseUrl 和 paths 解析 ：根据    中的    和    配置，将模块名称映射为具体的文件路径。   Node 模块解析 ：在 Node 模式下，TypeScript 会根据 Node.js 的模块解析规则，查找和加载    中的模块。   文件扩展名解析 ：根据    中的    配置或默认配置，解析模块文件的扩展名（如   ,   ,   ,   ,    等）。","level":3},{"id":"/notes/ts/book/module-resolution#_6-总结","title":"6. 总结","titles":[],"content":"模块解析在 TypeScript 中是一个重要的环节，它决定了在编译时如何查找和加载模块依赖。通过正确配置    中的    和相关选项，可以确保 TypeScript 在开发过程中能够正确地解析和处理模块的依赖关系，提高项目的可维护性和可扩展性。","level":3},{"id":"/notes/ts/book/module-resolution#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-resolution#handbook-content","level":3},{"id":"/notes/ts/book/declaration-merging#typescript-declaration-merging-声明合并","title":"TypeScript Declaration Merging (声明合并)","titles":[],"content":"Declaration Merging（声明合并）是 TypeScript 的一个独特功能，它允许开发者将多个声明合并成一个单一声明。这对于扩展现有类型和接口非常有用。在 TypeScript 中，声明合并主要应用于接口、命名空间和函数。","level":3},{"id":"/notes/ts/book/declaration-merging#接口合并","title":"接口合并","titles":[],"content":"当 TypeScript 遇到多个同名接口声明时，它会自动将它们合并成一个接口。这对于为现有接口添加属性或方法非常有用。","level":3},{"id":"/notes/ts/book/declaration-merging#示例接口合并","title":"示例：接口合并","titles":["接口合并"],"content":"在这个示例中，TypeScript 将两个    接口合并成一个包含    和    属性的接口。","level":4},{"id":"/notes/ts/book/declaration-merging#命名空间合并","title":"命名空间合并","titles":["接口合并","示例：接口合并"],"content":"命名空间的声明也可以合并。这在扩展现有命名空间时非常有用，例如为已有的命名空间添加新的函数、类或常量。","level":3},{"id":"/notes/ts/book/declaration-merging#示例命名空间合并","title":"示例：命名空间合并","titles":["接口合并","示例：接口合并","命名空间合并"],"content":"在这个示例中，两个    命名空间被合并，合并后的命名空间包含    接口、   常量和    类。","level":4},{"id":"/notes/ts/book/declaration-merging#函数合并","title":"函数合并","titles":["接口合并","示例：接口合并"],"content":"TypeScript 允许为同一个函数提供多个重载声明，这实际上是通过声明合并实现的。所有重载声明会被合并成一个函数声明。","level":3},{"id":"/notes/ts/book/declaration-merging#示例函数合并","title":"示例：函数合并","titles":["接口合并","示例：接口合并","函数合并"],"content":"在这个示例中，   函数有两个重载声明，一个接受两个数字参数，另一个接受两个字符串参数。最终的实现合并了这两个重载声明。","level":4},{"id":"/notes/ts/book/declaration-merging#类和命名空间合并","title":"类和命名空间合并","titles":["接口合并","示例：接口合并"],"content":"TypeScript 还允许类和命名空间进行合并。这在为一个类添加静态成员或扩展类功能时非常有用。","level":3},{"id":"/notes/ts/book/declaration-merging#示例类和命名空间合并","title":"示例：类和命名空间合并","titles":["接口合并","示例：接口合并","类和命名空间合并"],"content":"在这个示例中，   类和    命名空间合并，   命名空间中的    方法可以作为类的静态方法来使用。","level":4},{"id":"/notes/ts/book/declaration-merging#枚举和命名空间合并","title":"枚举和命名空间合并","titles":["接口合并","示例：接口合并"],"content":"TypeScript 还允许枚举和命名空间进行合并。这在为枚举添加静态方法时非常有用。","level":3},{"id":"/notes/ts/book/declaration-merging#示例枚举和命名空间合并","title":"示例：枚举和命名空间合并","titles":["接口合并","示例：接口合并","枚举和命名空间合并"],"content":"在这个示例中，   枚举和    命名空间合并，   命名空间中的    方法可以作为枚举的静态方法来使用。","level":4},{"id":"/notes/ts/book/declaration-merging#总结","title":"总结","titles":["接口合并","示例：接口合并"],"content":"TypeScript 的声明合并功能允许开发者以模块化和扩展的方式组织代码。通过接口合并、命名空间合并、函数合并、类与命名空间合并以及枚举与命名空间合并，可以轻松地扩展和组织代码，而不必担心名称冲突。了解和利用声明合并功能，可以帮助开发者更灵活地处理复杂的类型定义和模块化编程。","level":3},{"id":"/notes/ts/book/declaration-merging#参考","title":"参考","titles":["接口合并","示例：接口合并"],"content":"https://www.typescriptlang.org/docs/handbook/declaration-merging.html#handbook-content","level":3},{"id":"/notes/ts/book/jsx#_1-jsx-是什么","title":"1. JSX 是什么？","titles":[],"content":"JSX 是 JavaScript XML 的缩写，它允许开发者在 JavaScript 代码中直接编写类似 HTML 的结构。在 React 应用中，开发者可以使用 JSX 来声明组件的 UI 部分，例如：","level":3},{"id":"/notes/ts/book/jsx#_2-typescript-中的-jsx","title":"2. TypeScript 中的 JSX","titles":[],"content":"TypeScript 扩展了对 JSX 的支持，可以在 TypeScript 代码中使用 JSX 语法来描述 React 组件的结构。与普通 JavaScript 不同的是，TypeScript 提供了类型检查和类型推断功能，可以在编译时捕获潜在的类型错误。","level":3},{"id":"/notes/ts/book/jsx#_21-配置-typescript-支持-jsx","title":"2.1. 配置 TypeScript 支持 JSX","titles":["2. TypeScript 中的 JSX"],"content":"在 TypeScript 项目中，需要在    文件中配置    选项，以指定使用哪种 JSX 的语法：：指定使用 React 的 JSX 语法，这是在 React 应用中常见的配置。   ：保留 JSX，不进行转换，这在某些非 React 的项目中可能会使用到。","level":4},{"id":"/notes/ts/book/jsx#_22-typescript-中的-jsx-示例","title":"2.2. TypeScript 中的 JSX 示例","titles":["2. TypeScript 中的 JSX"],"content":"在 TypeScript 文件中，可以直接使用 JSX 语法编写 React 组件：","level":4},{"id":"/notes/ts/book/jsx#_3-typescript-对-jsx-的支持特性","title":"3. TypeScript 对 JSX 的支持特性","titles":["2. TypeScript 中的 JSX","2.2. TypeScript 中的 JSX 示例"],"content":"TypeScript 不仅支持基本的 JSX 语法，还提供了一些增强特性，例如：类型检查 ：检查 JSX 元素的属性是否符合预期的类型。   智能提示 ：提供与 JSX 相关的代码补全和文档提示。   属性扩展 ：支持使用展开操作符    扩展属性。   事件处理 ：对事件处理函数进行类型检查。","level":3},{"id":"/notes/ts/book/jsx#_4-注意事项","title":"4. 注意事项","titles":["2. TypeScript 中的 JSX","2.2. TypeScript 中的 JSX 示例"],"content":"在使用 TypeScript 开发 React 应用时，需要注意以下几点：命名空间冲突 ：JSX 中的    对应 HTML 的    属性，需要注意不要与 TypeScript 的    关键字混淆。   类型声明 ：确保为组件的 props、state 等定义良好的类型声明，以便 TypeScript 可以进行正确的类型推断和检查。","level":3},{"id":"/notes/ts/book/jsx#_5-总结","title":"5. 总结","titles":["2. TypeScript 中的 JSX","2.2. TypeScript 中的 JSX 示例"],"content":"JSX 是一种用于在 JavaScript 中编写类似 XML 结构的语法扩展，在 TypeScript 中，通过配置和类型系统的支持，可以使得在 React 应用中使用 JSX 更加高效和安全。合理配置    文件中的    选项，并且利用 TypeScript 提供的类型检查和智能提示功能，可以显著提升开发效率和代码质量。","level":3},{"id":"/notes/ts/book/jsx#参考","title":"参考","titles":["2. TypeScript 中的 JSX","2.2. TypeScript 中的 JSX 示例"],"content":"https://www.typescriptlang.org/docs/handbook/jsx.html#handbook-content","level":3},{"id":"/notes/ts/book/decorators#_1-基本概念","title":"1. 基本概念","titles":[],"content":"装饰器允许开发者通过注释或修饰类的方式来声明一些特性，这些特性包括：类装饰器 ：应用于类的声明之前，可以用来修改类的行为。   方法装饰器 ：应用于方法的声明之前，可以用来修改方法的行为。   访问器装饰器 ：应用于访问器（getter 和 setter）的声明之前，可以用来修改访问器的行为。   属性装饰器 ：应用于属性的声明之前，可以用来修改属性的行为。   参数装饰器 ：应用于函数参数的声明之前，可以用来修改参数的行为。","level":3},{"id":"/notes/ts/book/decorators#_2-使用装饰器的语法","title":"2. 使用装饰器的语法","titles":[],"content":"装饰器是一个函数，它接收三个参数：对于类成员（方法、属性、访问器或参数），装饰器的参数如下：\n   对于静态成员，是类的构造函数。  对于实例成员，是类的原型对象。  对于方法、访问器和属性，是成员的名称。  对于参数，是参数的索引。装饰器函数的实现可以是任何有效的 JavaScript 函数，通常返回一个函数或者直接操作传入的参数。","level":3},{"id":"/notes/ts/book/decorators#_3-示例","title":"3. 示例","titles":[],"content":"","level":3},{"id":"/notes/ts/book/decorators#_31-类装饰器示例","title":"3.1 类装饰器示例","titles":["3. 示例"],"content":"","level":4},{"id":"/notes/ts/book/decorators#_32-方法装饰器示例","title":"3.2 方法装饰器示例","titles":["3. 示例"],"content":"","level":4},{"id":"/notes/ts/book/decorators#_4-typescript-中的装饰器限制和注意事项","title":"4. TypeScript 中的装饰器限制和注意事项","titles":["3. 示例","3.2 方法装饰器示例"],"content":"实验性特性 ：装饰器目前仍处于实验阶段，可能会有语法和行为上的变化。   装饰器顺序 ：多个装饰器的执行顺序是从下到上、从右到左的。   装饰器应用目标 ：不同类型的装饰器只能应用于特定类型的声明（例如方法装饰器只能应用于方法）。   编译选项 ：使用装饰器需要将 TypeScript 编译器的    选项设置为   。","level":3},{"id":"/notes/ts/book/decorators#_5-总结","title":"5. 总结","titles":["3. 示例","3.2 方法装饰器示例"],"content":"装饰器是 TypeScript 中一个强大的特性，它使得可以通过简单的语法来修改类及其成员的行为，例如添加日志、验证等功能。虽然装饰器目前还是一个实验性特性，但在某些场景下可以提供非常有用的功能增强。在使用装饰器时，建议始终关注 TypeScript 和 JavaScript 的最新文档和规范，以确保正确和稳定的使用。","level":3},{"id":"/notes/ts/book/decorators#参考","title":"参考","titles":["3. 示例","3.2 方法装饰器示例"],"content":"https://www.typescriptlang.org/docs/handbook/decorators.html#handbook-content","level":3},{"id":"/notes/ts/book/mixins#_1-mixin-的基本概念","title":"1. Mixin 的基本概念","titles":[],"content":"Mixin 是一种设计模式，它通过组合多个类（或对象）的特性来创建一个新的类。在 TypeScript 中，通常使用一些技术（如交叉类型和类型断言）来实现 Mixin。","level":3},{"id":"/notes/ts/book/mixins#_2-实现-mixin-的方法","title":"2. 实现 Mixin 的方法","titles":[],"content":"","level":3},{"id":"/notes/ts/book/mixins#_21-基于类的-mixin","title":"2.1. 基于类的 Mixin","titles":["2. 实现 Mixin 的方法"],"content":"基于类的 Mixin 是通过将现有类的方法和属性合并到新的类中来实现的。例如，假设有一个 Logger Mixin，它可以将日志记录功能添加到类中：","level":4},{"id":"/notes/ts/book/mixins#_22-基于函数的-mixin","title":"2.2. 基于函数的 Mixin","titles":["2. 实现 Mixin 的方法"],"content":"基于函数的 Mixin 使用函数返回一个具有特定特性的对象，而不是一个类。这种方法更灵活，适用于需要动态组合功能的场景。","level":4},{"id":"/notes/ts/book/mixins#_3-mixin-的优势和注意事项","title":"3. Mixin 的优势和注意事项","titles":["2. 实现 Mixin 的方法","2.2. 基于函数的 Mixin"],"content":"优势 ：    避免类层次结构过深 ：通过 Mixin 可以避免创建过深的类继承层次结构。   灵活性 ：可以根据需求动态组合类的特性，而不是硬编码在类定义中。   复用性 ：可以将相同的 Mixin 应用于多个类，提高代码复用性。   注意事项 ：    命名冲突 ：当多个 Mixin 中存在相同名称的方法或属性时，可能会引起命名冲突，需要适当处理。   装饰器替代 ：在某些情况下，装饰器可能更适合用于添加类的额外功能，因为装饰器提供了更好的语法支持和类型安全性。","level":3},{"id":"/notes/ts/book/mixins#_4-总结","title":"4. 总结","titles":["2. 实现 Mixin 的方法","2.2. 基于函数的 Mixin"],"content":"Mixin 是一种强大的设计模式，允许开发者通过组合类的方式来创建具有多个功能的新类。在 TypeScript 中，可以通过基于类的方法或基于函数的方法实现 Mixin。使用 Mixin 可以避免类继承层次结构过深的问题，并提高代码的灵活性和复用性。然而，在使用 Mixin 时需要注意命名冲突和适当的设计，以确保代码的清晰和可维护性。","level":3},{"id":"/notes/ts/book/mixins#参考","title":"参考","titles":["2. 实现 Mixin 的方法","2.2. 基于函数的 Mixin"],"content":"https://www.typescriptlang.org/docs/handbook/mixins.html#handbook-content","level":3},{"id":"/notes/ts/book/triple-slash-directives#三斜线指令triple-slash-directives","title":"三斜线指令(Triple-Slash Directives)","titles":[],"content":"三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。三斜线指令  仅 可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。","level":1},{"id":"/notes/ts/book/triple-slash-directives#reference-path","title":"/// <reference path=\"...\" />","titles":["三斜线指令(Triple-Slash Directives)"],"content":"指令是三斜线指令中最常见的一种。 它用于声明文件间的   依赖 。三斜线引用告诉编译器在编译过程中要引入的额外的文件。当使用  或  时，它也可以做为调整输出内容顺序的一种方法。 文件在输出文件内容中的位置与经过预处理后的输入顺序一致。","level":2},{"id":"/notes/ts/book/triple-slash-directives#预处理输入文件","title":"预处理输入文件","titles":["三斜线指令(Triple-Slash Directives)","/// <reference path=\"...\" />"],"content":"编译器会对输入文件进行预处理来解析所有三斜线引用指令。 在这个过程中，额外的文件会加到编译过程中。这个过程会以一些  根文件 开始； 它们是在命令行中指定的文件或是在   中的  列表里的文件。 这些根文件按指定的顺序进行预处理。 在一个文件被加入列表前，它包含的所有三斜线引用都要被处理，还有它们包含的目标。 三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析。一个三斜线引用路径是相对于包含它的文件的，如果不是根文件。","level":3},{"id":"/notes/ts/book/triple-slash-directives#错误","title":"错误","titles":["三斜线指令(Triple-Slash Directives)","/// <reference path=\"...\" />"],"content":"引用不存在的文件会报错。 一个文件用三斜线指令引用自己会报错。","level":3},{"id":"/notes/ts/book/triple-slash-directives#使用-noresolve","title":"使用   --noResolve","titles":["三斜线指令(Triple-Slash Directives)","/// <reference path=\"...\" />"],"content":"如果指定了  编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。","level":3},{"id":"/notes/ts/book/triple-slash-directives#reference-types","title":"/// <reference types=\"...\" />","titles":["三斜线指令(Triple-Slash Directives)"],"content":"与   指令相似，这个指令是用来声明   依赖 的； 一个   指令则声明了对某个包的依赖。对这些包的名字的解析与在   语句里对模块名的解析类似。 可以简单地把三斜线类型引用指令当做   声明的包。例如，把   引入到声明文件，表明这个文件使用了   里面声明的名字； 并且，这个包需要在编译阶段与声明文件一起被包含进来。仅当在你需要写一个  文件时才使用这个指令。对于那些在编译阶段生成的声明文件，编译器会自动地添加  ；   当且仅当 结果文件中使用了引用的包里的声明时才会在生成的声明文件里添加  语句。若要在  文件里声明一个对  包的依赖，使用  命令行选项或在  里指定。 查看   在  里使用  ，  和  了解详情。","level":2},{"id":"/notes/ts/book/triple-slash-directives#reference-no-default-libtrue","title":"/// <reference no-default-lib=\"true\"/>","titles":["三斜线指令(Triple-Slash Directives)"],"content":"这个指令把一个文件标记成  默认库 。 你会在   文件和它不同的变体的顶端看到这个注释。这个指令告诉编译器在编译过程中  不要 包含这个默认库（比如，  ）。 这与在命令行上使用   相似。还要注意，当传递了  时，编译器只会忽略检查带有  的文件。","level":2},{"id":"/notes/ts/book/triple-slash-directives#amd-module","title":"/// <amd-module />","titles":["三斜线指令(Triple-Slash Directives)"],"content":"默认情况下生成的AMD模块都是匿名的。 但是，当一些工具需要处理生成的模块时会产生问题，比如   。指令允许给编译器传入一个可选的模块名：","level":2},{"id":"/notes/ts/book/triple-slash-directives#amdmodulets","title":"amdModule.ts","titles":["三斜线指令(Triple-Slash Directives)","/// <amd-module />"],"content":"这会将  传入到AMD   函数里：","level":5},{"id":"/notes/ts/book/triple-slash-directives#amdmodulejs","title":"amdModule.js","titles":["三斜线指令(Triple-Slash Directives)","/// <amd-module />"],"content":"","level":5},{"id":"/notes/ts/book/triple-slash-directives#amd-dependency","title":"/// <amd-dependency />","titles":["三斜线指令(Triple-Slash Directives)"],"content":"注意 ：这个指令被废弃了。使用  语句代替。告诉编译器有一个非TypeScript模块依赖需要被注入，做为目标模块  调用的一部分。指令也可以带一个可选的  属性；它允许我们为amd-dependency传入一个可选名字：生成的JavaScript代码：","level":2},{"id":"/notes/ts/book/triple-slash-directives#参考","title":"参考","titles":["三斜线指令(Triple-Slash Directives)","/// <amd-dependency />"],"content":"https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html","level":3},{"id":"/notes/ts/book/type-checking-javascript-files#javascript-文件类型检查","title":"JavaScript 文件类型检查","titles":[],"content":"TypeScript 2.3 以后的版本支持使用  对  文件进行类型检查和错误提示。你可以通过添加  注释来忽略类型检查；相反，你可以通过去掉  设置并添加一个  注释来选则检查某些  文件。 你还可以使用  来忽略本行的错误。 如果你使用了  ，JS 检查将遵照一些严格检查标记，如  ，  等。 但因为 JS 检查是相对宽松的，在使用严格标记时可能会有些出乎意料的情况。对比  文件和  文件在类型检查上的差异，有如下几点需要注意：","level":1},{"id":"/notes/ts/book/type-checking-javascript-files#用-jsdoc-类型表示类型信息","title":"用 JSDoc 类型表示类型信息","titles":["JavaScript 文件类型检查"],"content":"文件里，类型可以和在  文件里一样被推断出来。 同样地，当类型不能被推断时，它们可以通过 JSDoc 来指定，就好比在  文件里那样。 如同 TypeScript，  会在编译器无法推断类型的位置报错。 （除了对象字面量的情况；后面会详细介绍）JSDoc 注解修饰的声明会被设置为这个声明的类型。比如：你可以在这里找到所有 JSDoc 支持的模式，  JSDoc 文档 。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#属性的推断来自于类内的赋值语句","title":"属性的推断来自于类内的赋值语句","titles":["JavaScript 文件类型检查"],"content":"ES2015 没提供声明类属性的方法。属性是动态赋值的，就像对象字面量一样。在  文件里，编译器从类内部的属性赋值语句来推断属性类型。 属性的类型是在构造函数里赋的值的类型，除非它没在构造函数里定义或者在构造函数里是  或  。 若是这种情况，类型将会是所有赋的值的类型的联合类型。 在构造函数里定义的属性会被认为是一直存在的，然而那些在方法，存取器里定义的属性被当成可选的。如果一个属性从没在类内设置过，它们会被当成未知的。如果类的属性只是读取用的，那么就在构造函数里用 JSDoc 声明它的类型。 如果它稍后会被初始化，你甚至都不需要在构造函数里给它赋值：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#构造函数等同于类","title":"构造函数等同于类","titles":["JavaScript 文件类型检查"],"content":"ES2015 以前，Javascript 使用构造函数代替类。 编译器支持这种模式并能够将构造函数识别为 ES2015 的类。 属性类型推断机制和上面介绍的一致。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#支持-commonjs-模块","title":"支持 CommonJS 模块","titles":["JavaScript 文件类型检查"],"content":"在  文件里，TypeScript 能识别出 CommonJS 模块。 对  和  的赋值被识别为导出声明。 相似地，  函数调用被识别为模块导入。例如：对 JavaScript 文件里模块语法的支持比在 TypeScript 里宽泛多了。 大部分的赋值和声明方式都是允许的。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#类函数和对象字面量是命名空间","title":"类，函数和对象字面量是命名空间","titles":["JavaScript 文件类型检查"],"content":"文件里的类是命名空间。 它可以用于嵌套类，比如：ES2015 之前的代码，它可以用来模拟静态方法：它还可以用于创建简单的命名空间：同时还支持其它的变化：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#对象字面量是开放的","title":"对象字面量是开放的","titles":["JavaScript 文件类型检查"],"content":"文件里，用对象字面量初始化一个变量的同时也给它声明了类型。 新的成员不能再被添加到对象字面量中。 这个规则在  文件里被放宽了；对象字面量具有开放的类型，允许添加并访问原先没有定义的属性。例如：对象字面量的表现就好比具有一个默认的索引签名  ，它们可以被当成开放的映射而不是封闭的对象。与其它 JS 检查行为相似，这种行为可以通过指定 JSDoc 类型来改变，例如：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#nullundefined和空数组的类型是-any-或-any","title":"null，undefined，和空数组的类型是 any 或 any","titles":["JavaScript 文件类型检查"],"content":"任何用  ，  初始化的变量，参数或属性，它们的类型是  ，就算是在严格  检查模式下。 任何用  初始化的变量，参数或属性，它们的类型是  ，就算是在严格  检查模式下。 唯一的例外是像上面那样有多个初始化器的属性。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#函数参数是默认可选的","title":"函数参数是默认可选的","titles":["JavaScript 文件类型检查"],"content":"由于在 ES2015 之前无法指定可选参数，因此  文件里所有函数参数都被当做是可选的。 使用比预期少的参数调用函数是允许的。需要注意的一点是，使用过多的参数调用函数会得到一个错误。例如：使用 JSDoc 注解的函数会被从这条规则里移除。 使用 JSDoc 可选参数语法来表示可选性。比如：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#由arguments推断出的-var-args-参数声明","title":"由  arguments 推断出的 var-args 参数声明","titles":["JavaScript 文件类型检查"],"content":"如果一个函数的函数体内有对  的引用，那么这个函数会隐式地被认为具有一个 var-arg 参数（比如:  )）。使用 JSDoc 的 var-arg 语法来指定  的类型。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#未指定的类型参数默认为any","title":"未指定的类型参数默认为  any","titles":["JavaScript 文件类型检查"],"content":"由于 JavaScript 里没有一种自然的语法来指定泛型参数，因此未指定的参数类型默认为  。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#在-extends-语句中","title":"在 extends 语句中：","titles":["JavaScript 文件类型检查","未指定的类型参数默认为  any"],"content":"例如，  被定义成具有两个类型参数，  和  。 在一个  文件里，没有一个合法的方式在 extends 语句里指定它们。默认地参数类型为  ：使用 JSDoc 的  来明确地指定类型。例如：","level":3},{"id":"/notes/ts/book/type-checking-javascript-files#在-jsdoc-引用中","title":"在 JSDoc 引用中：","titles":["JavaScript 文件类型检查","未指定的类型参数默认为  any"],"content":"JSDoc 里未指定的类型参数默认为  ：","level":3},{"id":"/notes/ts/book/type-checking-javascript-files#在函数调用中","title":"在函数调用中","titles":["JavaScript 文件类型检查","未指定的类型参数默认为  any"],"content":"泛型函数的调用使用  来推断泛型参数。有时候，这个流程不能够推断出类型，大多是因为缺少推断的源；在这种情况下，类型参数类型默认为  。例如：","level":3},{"id":"/notes/ts/book/type-checking-javascript-files#支持的-jsdoc","title":"支持的 JSDoc","titles":[],"content":"下面的列表列出了当前所支持的 JSDoc 注解，你可以用它们在 JavaScript 文件里添加类型信息。注意，没有在下面列出的标记（例如  ）都是还不支持的。(or    or   )    (or   )          (or   )      (or   )它们代表的意义与 usejsdoc.org 上面给出的通常是一致的或者是它的超集。 下面的代码描述了它们的区别并给出了一些示例。","level":1},{"id":"/notes/ts/book/type-checking-javascript-files#type","title":"@type","titles":["支持的 JSDoc"],"content":"可以使用  标记并引用一个类型名称（原始类型，TypeScript 里声明的类型，或在 JSDoc 里  标记指定的） 可以使用任何 TypeScript 类型和大多数 JSDoc 类型。可以指定联合类型—例如，  和  类型的联合。注意，括号是可选的。有多种方式来指定数组类型：还可以指定对象字面量类型。 例如，一个带有  （字符串）和  （数字）属性的对象，使用下面的语法：可以使用字符串和数字索引签名来指定  和  的对象，使用标准的 JSDoc 语法或者 TypeScript 语法。这两个类型与 TypeScript 里的  和  是等同的。编译器能识别出这两种语法。可以使用 TypeScript 或 Closure 语法指定函数类型。或者直接使用未指定的  类型：Closure 的其它类型也可以使用：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#转换","title":"转换","titles":["支持的 JSDoc","@type"],"content":"TypeScript 借鉴了 Closure 里的转换语法。 在括号表达式前面使用  标记，可以将一种类型转换成另一种类型","level":3},{"id":"/notes/ts/book/type-checking-javascript-files#导入类型","title":"导入类型","titles":["支持的 JSDoc","@type"],"content":"可以使用导入类型从其它文件中导入声明。 这个语法是 TypeScript 特有的，与 JSDoc 标准不同：导入类型也可以使用在类型别名声明中：导入类型可以用在从模块中得到一个值的类型。","level":3},{"id":"/notes/ts/book/type-checking-javascript-files#param和returns","title":"@param 和  @returns","titles":["支持的 JSDoc"],"content":"语法和  相同，但增加了一个参数名。 使用  可以把参数声明为可选的：函数的返回值类型也是类似的：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#typedef-callback-和-param","title":"@typedef ,   @callback , 和   @param","titles":["支持的 JSDoc"],"content":"可以用来声明复杂类型。 和  类似的语法。可以在第一行上使用  或  。允许使用相似的语法。 注意，嵌套的属性名必须使用参数名做为前缀：与  相似，但它指定函数类型而不是对象类型：当然，所有这些类型都可以使用 TypeScript 的语法  在一行上声明：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#template","title":"@template","titles":["支持的 JSDoc"],"content":"使用  声明泛型：用逗号或多个标记来声明多个类型参数：还可以在参数名前指定类型约束。 只有列表的第一项类型参数会被约束：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#constructor","title":"@constructor","titles":["支持的 JSDoc"],"content":"编译器通过  属性的赋值来推断构造函数，但你可以让检查更严格提示更友好，你可以添加一个  标记：通过  ，  将在构造函数  里被检查，因此你在  方法里得到一个提示，如果你传入一个数字你还将得到一个错误提示。如果你直接调用  而不是构造它，也会得到一个错误。不幸的是，这意味着那些既能构造也能直接调用的构造函数不能使用  。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#this","title":"@this","titles":["支持的 JSDoc"],"content":"编译器通常可以通过上下文来推断出  的类型。但你可以使用  来明确指定它的类型：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#extends","title":"@extends","titles":["支持的 JSDoc"],"content":"当 JavaScript 类继承了一个基类，无处指定类型参数的类型。而  标记提供了这样一种方式：注意  只作用于类。当前，无法实现构造函数继承类的情况。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#enum","title":"@enum","titles":["支持的 JSDoc"],"content":"标记允许你创建一个对象字面量，它的成员都有确定的类型。不同于 JavaScript 里大多数的对象字面量，它不允许添加额外成员。注意  与 TypeScript 的  大不相同，它更加简单。然而，不同于 TypeScript 的枚举，  可以是任何类型：","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#更多示例","title":"更多示例","titles":["支持的 JSDoc"],"content":"","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#已知不支持的模式","title":"已知不支持的模式","titles":["支持的 JSDoc"],"content":"在值空间中将对象视为类型是不可以的，除非对象创建了类型，如构造函数。对象字面量属性上的  后缀不能指定这个属性是可选的：类型只在启用了  检查时才启作用：类型没有意义，以其原类型对待：不同于 JSDoc 类型系统，TypeScript 只允许将类型标记为包不包含  。 没有明确的   -- 如果启用了  ，那么  是非  的。 如果没有启用，那么  是可以为  的。","level":2},{"id":"/notes/ts/book/type-checking-javascript-files#参考","title":"参考","titles":["支持的 JSDoc","已知不支持的模式"],"content":"https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#handbook-content","level":3},{"id":"/notes/ts/declaration-files/introduction#_1-声明文件的作用","title":"1. 声明文件的作用","titles":[],"content":"TypeScript 的类型系统需要了解每个变量、函数、类和模块的类型。对于 JavaScript 代码库，特别是那些没有原生支持 TypeScript 的第三方库，TypeScript 需要额外的声明文件来描述这些库的类型信息。声明文件告诉 TypeScript 每个符号的类型、结构和如何使用它们。","level":3},{"id":"/notes/ts/declaration-files/introduction#_2-使用声明文件","title":"2. 使用声明文件","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/introduction#通过-definitelytyped","title":"通过 DefinitelyTyped","titles":["2. 使用声明文件"],"content":"大多数常见的第三方 JavaScript 库都已经有了相应的声明文件，这些声明文件通常托管在 DefinitelyTyped 社区。可以通过以下几种方式获取和使用声明文件：npm 安装 ：很多声明文件都已经发布到 npm 上，可以通过    包前缀进行安装。     手动下载 ：可以直接从 DefinitelyTyped 的 GitHub 仓库手动下载声明文件，并将其放置在项目中。","level":4},{"id":"/notes/ts/declaration-files/introduction#编写自定义声明文件","title":"编写自定义声明文件","titles":["2. 使用声明文件"],"content":"如果要使用的库没有相关的声明文件，或者需要自定义类型声明，可以编写自己的声明文件。文件命名约定 ：声明文件通常以    为后缀，比如   。   声明文件语法 ：使用 TypeScript 的声明语法描述变量、函数、类、接口等的类型信息。     全局变量声明 ：描述全局变量的类型信息。","level":4},{"id":"/notes/ts/declaration-files/introduction#_3-使用声明文件的注意事项","title":"3. 使用声明文件的注意事项","titles":["2. 使用声明文件","编写自定义声明文件"],"content":"全局声明 ：如果声明文件定义了全局变量或全局模块，在使用之前需要确保它们在全局作用域中可用。   模块声明 ：如果声明文件定义了模块内的类型信息，需要使用    或    来导入声明的类型。   类型合并 ：可以通过声明合并（Declaration Merging）来扩展已有类型的定义。","level":3},{"id":"/notes/ts/declaration-files/introduction#_4-示例应用","title":"4. 示例应用","titles":["2. 使用声明文件","编写自定义声明文件"],"content":"假设有一个 JavaScript 库   ，我们想在 TypeScript 中使用它，但是它没有类型定义文件：为了在 TypeScript 中使用，我们可以编写一个声明文件   ：然后在 TypeScript 项目中导入和使用该模块：","level":3},{"id":"/notes/ts/declaration-files/introduction#_5-自动生成声明文件","title":"5. 自动生成声明文件","titles":["2. 使用声明文件","编写自定义声明文件"],"content":"对于自己编写的 TypeScript 代码，TypeScript 编译器会自动为每个 TypeScript 文件生成相应的声明文件（  ），这些文件包含了已声明的类型信息，可以被其他 TypeScript 项目导入和使用。","level":3},{"id":"/notes/ts/declaration-files/introduction#总结","title":"总结","titles":["2. 使用声明文件","编写自定义声明文件"],"content":"TypeScript 声明文件是一种重要的工具，用于描述 JavaScript 库的类型信息，使得 TypeScript 可以进行类型检查和智能提示。通过使用已有的声明文件或编写自定义的声明文件，可以很好地整合第三方 JavaScript 库到 TypeScript 项目中，并获得类型安全和开发效率的提升。","level":3},{"id":"/notes/ts/declaration-files/introduction#参考","title":"参考","titles":["2. 使用声明文件","编写自定义声明文件"],"content":"https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html","level":3},{"id":"/notes/ts/declaration-files/library-structures#_1-基本结构","title":"1. 基本结构","titles":[],"content":"一个典型的 TypeScript 库通常包含以下基本元素：源代码文件夹 （src）：存放 TypeScript 源码文件。   编译输出文件夹 （dist 或 lib）：存放编译后的 JavaScript 文件（如果需要发布给用户）。   类型声明文件夹 （types 或 typings）：存放 TypeScript 声明文件（  ）。","level":3},{"id":"/notes/ts/declaration-files/library-structures#_2-设计原则和最佳实践","title":"2. 设计原则和最佳实践","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/library-structures#_21-使用-es-模块","title":"2.1. 使用 ES 模块","titles":["2. 设计原则和最佳实践"],"content":"推荐使用 ES 模块作为默认的模块格式，因为它提供了静态分析、树摇（去除未使用代码）和更清晰的语法。如果需要兼容 CommonJS（例如在 Node.js 中使用），可以通过工具进行转换或使用条件导出。","level":4},{"id":"/notes/ts/declaration-files/library-structures#_22-利用命名空间和模块","title":"2.2. 利用命名空间和模块","titles":["2. 设计原则和最佳实践"],"content":"命名空间（Namespace） ：用于将相关的类型和函数组织在一起，但在现代 TypeScript 开发中，推荐使用 ES 模块来代替命名空间。     模块（Module） ：用于将相关的代码组织成一个独立的单元，可以导出和导入模块中的内容。","level":4},{"id":"/notes/ts/declaration-files/library-structures#_23-声明文件","title":"2.3. 声明文件","titles":["2. 设计原则和最佳实践"],"content":"对于每个 TypeScript 文件，TypeScript 编译器会自动生成对应的声明文件（  ），如果需要自定义声明，可以创建单独的声明文件。","level":4},{"id":"/notes/ts/declaration-files/library-structures#_24-模块化的组织方式","title":"2.4. 模块化的组织方式","titles":["2. 设计原则和最佳实践"],"content":"根据功能和使用频率，将功能相关的代码组织成模块，并尽可能减少模块之间的耦合。可以通过模块的导入和导出来管理模块之间的依赖关系。","level":4},{"id":"/notes/ts/declaration-files/library-structures#_25-编译和构建","title":"2.5. 编译和构建","titles":["2. 设计原则和最佳实践"],"content":"在    中配置编译选项，确保 TypeScript 编译器可以正确地将 TypeScript 代码转换为 JavaScript 代码，并生成声明文件。","level":4},{"id":"/notes/ts/declaration-files/library-structures#_3-示例应用","title":"3. 示例应用","titles":["2. 设计原则和最佳实践","2.5. 编译和构建"],"content":"假设有一个名为    的 TypeScript 库，可以按以下结构组织代码：在    中导出库的主要功能，例如：然后在    中配置编译选项，生成 JavaScript 文件和声明文件到    和    目录。","level":3},{"id":"/notes/ts/declaration-files/library-structures#_4-发布和文档化","title":"4. 发布和文档化","titles":["2. 设计原则和最佳实践","2.5. 编译和构建"],"content":"发布 TypeScript 库时，可以使用 npm 进行发布，并确保包含编译后的 JavaScript 文件和相应的声明文件。另外，编写清晰的文档（如 README.md 文件）来说明库的用途、安装方法和使用示例，提高库的易用性和可维护性。","level":3},{"id":"/notes/ts/declaration-files/library-structures#总结","title":"总结","titles":["2. 设计原则和最佳实践","2.5. 编译和构建"],"content":"设计和组织 TypeScript 库的结构是一个综合考虑功能模块化、依赖管理、编译配置和发布流程的过程。通过合理的结构设计，可以使得库更易于维护、扩展和使用，提高代码的可读性和可靠性。","level":3},{"id":"/notes/ts/declaration-files/library-structures#参考","title":"参考","titles":["2. 设计原则和最佳实践","2.5. 编译和构建"],"content":"https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html","level":3},{"id":"/notes/ts/declaration-files/by-example#_1-全局变量","title":"1. 全局变量","titles":[],"content":"假设要声明一个全局变量   ，它是一个字符串类型。","level":3},{"id":"/notes/ts/declaration-files/by-example#typescript-声明文件","title":"TypeScript 声明文件","titles":["1. 全局变量"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#api-文档","title":"API 文档","titles":["1. 全局变量"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#示例","title":"示例","titles":["1. 全局变量"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#_2-全局函数","title":"2. 全局函数","titles":["1. 全局变量","示例"],"content":"假设要声明一个全局函数   ，它接受一个字符串参数并返回一个字符串。","level":3},{"id":"/notes/ts/declaration-files/by-example#typescript-声明文件-1","title":"TypeScript 声明文件","titles":["1. 全局变量","示例","2. 全局函数"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#api-文档-1","title":"API 文档","titles":["1. 全局变量","示例","2. 全局函数"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#示例-1","title":"示例","titles":["1. 全局变量","示例","2. 全局函数"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#_3-带属性的对象","title":"3. 带属性的对象","titles":["1. 全局变量","示例"],"content":"假设要声明一个对象   ，它有一个属性    和一个方法   。","level":3},{"id":"/notes/ts/declaration-files/by-example#typescript-声明文件-2","title":"TypeScript 声明文件","titles":["1. 全局变量","示例","3. 带属性的对象"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#api-文档-2","title":"API 文档","titles":["1. 全局变量","示例","3. 带属性的对象"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#示例-2","title":"示例","titles":["1. 全局变量","示例","3. 带属性的对象"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#_4-函数重载","title":"4. 函数重载","titles":["1. 全局变量","示例"],"content":"假设要声明一个函数   ，它根据传入参数的类型不同有不同的行为。","level":3},{"id":"/notes/ts/declaration-files/by-example#typescript-声明文件-3","title":"TypeScript 声明文件","titles":["1. 全局变量","示例","4. 函数重载"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#api-文档-3","title":"API 文档","titles":["1. 全局变量","示例","4. 函数重载"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#示例-3","title":"示例","titles":["1. 全局变量","示例","4. 函数重载"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#_5-可重用类型接口","title":"5. 可重用类型（接口）","titles":["1. 全局变量","示例"],"content":"假设要声明一个接口   ，描述一个人的基本信息。","level":3},{"id":"/notes/ts/declaration-files/by-example#typescript-声明文件-4","title":"TypeScript 声明文件","titles":["1. 全局变量","示例","5. 可重用类型（接口）"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#api-文档-4","title":"API 文档","titles":["1. 全局变量","示例","5. 可重用类型（接口）"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#示例-4","title":"示例","titles":["1. 全局变量","示例","5. 可重用类型（接口）"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#_6-可重用类型类型别名","title":"6. 可重用类型（类型别名）","titles":["1. 全局变量","示例"],"content":"假设要声明一个类型别名   ，用于描述坐标的类型。","level":3},{"id":"/notes/ts/declaration-files/by-example#typescript-声明文件-5","title":"TypeScript 声明文件","titles":["1. 全局变量","示例","6. 可重用类型（类型别名）"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#api-文档-5","title":"API 文档","titles":["1. 全局变量","示例","6. 可重用类型（类型别名）"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#示例-5","title":"示例","titles":["1. 全局变量","示例","6. 可重用类型（类型别名）"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#_7-组织类型","title":"7. 组织类型","titles":["1. 全局变量","示例"],"content":"假设要声明一个类   ，它有一个构造函数和一些实例方法。","level":3},{"id":"/notes/ts/declaration-files/by-example#typescript-声明文件-6","title":"TypeScript 声明文件","titles":["1. 全局变量","示例","7. 组织类型"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#api-文档-6","title":"API 文档","titles":["1. 全局变量","示例","7. 组织类型"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#示例-6","title":"示例","titles":["1. 全局变量","示例","7. 组织类型"],"content":"","level":4},{"id":"/notes/ts/declaration-files/by-example#总结","title":"总结","titles":["1. 全局变量","示例"],"content":"编写高质量的 TypeScript 声明文件需要结合清晰的 API 文档和实际示例，确保用户可以轻松理解和正确使用你的库。通过合理的组织和描述，可以提升代码的可读性、可维护性，以及 TypeScript 的类型推断和类型安全检查效果。","level":3},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#_1-普通类型","title":"1. 普通类型","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#正常用例","title":"正常用例","titles":["1. 普通类型"],"content":"普通类型指的是 TypeScript 中的基本数据类型和自定义类型。这些类型可以用来声明变量、函数参数、返回值等。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#错误用例","title":"错误用例","titles":["1. 普通类型"],"content":"错误的使用方式包括将变量赋予不匹配的类型或者在函数调用时传递不符合类型预期的参数。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#_2-泛型","title":"2. 泛型","titles":["1. 普通类型","错误用例"],"content":"泛型允许在定义函数、类或接口时延迟指定类型，提高代码的复用性和灵活性。","level":3},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#正常用例-1","title":"正常用例","titles":["1. 普通类型","错误用例","2. 泛型"],"content":"使用泛型可以在定义函数或类时不指定具体类型，而是在使用时根据传入的参数类型来确定。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#错误用例-1","title":"错误用例","titles":["1. 普通类型","错误用例","2. 泛型"],"content":"在泛型使用中的错误通常涉及类型不匹配或不正确的用法。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#_3-回调函数类型","title":"3. 回调函数类型","titles":["1. 普通类型","错误用例"],"content":"回调函数类型是指在 TypeScript 中定义函数参数时指定函数的类型。","level":3},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#正常用例-2","title":"正常用例","titles":["1. 普通类型","错误用例","3. 回调函数类型"],"content":"使用回调函数类型可以确保函数接受正确类型的函数作为参数。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#错误用例-2","title":"错误用例","titles":["1. 普通类型","错误用例","3. 回调函数类型"],"content":"错误的回调函数类型使用可能导致参数类型不匹配或函数调用失败。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#_4-函数重载","title":"4. 函数重载","titles":["1. 普通类型","错误用例"],"content":"函数重载允许定义多个函数签名来处理不同的参数类型或数量，提高函数的灵活性和适用性。","level":3},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#正常用例-3","title":"正常用例","titles":["1. 普通类型","错误用例","4. 函数重载"],"content":"通过合理定义函数重载，可以根据不同的参数类型或数量调用不同的函数实现。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#错误用例-3","title":"错误用例","titles":["1. 普通类型","错误用例","4. 函数重载"],"content":"错误的函数重载定义或调用可能导致函数无法正确识别参数类型。示例：","level":4},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#总结","title":"总结","titles":["1. 普通类型","错误用例"],"content":"遵循 TypeScript 规范，正确使用普通类型、泛型、回调函数类型和函数重载是确保代码类型安全性和可维护性的重要步骤。通过合理的类型定义和使用，可以有效减少运行时错误，并提升代码的可读性和可靠性。","level":3},{"id":"/notes/ts/declaration-files/do-s-and-don-ts#参考","title":"参考","titles":["1. 普通类型","错误用例"],"content":"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html","level":3},{"id":"/notes/ts/declaration-files/templates#global-modifying-moduledts","title":"global-modifying-module.d.ts","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/templates#global-plugindts","title":"global-plugin.d.ts","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/templates#globaldts","title":"global.d.ts","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/templates#module-classdts","title":"module-class.d.ts","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/templates#module-functiondts","title":"module-function.d.ts","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/templates#module-plugindts","title":"module-plugin.d.ts","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/templates#moduledts","title":"module.d.ts","titles":[],"content":"","level":3},{"id":"/notes/ts/declaration-files/templates#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html","level":3},{"id":"/notes/ts/declaration-files/publishing#_1-准备项目","title":"1. 准备项目","titles":[],"content":"首先，确保你的 TypeScript 项目已经完成开发，并通过 TypeScript 编译器（  ）将 TypeScript 代码编译为 JavaScript。项目中应包含以下关键文件：：项目的配置文件，包含项目的名称、版本、依赖等信息。  编译后的 JavaScript 文件（通常位于    或    目录下）。  TypeScript 声明文件（   文件），如果有的话。","level":3},{"id":"/notes/ts/declaration-files/publishing#_2-配置-packagejson","title":"2. 配置   package.json","titles":[],"content":"在    文件中，需要做以下几个关键配置：name ：包的名称，确保它在 npm 中是唯一的。   version ：包的版本号。   main ：指定入口文件，通常是编译后的 JavaScript 文件。   typings ：指定 TypeScript 声明文件的入口文件（如果有的话）。   license ：指定项目的许可证类型。   dependencies  和   devDependencies ：列出项目的依赖，确保所有依赖都被正确声明。例如，一个简单的    配置可能如下所示：","level":3},{"id":"/notes/ts/declaration-files/publishing#_3-构建项目","title":"3. 构建项目","titles":[],"content":"确保你的项目可以成功构建并生成编译后的 JavaScript 文件和 TypeScript 声明文件。你可以使用    命令来进行手动编译，或者配置构建脚本在    中自动执行。运行    或    来执行构建。","level":3},{"id":"/notes/ts/declaration-files/publishing#_4-登录-npm-账号","title":"4. 登录 npm 账号","titles":[],"content":"在发布之前，你需要登录你的 npm 账号。如果没有账号，可以使用    命令注册一个新账号。","level":3},{"id":"/notes/ts/declaration-files/publishing#_5-发布到-npm","title":"5. 发布到 npm","titles":[],"content":"完成上述步骤后，即可进行发布。登录 npm 账号 ：     发布包 ：    如果是第一次发布该包，可能需要添加    参数来确保包对所有人可见：","level":3},{"id":"/notes/ts/declaration-files/publishing#_6-验证发布","title":"6. 验证发布","titles":[],"content":"发布完成后，可以访问 npm 上的包页面，确认包已经成功发布。确保可以安装包并使用。","level":3},{"id":"/notes/ts/declaration-files/publishing#_7-发布-typescript-声明文件","title":"7. 发布 TypeScript 声明文件","titles":[],"content":"如果你的项目包含 TypeScript 声明文件，确保它们也包含在你的发布包中，并在    中正确配置    字段。通常情况下，编译后的 JavaScript 文件和 TypeScript 声明文件应该位于    目录（或其他类似目录）下，并在    中相应地引用。","level":3},{"id":"/notes/ts/declaration-files/publishing#示例完整的发布流程","title":"示例：完整的发布流程","titles":[],"content":"假设你的项目名称为   ，包含了一个主文件    和 TypeScript 声明文件   ，你可以按照以下步骤进行发布：确保项目构建成功：    登录 npm 账号：    发布包：    验证发布：  访问    确认包已经发布成功。通过以上步骤，你可以成功地发布你的 TypeScript 项目，并包含 TypeScript 声明文件以供其他开发者使用和引用。","level":3},{"id":"/notes/ts/declaration-files/publishing#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html","level":3},{"id":"/notes/ts/declaration-files/consumption#使用","title":"使用","titles":[],"content":"在TypeScript 2.0，获取、使用和查找声明文件变得十分容易。 这篇文章将详细说明怎么做这三件事。","level":1},{"id":"/notes/ts/declaration-files/consumption#下载","title":"下载","titles":[],"content":"在TypeScript 2.0以上的版本，获取类型声明文件只需要使用npm。比如，获取lodash库的声明文件，只需使用下面的命令：如果一个npm包像  发布 里所讲的一样已经包含了它的声明文件，那就不必再去下载相应的  包了。","level":1},{"id":"/notes/ts/declaration-files/consumption#使用-1","title":"使用","titles":[],"content":"下载完后，就可以直接在TypeScript里使用lodash了。 不论是在模块里还是全局代码里使用。比如，你已经  安装了类型声明，你可以使用导入：或者如果你没有使用模块，那么你只需使用全局的变量  。","level":1},{"id":"/notes/ts/declaration-files/consumption#查找","title":"查找","titles":[],"content":"大多数情况下，类型声明包的名字总是与它们在  上的包的名字相同，但是有  前缀， 但如果你需要的话，你可以在   https://aka.ms/types 这里查找你喜欢的库。注意：如果你要找的声明文件不存在，你可以贡献一份，这样就方便了下一位要使用它的人。 查看DefinitelyTyped 贡献指南页了解详情。","level":1},{"id":"/notes/ts/declaration-files/consumption#参考","title":"参考","titles":["查找"],"content":"https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html","level":3},{"id":"/notes/ts/object/guide#总览","title":"总览","titles":[],"content":"在 TypeScript 中，   是 JavaScript 中的基本对象类型，包含多种方法来操作和处理对象。以下是    的常用方法及其描述：","level":2},{"id":"/notes/ts/object/guide#object-类的静态方法","title":"Object  类的静态方法","titles":["总览"],"content":"：   用于将一个或多个源对象的所有可枚举属性复制到目标对象中，返回目标对象。       ：   使用指定的原型对象和可选的属性描述符创建一个新对象。       ：   直接在对象上定义一个新属性，或者修改对象的现有属性，并返回该对象。       ：   直接在对象上定义一个或多个新的属性或修改现有属性，返回该对象。       ：   返回一个给定对象自身可枚举属性的键值对数组，其排列顺序与使用    循环遍历该对象时返回的顺序一致。       ：   冻结一个对象，冻结后不能向该对象添加新属性，不能删除已有属性，不能修改已有属性的可枚举性、可配置性、可写性以及属性值。       ：   返回对象上一个自有属性对应的属性描述符（如果存在），否则返回   。       ：   返回一个对象的所有自身属性的描述符。       ：   返回一个包含对象自身所有属性（包括不可枚举属性但不包括    属性）的数组。       ：   返回一个数组，包含对象自身所有的    属性键。       ：   返回指定对象的原型（即，内部 [[Prototype]] 属性的值）。       ：   判断两个值是否是相同的值。所有    值都相同（即    返回   ），但正零和负零不相同。       ：   判断对象是否是可扩展的（即，可以添加新的属性）。       ：   判断对象是否被冻结。       ：   判断对象是否被密封。       ：   返回一个包含对象自身所有可枚举属性名称的数组。       ：   防止对象的扩展。将对象设置为不可扩展（即，不能添加新的属性）。       ：   密封一个对象，防止添加新属性并将所有现有属性标记为不可配置。现有属性的值仍然可以改变。       ：   设置对象的原型（即，内部 [[Prototype]] 属性的值），返回指定对象。       ：   返回一个包含对象自身所有可枚举属性值的数组。这些方法可以帮助你在 TypeScript 中有效地处理和操作对象。通过理解和利用这些方法，你可以编写更健壮和灵活的代码。","level":3},{"id":"/notes/ts/object/assign#objectassign","title":"Object.assign","titles":[],"content":"是一个常用的 JavaScript 方法，它可以将一个或多个源对象的所有可枚举属性复制到目标对象中，并返回目标对象。TypeScript 完全支持    方法，并且可以提供类型检查。","level":1},{"id":"/notes/ts/object/assign#基本用法","title":"基本用法","titles":["Object.assign"],"content":"：目标对象。    ：一个或多个源对象。","level":3},{"id":"/notes/ts/object/assign#示例","title":"示例","titles":["Object.assign"],"content":"","level":3},{"id":"/notes/ts/object/assign#基本示例","title":"基本示例","titles":["Object.assign","示例"],"content":"将一个源对象的属性复制到目标对象：","level":4},{"id":"/notes/ts/object/assign#合并多个源对象","title":"合并多个源对象","titles":["Object.assign","示例"],"content":"","level":4},{"id":"/notes/ts/object/assign#克隆对象","title":"克隆对象","titles":["Object.assign","示例"],"content":"创建对象的浅拷贝：","level":4},{"id":"/notes/ts/object/assign#处理嵌套对象","title":"处理嵌套对象","titles":["Object.assign","示例"],"content":"注意：   只进行浅拷贝，不会深度合并嵌套对象。","level":4},{"id":"/notes/ts/object/assign#注意事项","title":"注意事项","titles":["Object.assign","示例"],"content":"浅拷贝 ：   执行的是浅拷贝，如果源对象的某个属性是对象，则只会复制对象的引用。     目标对象的修改 ：   会改变目标对象本身，如果不想修改目标对象，可以传入一个空对象作为目标对象。     处理原型链上的属性 ：   只会复制源对象自身的可枚举属性，不会复制继承的属性。     处理不可枚举属性 ：   不会复制不可枚举的属性。     处理 Symbol 属性 ：   会复制    类型的属性。","level":3},{"id":"/notes/ts/object/assign#总结","title":"总结","titles":["Object.assign","示例"],"content":"是一个强大的工具，用于对象的合并和克隆。了解其浅拷贝的特性以及对原型链和不可枚举属性的处理方式，可以帮助你在使用    时避免一些常见的陷阱。通过合理使用   ，可以在 TypeScript 中编写更简洁和高效的代码。","level":3},{"id":"/notes/ts/object/create#objectcreate","title":"Object.create","titles":[],"content":"是一个 JavaScript 方法，用于创建一个新对象，并将其原型设置为指定的对象。在 TypeScript 中，这个方法同样适用。下面是    的用法、示例、常见问题和注意事项。","level":2},{"id":"/notes/ts/object/create#基本用法","title":"基本用法","titles":["Object.create"],"content":"：新创建对象的原型对象。    （可选）：一个对象，其属性将作为新对象的自有属性。这些属性的属性描述符格式与    中的相同。","level":3},{"id":"/notes/ts/object/create#示例","title":"示例","titles":["Object.create"],"content":"","level":3},{"id":"/notes/ts/object/create#创建一个具有指定原型的新对象","title":"创建一个具有指定原型的新对象","titles":["Object.create","示例"],"content":"","level":4},{"id":"/notes/ts/object/create#使用属性描述符创建对象","title":"使用属性描述符创建对象","titles":["Object.create","示例"],"content":"","level":4},{"id":"/notes/ts/object/create#常见问题","title":"常见问题","titles":["Object.create","示例"],"content":"","level":3},{"id":"/notes/ts/object/create#_1-objectcreate-与-new-的区别","title":"1.    Object.create  与   new  的区别","titles":["Object.create","示例","常见问题"],"content":"直接创建一个新对象并设置其原型，而    关键字则用于创建一个构造函数的实例。前者更灵活，后者适合使用构造函数模式。","level":4},{"id":"/notes/ts/object/create#_2-继承多个对象","title":"2.   继承多个对象","titles":["Object.create","示例","常见问题"],"content":"只能设置一个对象作为新对象的原型，因此不能直接实现多重继承。要实现多重继承，需要结合    或其他方法手动混合多个对象的属性。","level":4},{"id":"/notes/ts/object/create#注意事项","title":"注意事项","titles":["Object.create","示例"],"content":"浅拷贝创建的新对象与原型对象之间是浅拷贝关系。如果原型对象的属性是引用类型，修改新对象上的该属性会影响原型对象。属性描述符在    中定义的属性是非继承的自有属性，可以通过属性描述符进行详细配置。注意如果属性描述符未设置   、   和   ，它们的默认值为   。原型链通过    创建的对象，其原型链与    指定的对象一致。可以通过    方法验证。","level":3},{"id":"/notes/ts/object/create#总结","title":"总结","titles":["Object.create","示例"],"content":"是一个强大的工具，允许你创建具有特定原型和属性的新对象。通过理解其用法和特性，可以在 TypeScript 中更灵活地进行面向对象编程。然而，要注意浅拷贝特性和属性描述符的配置，以避免潜在的问题。","level":3},{"id":"/notes/ts/project-configuration/tsconfig-json#tsconfigjson","title":"tsconfig.json","titles":[],"content":"","level":1},{"id":"/notes/ts/project-configuration/tsconfig-json#概述","title":"概述","titles":["tsconfig.json"],"content":"如果一个目录下存在一个  文件，那么它意味着这个目录是 TypeScript 项目的根目录。   文件中指定了用来编译这个项目的根文件和编译选项。 一个项目可以通过以下方式之一来编译：","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#使用-tsconfigjson","title":"使用 tsconfig.json","titles":["tsconfig.json"],"content":"不带任何输入文件的情况下调用  ，编译器会从当前目录开始去查找  文件，逐级向上搜索父目录。  不带任何输入文件的情况下调用  ，且使用命令行参数  （或  ）指定一个包含  文件的目录。当命令行上指定了输入文件时，  文件会被忽略。","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#示例","title":"示例","titles":["tsconfig.json"],"content":"示例文件:使用  属性    使用  和  属性","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#细节","title":"细节","titles":["tsconfig.json"],"content":"可以被忽略，这时编译器会使用默认值。在这里查看完整的  编译器选项 列表。指定一个包含相对或绝对文件路径的列表。   和  属性指定一个文件 glob 匹配模式列表。 支持的 glob 通配符有：匹配 0 或多个字符（不包括目录分隔符）    匹配一个任意字符（不包括目录分隔符）    递归匹配任意子目录如果一个 glob 模式里的某部分只包含  或  ，那么仅有支持的文件扩展名类型被包含在内（比如默认  ，  ，和  ， 如果   设置能  还包含  和  ）。如果  和  都没有被指定，编译器默认包含当前目录和子目录下所有的 TypeScript 文件（  ,    和   ），排除在  里指定的文件。JS 文件（  和  ）也被包含进来如果  被设置成  。 如果指定了   或  ，编译器会将它们结合一并包含进来。 使用   指定的目录下的文件永远会被编译器排除，除非你明确地使用  将其包含进来（这时就算用  指定也没用）。使用  引入的文件可以使用  属性过滤。 然而，通过   属性明确指定的文件却总是会被包含在内，不管  如何设置。 如果没有特殊指定，   默认情况下会排除  ，  ，  和  目录。任何被  或  指定的文件所引用的文件也会被包含进来。   引用了  ，因此  不能被排除，除非引用它的  在  列表中。需要注意编译器不会去引入那些可能做为输出的文件；比如，假设我们包含了  ，那么  和  会被排除在外。 通常来讲，不推荐只有扩展名的不同来区分同目录下的文件。文件可以是个空文件，那么所有默认的文件（如上面所述）都会以默认配置选项编译。在命令行上指定的编译选项会覆盖在  文件里的相应选项。","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#typestyperoots和types","title":"@types ，  typeRoots 和  types","titles":["tsconfig.json"],"content":"默认所有  可见的 \"  \"包会在编译过程中被包含进来。   文件夹下以及它们子文件夹下的所有包都是  可见的 ； 也就是说，   ，  和  等等。如果指定了  ，  只有  下面的包才会被包含进来。 比如：这个配置文件会包含  所有  下面的包，而不包含  里面的包。如果指定了  ，只有被列出来的包才会被包含进来。 比如：这个  文件将  仅会 包含   ，  和  。/@types/。   里面的其它包不会被引入进来。指定  来禁用自动引入  包。注意，自动引入只在你使用了全局的声明（相反于模块）时是重要的。 如果你使用   语句，TypeScript 仍然会查找  和  文件夹来获取  包。","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#使用extends继承配置","title":"使用  extends 继承配置","titles":["tsconfig.json"],"content":"文件可以利用  属性从另一个配置文件里继承配置。是  文件里的顶级属性（与  ，  ，  ，和  一样）。   的值是一个字符串，包含指向另一个要继承文件的路径。在原文件里的配置先被加载，然后被来至继承文件里的配置重写。 如果发现循环引用，则会报错。来至所继承配置文件的  ，  和   覆盖 源配置文件的属性。配置文件里的相对路径在解析时相对于它所在的文件。比如：：：：","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#compileonsave","title":"compileOnSave","titles":["tsconfig.json"],"content":"在最顶层设置  标记，可以让 IDE 在保存文件的时候根据  重新生成文件。要想支持这个特性需要 Visual Studio 2015， TypeScript1.8.4 以上并且安装  atom-typescript 插件。","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#模式","title":"模式","titles":["tsconfig.json"],"content":"到这里查看模式:   http://json.schemastore.org/tsconfig  .","level":2},{"id":"/notes/ts/project-configuration/tsconfig-json#参考","title":"参考","titles":["tsconfig.json","模式"],"content":"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#handbook-content","level":3},{"id":"/notes/ts/project-configuration/compiler-options-in-msbuild#typescript-编译器选项","title":"TypeScript 编译器选项","titles":[],"content":"TypeScript 的编译器选项可以通过配置文件（通常是   ）或者在 MSBuild 项目文件中直接指定。以下是一些常见的 TypeScript 编译器选项，它们可以通过 MSBuild 配置来控制：OutDir  设置输出目录，指定编译后 JavaScript 文件的输出位置。     SourceMap  是否生成 source map 文件，用于在调试时将编译后的 JavaScript 代码映射回 TypeScript 源代码。     ModuleResolution  指定模块解析策略，可以是   （Node.js 模块解析策略）或   （经典模块解析策略）。     Target  指定 ECMAScript 目标版本，例如 ES5、ES6 等。     NoEmitOnError  如果有 TypeScript 编译错误，是否终止生成 JavaScript 文件。     AllowJs  是否允许编译器编译    文件。","level":3},{"id":"/notes/ts/project-configuration/compiler-options-in-msbuild#在-msbuild-项目中配置-typescript-编译器选项","title":"在 MSBuild 项目中配置 TypeScript 编译器选项","titles":[],"content":"在 MSBuild 项目文件（例如    文件）中，可以通过    和    元素来配置 TypeScript 编译器选项。以下是一个示例：在这个例子中：指定了编译后 JavaScript 文件的输出目录。    设置为   ，生成对应的 source map 文件。    设置为   ，使用 Node.js 模块解析策略。    指定了编译的目标 ECMAScript 版本为 ES5。    设置为   ，在 TypeScript 编译错误时停止生成 JavaScript 文件。    设置为   ，允许编译器编译    文件。通过在 MSBuild 项目文件中配置这些选项，可以有效地控制 TypeScript 的编译行为，以适应项目的需求和环境。","level":3},{"id":"/notes/ts/project-configuration/compiler-options-in-msbuild#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html#handbook-content","level":3},{"id":"/notes/ts/project-configuration/compiler-options#常见的-tsc-cli-options","title":"常见的 tsc CLI Options","titles":[],"content":"--help  显示 tsc 命令行帮助信息，列出所有可用的命令行选项。     --version  显示 TypeScript 编译器的版本信息。     --target  指定编译后的 ECMAScript 目标版本。可选值包括   ,   ,   ,   ,   ,   ,   ,   ,    等。     --module  指定生成的模块系统。可选值包括   ,   ,   ,   ,   ,   ,    等。     --outDir  指定输出目录，用来存放编译后的 JavaScript 文件。     --sourceMap  是否生成 source map 文件，用于在调试时将编译后的 JavaScript 代码映射回 TypeScript 源代码。     --strict  开启所有严格类型检查选项。相当于同时启用   ,   ,   ,   ,   ,   ,   。     --noEmit  不生成任何输出文件，只进行类型检查。     --watch  监视文件变化并重新编译。在开发过程中常用来实时监控文件变化并自动重新编译。     --esModuleInterop  允许在导入默认导出时使用 CommonJS 的    语法。     --declaration  是否生成    声明文件。     --allowJs  允许编译器编译    文件。","level":3},{"id":"/notes/ts/project-configuration/compiler-options#示例","title":"示例","titles":[],"content":"假设我们有一个 TypeScript 项目，项目文件结构如下：文件内容如下：我们可以使用 tsc 命令行工具来编译这个 TypeScript 文件：这个命令将会把    编译成    和    文件，使用    目标版本，   模块系统，并生成 source map 文件以便在调试时进行源代码映射。","level":3},{"id":"/notes/ts/project-configuration/compiler-options#总结","title":"总结","titles":[],"content":"tsc 命令行工具提供了丰富的选项来控制 TypeScript 的编译行为，可以根据项目需求和特定的环境配置相应的选项。这些选项可以通过直接在命令行中指定，也可以在项目的    文件中进行配置，以达到灵活和高效地管理 TypeScript 项目的目的。","level":3},{"id":"/notes/ts/project-configuration/compiler-options#参考","title":"参考","titles":[],"content":"https://www.typescriptlang.org/docs/handbook/compiler-options.html","level":3},{"id":"/notes/ts/project-configuration/project-references#项目引用-project-references","title":"项目引用 Project References","titles":[],"content":"TypeScript 的项目引用（Project References）是一个强大的功能，允许一个 TypeScript 项目引用另一个 TypeScript 项目。这个功能非常适用于大型代码库和单体仓库（monorepos），它使得项目之间的依赖关系更明确，并且可以显著加快编译速度。","level":2},{"id":"/notes/ts/project-configuration/project-references#项目引用的核心概念","title":"项目引用的核心概念","titles":["项目引用 Project References"],"content":"项目引用通过允许一个项目依赖于另一个项目，使得 TypeScript 编译器可以在编译时确保所有引用的项目都被正确编译。这不仅提高了编译效率，还改善了项目间的类型检查和代码导航。","level":3},{"id":"/notes/ts/project-configuration/project-references#配置项目引用","title":"配置项目引用","titles":["项目引用 Project References"],"content":"要使用项目引用，需要对 TypeScript 项目进行一些配置，主要包括    文件的设置。","level":3},{"id":"/notes/ts/project-configuration/project-references#步骤-1-创建多个项目","title":"步骤 1: 创建多个项目","titles":["项目引用 Project References","配置项目引用"],"content":"假设我们有两个项目，   和   。   项目依赖于    项目。","level":4},{"id":"/notes/ts/project-configuration/project-references#步骤-2-配置-core-项目的-tsconfigjson","title":"步骤 2: 配置   core  项目的   tsconfig.json","titles":["项目引用 Project References","配置项目引用"],"content":"首先，我们需要配置    项目的   ：选项必须启用，它表示这是一个可以被引用的 TypeScript 项目。","level":4},{"id":"/notes/ts/project-configuration/project-references#步骤-3-配置-app-项目的-tsconfigjson","title":"步骤 3: 配置   app  项目的   tsconfig.json","titles":["项目引用 Project References","配置项目引用"],"content":"接下来，我们需要配置    项目的   ，并引用    项目：字段指定了    项目引用了    项目。","level":4},{"id":"/notes/ts/project-configuration/project-references#步骤-4-配置顶层-tsconfigjson","title":"步骤 4: 配置顶层   tsconfig.json","titles":["项目引用 Project References","配置项目引用"],"content":"在顶层目录创建一个    文件，以便可以一次性编译整个项目结构：","level":4},{"id":"/notes/ts/project-configuration/project-references#构建项目","title":"构建项目","titles":["项目引用 Project References","配置项目引用"],"content":"通过在顶层目录运行    命令，可以一次性编译所有的子项目：这个命令会按照项目之间的依赖关系顺序编译所有的项目，并生成相应的输出文件。","level":3},{"id":"/notes/ts/project-configuration/project-references#项目引用的优势","title":"项目引用的优势","titles":["项目引用 Project References","配置项目引用"],"content":"加快增量编译 ：由于每个项目可以单独编译，并且编译结果可以被缓存，所以在修改一个项目时，只需要重新编译受影响的项目，从而加快编译速度。   更好的模块化 ：项目引用使得项目之间的依赖关系更加明确，有助于模块化管理代码。   改进的类型检查和代码导航 ：TypeScript 编译器可以跨项目进行类型检查，确保类型安全，并且开发工具（如 VS Code）可以提供更好的代码导航支持。","level":3},{"id":"/notes/ts/project-configuration/project-references#总结","title":"总结","titles":["项目引用 Project References","配置项目引用"],"content":"TypeScript 的项目引用是一个非常实用的功能，特别适用于大型项目和单体仓库。通过配置项目引用，可以提高编译速度，改进代码模块化管理，并且增强类型检查和代码导航能力。使用项目引用可以使得 TypeScript 项目之间的依赖关系更加清晰和高效，从而更好地管理和维护大型代码库。","level":3},{"id":"/notes/ts/project-configuration/project-references#参考","title":"参考","titles":["项目引用 Project References","配置项目引用"],"content":"https://www.typescriptlang.org/docs/handbook/project-references.html","level":3},{"id":"/notes/ts/project-configuration/integrating-with-build-tools#与构建工具集成-integrating-with-build-tools","title":"与构建工具集成 Integrating with Build Tools","titles":[],"content":"在现代前端开发中，使用构建工具来管理和自动化构建流程已经成为一种常见的做法。TypeScript 提供了良好的工具链支持，可以无缝集成到各种构建工具中，例如 Gulp、Grunt、Webpack 等。以下是如何将 TypeScript 集成到这些构建工具中的详细介绍。","level":2},{"id":"/notes/ts/project-configuration/integrating-with-build-tools#使用-gulp-集成-typescript","title":"使用 Gulp 集成 TypeScript","titles":["与构建工具集成 Integrating with Build Tools"],"content":"Gulp 是一个流行的基于流的构建工具，适合用来自动化前端开发任务。以下是使用 Gulp 集成 TypeScript 的步骤：安装必要的依赖包 ：     创建   ：     配置   ：     运行 Gulp 任务 ：","level":3},{"id":"/notes/ts/project-configuration/integrating-with-build-tools#使用-grunt-集成-typescript","title":"使用 Grunt 集成 TypeScript","titles":["与构建工具集成 Integrating with Build Tools"],"content":"Grunt 是一个基于任务的构建工具，非常适合用于构建、验证和运行项目中的重复性任务。以下是使用 Grunt 集成 TypeScript 的步骤：安装必要的依赖包 ：     创建   ：     配置   ：     运行 Grunt 任务 ：","level":3},{"id":"/notes/ts/project-configuration/integrating-with-build-tools#使用-webpack-集成-typescript","title":"使用 Webpack 集成 TypeScript","titles":["与构建工具集成 Integrating with Build Tools"],"content":"Webpack 是一个模块打包工具，适用于现代 JavaScript 应用。以下是使用 Webpack 集成 TypeScript 的步骤：安装必要的依赖包 ：     创建   ：     配置   ：     运行 Webpack 构建 ：","level":3},{"id":"/notes/ts/project-configuration/integrating-with-build-tools#使用-npm-scripts-集成-typescript","title":"使用 npm Scripts 集成 TypeScript","titles":["与构建工具集成 Integrating with Build Tools"],"content":"对于一些简单的项目，使用 npm 脚本来构建 TypeScript 也是一个不错的选择。以下是如何配置 npm 脚本来编译 TypeScript：安装 TypeScript ：     配置   ：     更新    文件添加编译脚本：     运行 npm 脚本 ：","level":3},{"id":"/notes/ts/project-configuration/integrating-with-build-tools#总结","title":"总结","titles":["与构建工具集成 Integrating with Build Tools"],"content":"将 TypeScript 集成到各种构建工具中可以提高开发效率，自动化构建流程。无论是 Gulp、Grunt、Webpack 还是 npm Scripts，TypeScript 都能很好地融入其中，根据项目需求选择合适的构建工具进行集成，是管理项目构建的最佳实践之一。","level":3},{"id":"/notes/ts/project-configuration/integrating-with-build-tools#参考","title":"参考","titles":["与构建工具集成 Integrating with Build Tools"],"content":"https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#配置监视-configuring-watch","title":"配置监视 Configuring Watch","titles":[],"content":"在 TypeScript 中，   选项允许编译器监视文件变化，并在文件修改时自动重新编译。这对于开发者来说是一个非常有用的功能，可以提高开发效率，减少手动编译的次数。除了基本的    选项，TypeScript 提供了许多配置选项来定制监视行为。","level":2},{"id":"/notes/ts/project-configuration/configuring-watch#基本使用","title":"基本使用","titles":["配置监视 Configuring Watch"],"content":"要使用 TypeScript 的    模式，只需要在命令行中添加    选项。例如：这会让 TypeScript 编译器监视当前目录及其子目录中的所有 TypeScript 文件，当这些文件发生变化时，编译器会自动重新编译。","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#配置-tsconfigjson","title":"配置 tsconfig.json","titles":["配置监视 Configuring Watch"],"content":"为了更方便地使用    选项，可以在    文件中配置监视模式。这允许你更灵活地控制监视行为。","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#基本-tsconfigjson-配置","title":"基本 tsconfig.json 配置","titles":["配置监视 Configuring Watch","配置 tsconfig.json"],"content":"创建一个基本的    文件：然后在命令行中运行：这会让 TypeScript 监视    目录中的所有    文件，并将编译后的输出放到    目录中。","level":4},{"id":"/notes/ts/project-configuration/configuring-watch#监视模式配置选项","title":"监视模式配置选项","titles":["配置监视 Configuring Watch","配置 tsconfig.json"],"content":"TypeScript 提供了几个配置选项，可以在    中设置，以更好地控制监视模式。","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#watchoptions","title":"watchOptions","titles":["配置监视 Configuring Watch","配置 tsconfig.json","监视模式配置选项"],"content":"在    文件中，你可以使用    来配置监视模式的行为：以下是    中的一些常用选项：excludeDirectories : 排除特定的目录，不监视这些目录中的文件。   excludeFiles : 排除特定的文件，不监视这些文件。   watchFile : 设置文件监视策略。可选值有：\n    : 固定的轮询间隔。   : 优先级轮询间隔。   : 动态优先级轮询。   : 使用文件系统事件（推荐）。   watchDirectory : 设置目录监视策略。可选值有：\n    : 使用文件系统事件（推荐）。   : 固定的轮询间隔。   : 动态优先级轮询。   fallbackPolling : 设置回退的轮询策略，当文件系统事件不可用时使用。可选值有：\n    : 固定的轮询间隔。   : 优先级轮询。   : 动态优先级轮询。","level":4},{"id":"/notes/ts/project-configuration/configuring-watch#使用-tsc-watch","title":"使用 tsc-watch","titles":["配置监视 Configuring Watch","配置 tsconfig.json"],"content":"是一个第三方工具，提供了更高级的监视功能，例如在文件变化时自动运行自定义脚本。安装 tsc-watch ：     配置 package.json ：  在    中添加脚本来使用   ：     运行监视脚本 ：这样，当 TypeScript 文件编译成功时，会自动运行    脚本。","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#示例配置监视模式的项目","title":"示例：配置监视模式的项目","titles":["配置监视 Configuring Watch","配置 tsconfig.json"],"content":"假设我们有以下项目结构：文件内容：文件内容：","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#运行监视模式","title":"运行监视模式","titles":["配置监视 Configuring Watch","配置 tsconfig.json"],"content":"使用 TypeScript 内置的    模式：    使用    提供的高级监视功能：","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#总结","title":"总结","titles":["配置监视 Configuring Watch","配置 tsconfig.json"],"content":"TypeScript 的监视模式是开发过程中提高效率的有力工具。通过配置    中的   ，可以定制监视行为以适应不同的开发需求。对于更高级的使用场景，可以借助    等第三方工具，实现文件变化时自动运行自定义脚本的功能。","level":3},{"id":"/notes/ts/project-configuration/configuring-watch#参考","title":"参考","titles":["配置监视 Configuring Watch","配置 tsconfig.json"],"content":"https://www.typescriptlang.org/docs/handbook/configuring-watch.html","level":3},{"id":"/notes/ts/project-configuration/nightly-builds#每日构建","title":"每日构建","titles":[],"content":"TypeScript Nightly Builds 是 TypeScript 编译器和语言服务的最新、最前沿的版本，通常每天发布一次。这些构建包含了最新的功能、修复和改进，使开发者可以尽早测试和使用新功能。然而，这些版本也可能包含未经过全面测试的代码，因此可能不如正式发布版稳定。","level":2},{"id":"/notes/ts/project-configuration/nightly-builds#安装-typescript-nightly-builds","title":"安装 TypeScript Nightly Builds","titles":["每日构建"],"content":"要安装 TypeScript 的 Nightly 版本，可以使用 npm 包管理器。命令如下：这将全局安装最新的 Nightly 版本，并将    命令指向该版本。如果只想在某个项目中使用 Nightly 版本，可以运行：","level":3},{"id":"/notes/ts/project-configuration/nightly-builds#使用-typescript-nightly-builds","title":"使用 TypeScript Nightly Builds","titles":["每日构建"],"content":"使用 Nightly 版本与使用正式版本的 TypeScript 没有区别。你仍然可以通过    命令编译 TypeScript 文件，并通过    文件配置编译选项。","level":3},{"id":"/notes/ts/project-configuration/nightly-builds#查看-typescript-版本","title":"查看 TypeScript 版本","titles":["每日构建","使用 TypeScript Nightly Builds"],"content":"要确认安装的 TypeScript 版本，可以运行以下命令：输出将类似于：这里的版本号表示这是一个 2022 年 2 月 14 日的 Nightly 构建版本。","level":4},{"id":"/notes/ts/project-configuration/nightly-builds#优点和风险","title":"优点和风险","titles":["每日构建","使用 TypeScript Nightly Builds"],"content":"","level":3},{"id":"/notes/ts/project-configuration/nightly-builds#优点","title":"优点","titles":["每日构建","使用 TypeScript Nightly Builds","优点和风险"],"content":"新功能 ：能够率先体验和使用 TypeScript 最新的语言特性和改进。   早期反馈 ：通过使用 Nightly 版本，开发者可以向 TypeScript 团队提供早期反馈，帮助发现和修复问题。   社区参与 ：积极参与 TypeScript 社区，贡献自己的意见和经验。","level":4},{"id":"/notes/ts/project-configuration/nightly-builds#风险","title":"风险","titles":["每日构建","使用 TypeScript Nightly Builds","优点和风险"],"content":"不稳定 ：Nightly 版本可能包含未经全面测试的功能和改动，可能会导致编译错误或运行时错误。   频繁更新 ：每天一个新版本，可能需要频繁更新项目中的 TypeScript 依赖。   向后兼容性问题 ：某些新功能或改动可能不向后兼容，可能会破坏现有代码。","level":4},{"id":"/notes/ts/project-configuration/nightly-builds#如何报告问题","title":"如何报告问题","titles":["每日构建","使用 TypeScript Nightly Builds"],"content":"如果在使用 Nightly 版本时遇到问题，可以通过 TypeScript 的 GitHub 仓库报告问题。具体步骤如下：前往   TypeScript 的 GitHub 仓库 。  点击 \"Issues\" 标签。  点击 \"New issue\" 按钮。  填写问题的详细信息，包括重现步骤、预期行为和实际行为。  提交问题。","level":3},{"id":"/notes/ts/project-configuration/nightly-builds#示例使用-nightly-版本的新功能","title":"示例：使用 Nightly 版本的新功能","titles":["每日构建","使用 TypeScript Nightly Builds"],"content":"假设 Nightly 版本引入了一个新的类型运算符   。我们可以创建一个    文件来启用 Nightly 版本特有的配置，并编写一些使用新功能的代码。","level":3},{"id":"/notes/ts/project-configuration/nightly-builds#tsconfigjson","title":"tsconfig.json","titles":["每日构建","使用 TypeScript Nightly Builds","示例：使用 Nightly 版本的新功能"],"content":"","level":4},{"id":"/notes/ts/project-configuration/nightly-builds#示例代码","title":"示例代码","titles":["每日构建","使用 TypeScript Nightly Builds","示例：使用 Nightly 版本的新功能"],"content":"通过运行    命令编译这些代码，如果编译器正常工作且支持新的    运算符，则表示 Nightly 版本正常。","level":4},{"id":"/notes/ts/project-configuration/nightly-builds#总结","title":"总结","titles":["每日构建","使用 TypeScript Nightly Builds"],"content":"TypeScript Nightly Builds 是开发者可以提前体验和测试 TypeScript 最新功能的重要工具。通过安装和使用这些版本，开发者不仅可以获得最新的功能和改进，还可以向 TypeScript 团队提供早期反馈，帮助改进 TypeScript。不过，由于这些版本可能不够稳定，因此在生产环境中使用时需要谨慎。","level":3},{"id":"/notes/ts/project-configuration/nightly-builds#参考","title":"参考","titles":["每日构建","使用 TypeScript Nightly Builds"],"content":"https://www.typescriptlang.org/docs/handbook/nightly-builds.html","level":3},{"id":"/notes/vue/vue-slot#vue3-获取插槽内容-slot","title":"vue3 获取插槽内容 slot","titles":[],"content":"useSlots()的用法, renderSlotContent","level":1},{"id":"/notes/web/a-nofollow#一什么是nofollow-标签","title":"一、什么是  nofollow 标签","titles":[],"content":"nofollow 标签是 HTML 页面中    标签的一个属性值。这个标签的意义是告诉搜索引擎不要追踪此网页上的链接或不要追踪此特定链接。它可以被看作是一个指示牌，告诉搜索引擎这个链接不是经过作者信任的，因此不应该被视为一个信任票。当搜索引擎看到 nofollow 标签时，它可能会减少或完全取消该链接的投票权重。nofollow 标签一般指 Nofollow，是 HTML 页面中 A 标签的属性，故又称为 nofollow 属性。该标签告诉搜索引擎这个链接不是作者推荐的，不要追踪此网页上的链接和传递权重，以减少垃圾链接，分散网站权重。nofollow 标签最初被设计用来应对垃圾链接（Spam），它的作用主要是两方面：   一是不给链接投票，降低此链接的权重；  二是使添加 nofollow 的部分内容不参与网站排名，这样可以集中网站权重，减少权重的分散。这种方式可以帮助网站管理员更好地控制搜索引擎对其网页的追踪和评估，从而改善搜索结果的质量，并防止垃圾链接的蔓延。![什么是nofollow标签]nofollow 这个概念最初是由谷歌公司在 2005 年的时候提出来的，并被百度、yahoo 等各大搜索引擎广泛支持，是一个\"反垃圾链接\"的标签，当时提出这个标签的解释主要是为了应付越来越泛滥的外链群发作弊，意思就是说，只要加入了这个 nofollow 标签的链接，搜索蜘蛛就不会进行爬行。","level":3},{"id":"/notes/web/a-nofollow#二nofollow-标签的正确使用方法","title":"二、nofollow 标签的正确使用方法","titles":[],"content":"1、用于 meta 元标签这段代码告诉搜索引擎不要抓取网页上的所有链接，和包括内部链接、外部链接。Content 里 index、noindex、follow、nofollow 标签结合使用：：可以抓取本页，而且可以顺着本页继续索引别的链接。：不许抓取本页，但是可以顺着本页抓取索引别的链接。：可以抓取本页，但是不许顺着本页抓取索引别的链接。：不许抓取本页，也不许顺着本页抓取索引别的链接。2、用于 a 标签这段代码在超链接中加入 nofollow 属性，意思是告诉搜索引擎不要追踪这个链接。","level":3},{"id":"/notes/web/a-nofollow#三nofollow-标签应用场景","title":"三、nofollow 标签应用场景","titles":[],"content":"通过合理使用 nofollow 标签，网站管理员可以更好地控制链接的权重分配，提高网站的搜索引擎优化效果，并有效防止垃圾链接的扩散。nofollow 标签在多种场景中具有实际应用，主要包括以下几个方面：论坛帖子和博客评价 ：这些地方通常存在大量的其他网站链接，其中可能包含垃圾链接，影响搜索引擎蜘蛛的爬取。使用 nofollow 标签可以避免给这些链接传递权重，防止垃圾链接的过度滋生。   广告链接 ：给广告链接加上 nofollow 可以明确告诉搜索引擎，这是一个广告链接，不应该传递链接权重。这样做有助于遵守搜索引擎的指南，确保广告链接不会被误认为是编辑推荐。   网站内部链接 ：对于网站内部的一些无用页面，如法律声明、版权声明等，加上 nofollow 标签可以阻止整个网站的权重传递到这些页面上。这样做可以确保网站的权重更集中地分配到其他更有价值的页面上。   购物车和注册页面 ：这些页面通常对搜索引擎不友好，使用 nofollow 标签可以阻止搜索引擎索引这些页面，从而提高网站的 SEO 效果。   自定义付费链接 ：为了遵循搜索引擎的指南，付费链接通常会被添加 nofollow 标签。这样做可以表明这不是一个编辑上的推荐链接，搜索引擎不应该传递该链接的权重。","level":3},{"id":"/notes/web/a-nofollow#四nofollow-标签的作用","title":"四、nofollow 标签的作用","titles":[],"content":"通常情况下，反向链接是会传递权重的，所以一些做  SEO 的为了添加反向链接，就在论坛和博客等大量发布带无关链接的内容。这些垃圾链接的存在给搜索引擎对网页质量的评估造成一定程度的麻烦。因此，在这种情况下，nofollow 正是几大搜索引擎商(比如，Google、Yahoo、百度等)为了应对垃圾链接(Spam)引入的一个属性。 其作用具体表现为以下几方面。1、Nofollow 可以帮助你区分链接自然的外链是多种多样的。一些链接是 dofollow 链接，另外的则是 nofollow 链接。这个事实是不可避免的，因为有些人不可避免地会通过 nofollow 链接链接到你。总之，如果一个网站只有 dofollow 链接，或者是占比非常高，那么就非常的可疑了。2、Nofollow 链接可以防止百度谷歌惩罚如果你的内容页面，由于社会关系，碍于情面必须要链接某位熟人的低质量内容，那么你完全可以利用 Nofollow 标签，屏蔽这个链接，从而避免链接大量垃圾页面而遭到惩罚。3、引导爬虫抓取有效的页面链接不仅对 SEO 有用。它们也可以提高引荐流量。如果一个 nofollow 链接带来了有效价值的用户访问，说明这个链接对用户是有价值的，对搜索引擎来说就是 dofollow 的链接机会。4、提升锚文本的影响力虽然 Nofollow 标签并不能传递权重，但是来自高权重，知名站点的 Nofllow 链接，仍然对中小网站有着积极推动的作用，基于庞大的用户群，它有利于企业网站的曝光。**注意：**网站上添加了 nofollow 属性标签并不代表搜索引擎不收录那个链接，没有说不要抓取链接指向的 URL，也没有说不要索引链接指向的 URL，nofollow 既没禁止抓取，也没禁止索引，只是不将这个链接计算入反向链接而已。链接加了 nofollow，不意味着别的地方就没有正常的指向这个 URL 的链接，只要别的地方出现了没加 nofollow 的链接，目标 URL 还是会被发现、抓取(假设没被 robotx 文件禁止)、索引(假设没加 noindex )。","level":3},{"id":"/notes/web/a-nofollow#五nofollow-与-robots-的区别","title":"五、nofollow 与 robots 的区别","titles":[],"content":"很多时候 nofollow 和 robots 一并被人提起，因为一般看来都有一个效果——让搜索引擎不要抓取某个页面。这里因为多种搜索引擎的不同处理方式是有不同情况的：百度：百度爬虫极有可能会爬行 nofollow 链接，所以试图用 nofollow 来屏蔽某个页面不被抓取是不妥当的，必须辅以  robots 文件 。而 robots 文件已经屏蔽的页面，是不会获得权重的。Google：Google 爬虫不会爬行 nofollow 链接，但是只要页面有一个 dofollow 链接，依然是有可能被抓取的，想要屏蔽页面最妥当的方式还是采用 robots 文件。因为不同搜索引擎对待这两个东西的方式不尽相同，所以当需要屏蔽页面的时候，应当把这两个都用上。","level":3},{"id":"/notes/web/a-nofollow#六百度与-google-对待-nofollow-标签的态度","title":"六、百度与 Google 对待 nofollow 标签的态度","titles":[],"content":"1、百度对于 nofollow 标签的态度网页级：   不追踪链接，不传递权重。链接级：  跟踪链接并记录锚文本，但不传递权重。2、Google 对待 nofollow 标签的态度Google 对于 nofollow：最近的 google 搜索引擎优化初学者指南中明确指出：如果您把某一链接的\"rel\"属性设置成\"nofollow\" , 这意味着您是在向 Google 传达这样的信息 : 您不希望 Google 继续跟踪抓取这些特定链接所指向的页面 , 并且也不希望将自己网页的声誉传给这些链接指向的网页。（也就是不跟踪知道的 nofollow 链接也不传递相应的权重）。","level":3},{"id":"/notes/web/a-nofollow#七链接属性的重大变化","title":"七、链接属性的重大变化","titles":[],"content":"1、增加了两个新的属性：rel=\"sponsored\":  这个新属性/标签用于标注广告、赞助商或其它因利益而存在的链接。rel=\"ugc\":  这个新属性/标签用于 UGC（用户产生内容），如论坛帖子、博客评论之类的。rel=\"nofollow\":  这个老的属性/标签依然用于没有任何投票、背书意味的链接，也不传递排名权重。换句话说，新公布的两个标签是为广告和 UGC 各新创了一个专用标签。2、这三个标签将被搜索引擎算法在决定链接是否应该被考虑时视为一个暗示，更容易理解点的词是一个建议，而不是指令。以前的 nofollow 基本上是一个指令，搜索引擎会忽略加了 nofollow 的链接，在计算权重流动时根本不考虑这个链接。但变更以后，只把这三个标签当作建议，搜索引擎的算法是否考虑这个链接，由搜索引擎自行综合其它因素来做决定。","level":3},{"id":"/notes/web/a-nofollow#八nofollow-标签常见问答","title":"八、nofollow 标签常见问答","titles":[],"content":"1、链接中有 Nofollow 属性是否算外链？从主流 SEO 平台对 nofollow 跟踪来说，有专门 nofollow 链接的分析，归属为网站外链的一种类型，由此可以看出链接中有 Nofollow 属性也算一种外链，因为这种链接如果出现位置好是可以吸引用户的。2、Nofollow 标签去除重复链接有什么效果?加入 Nofollow 标签并不能像我们想象中的那样节约很多时间，因为百度站长指南中就明确的说了，蜘蛛会将网站第一个链接抓取后，重复出现的并不会给予权值，且只做记录作用。所以为了节约时间而使用 Nofollow 标签去除重复性链接根本就是多此一举。总结优化猩 SEO：如果你正在进行网站的外链建设，尤其是进行友情链接交换，务必查看对方网站是否添加 nofollow，如果添加了 nofollow 属性，将导致该友情链接失去了本来的意义，因为这些链接不会传递网站权重，对网站  SEO 优化 没有效果。","level":3},{"id":"/notes/web/a-nofollow#参考链接","title":"参考链接：","titles":[],"content":"Nofollow_百度百科https://baike.baidu.com/item/Nofollow/2410595NOFOLLOW 是什么意思 - 百度经验https://jingyan.baidu.com/article/3aed632e6627877010809101.htmlnofollow 标签_nofollow 是什么意思及 nofollow 作用-CSDN 博客https://blog.csdn.net/weixin_39729840/article/details/111679084不断完善 nofollow - 确定链接性质的几种新方法 _ Google 搜索中心https://developers.google.com/search/blog/2019/09/evolving-nofollow-new-ways-to-identify?hl=zh-cnnofollow 常见问题解答 - 卢松松博客https://lusongsong.com/reed/397.html","level":3},{"id":"/notes/web/browser-color#修改手机浏览器地址栏和状态栏的颜色","title":"修改手机浏览器地址栏和状态栏的颜色","titles":[],"content":"要修改手机浏览器地址栏和状态栏的颜色，可以使用 HTML 和 CSS 来实现。以下是两种常见的方式：","level":2},{"id":"/notes/web/browser-color#_1-使用-html-meta-标签修改浏览器地址栏颜色","title":"1. 使用 HTML meta 标签修改浏览器地址栏颜色","titles":["修改手机浏览器地址栏和状态栏的颜色"],"content":"对于安卓设备，可以使用    meta 标签：","level":3},{"id":"/notes/web/browser-color#_2-使用-css-修改-ios-safari-浏览器的状态栏颜色","title":"2. 使用 CSS 修改 iOS Safari 浏览器的状态栏颜色","titles":["修改手机浏览器地址栏和状态栏的颜色"],"content":"对于 iOS 设备，可以使用 Apple 提供的    标签来设置状态栏的颜色：","level":3},{"id":"/notes/web/browser-color#在-vuejs-中实现","title":"在 Vue.js 中实现","titles":["修改手机浏览器地址栏和状态栏的颜色"],"content":"如果你正在使用 Vue.js 框架，可以在你的主组件（例如   ）的    生命周期钩子中动态添加这些 meta 标签。这样，你就可以在 Vue.js 应用中动态修改手机浏览器的颜色了。根据具体需求，你可以调整颜色值或 meta 标签的内容。","level":3},{"id":"/notes/web/browser-color#vue-3-组合函数-设置手机浏览器的颜色","title":"Vue 3 组合函数 设置手机浏览器的颜色","titles":["修改手机浏览器地址栏和状态栏的颜色"],"content":"HTMLMetaElement","level":2},{"id":"/notes/web/browser-color#创建自定义组合函数","title":"创建自定义组合函数","titles":["修改手机浏览器地址栏和状态栏的颜色","Vue 3 组合函数 设置手机浏览器的颜色"],"content":"首先，创建一个自定义的组合函数，用于设置浏览器颜色：","level":3},{"id":"/notes/web/browser-color#在-vue-组件中使用该组合函数","title":"在 Vue 组件中使用该组合函数","titles":["修改手机浏览器地址栏和状态栏的颜色","Vue 3 组合函数 设置手机浏览器的颜色"],"content":"然后，在 Vue 组件中使用这个自定义的组合函数：","level":3},{"id":"/notes/web/browser-color#完整项目结构","title":"完整项目结构","titles":["修改手机浏览器地址栏和状态栏的颜色","Vue 3 组合函数 设置手机浏览器的颜色"],"content":"确保你的项目结构如下：","level":3},{"id":"/notes/web/browser-color#解释","title":"解释","titles":["修改手机浏览器地址栏和状态栏的颜色","Vue 3 组合函数 设置手机浏览器的颜色"],"content":"类型断言 ：\n   使用    进行类型断言，以确保    返回的元素被视为   。  在创建新的 meta 标签时也使用类型断言将其视为   。通过这些更改，TypeScript 编译器将不会再报错，并且你的代码仍然保持清洁和模块化。","level":3},{"id":"/notes/web/browser-color#appvue","title":"App.vue","titles":["修改手机浏览器地址栏和状态栏的颜色","Vue 3 组合函数 设置手机浏览器的颜色"],"content":"","level":3},{"id":"/notes/web/nuxt-deploy-vercel#准备-nuxtjs-项目","title":"准备 Nuxt.js 项目","titles":[],"content":"创建一个 Nuxt.js 项目 ：\n如果你还没有 Nuxt.js 项目，可以使用以下命令创建一个新项目：     安装依赖 ：\n确保所有依赖都已安装：","level":3},{"id":"/notes/web/nuxt-deploy-vercel#配置-nuxtjs-项目","title":"配置 Nuxt.js 项目","titles":[],"content":"更新   ：\n确保你的    文件中包含以下配置，以便 Nuxt.js 以静态站点生成模式运行：","level":3},{"id":"/notes/web/nuxt-deploy-vercel#部署到-vercel","title":"部署到 Vercel","titles":[],"content":"安装 Vercel CLI ：\n如果你还没有安装 Vercel CLI，可以使用以下命令安装：     登录 Vercel ：\n使用你的 Vercel 账户登录：     部署到 Vercel ：\n在你的 Nuxt.js 项目目录中运行以下命令：    你将会被提示输入一些配置信息，比如项目名称和是否与现有项目关联。按照提示完成配置。   更新项目设置 ：\n你可能需要更新一些默认的设置以确保项目正确部署。Vercel 会自动检测并配置你的 Nuxt.js 项目，但是你可以在 Vercel 仪表盘中检查并修改配置。","level":3},{"id":"/notes/web/nuxt-deploy-vercel#配置-nuxtjs-应用程序以适应-vercel-平台","title":"配置 Nuxt.js 应用程序以适应 Vercel 平台","titles":[],"content":"添加构建和输出目录配置 ：\n更新    以确保构建和输出目录正确配置：     创建    文件 ：\n在项目根目录下创建一个    文件，配置构建和输出设置：","level":3},{"id":"/notes/web/nuxt-deploy-vercel#验证部署","title":"验证部署","titles":[],"content":"访问 Vercel 项目 URL ：\n部署完成后，你会得到一个 Vercel 提供的项目 URL。访问这个 URL，确保你的 Nuxt.js 应用程序正确运行。","level":3},{"id":"/notes/web/nuxt-deploy-vercel#其他注意事项","title":"其他注意事项","titles":[],"content":"环境变量 ：如果你的项目使用环境变量，确保在 Vercel 仪表盘上正确配置这些变量。   自定义域名 ：如果你有自定义域名，可以在 Vercel 仪表盘中进行配置。通过上述步骤，你应该能够成功地在 Vercel 上部署你的 Nuxt.js 应用程序。如果遇到任何问题，可以参考 Vercel 和 Nuxt.js 的官方文档以获得更多帮助。","level":3},{"id":"/notes/web/nuxt-deploy-vercel#参考","title":"参考","titles":[],"content":"https://vercel.comhttps://nuxt.comhttp://nuxt-vvll.vercel.com","level":3},{"id":"/projects/chatmaxim-electron-vite#chatmaxim-桌面端","title":"ChatMaxim 桌面端","titles":[],"content":"","level":1},{"id":"/projects/chatmaxim-electron-vite#我是-h2-标题","title":"我是 H2 标题","titles":["ChatMaxim 桌面端"],"content":"资料整理中...","level":2},{"id":"/projects/chatmaxim-electron-vite#先在-github-上看看","title":"先在 Github 上看看","titles":["ChatMaxim 桌面端","我是 H2 标题"],"content":"https://github.com/iczp","level":3},{"id":"/projects/chatmaxim-flutter#chatmaxim-移动端flutter","title":"ChatMaxim 移动端(Flutter)","titles":[],"content":"VVLL.net（Vite Vue Link Lab）是一个网站，主要提供关于Vite、Vue和相关开发文档的资源和信息。以下是该网站的主要内容和特点：Vite ：网站涵盖了关于Vite的开发文档和指南，介绍了Vite作为一个现代化的构建工具的特性和用法，帮助开发者快速了解和使用Vite进行项目开发。   Vue ：网站包含了关于Vue.js框架的开发文档和教程，涵盖了Vue的基础知识、组件开发、状态管理等方面的内容，帮助开发者掌握Vue.js的使用技巧。   Link Lab ：Link Lab部分提供了有关前端开发中常用的链接、资源和工具，包括前端框架、UI库、插件等相关内容，帮助开发者发现和使用与前端开发相关的资源。通过VVLL.net，开发者可以获取关于Vite、Vue和前端开发相关的最新资讯、文档和教程，帮助他们更好地理解和应用这些技术，提升前端开发能力和效率。","level":1},{"id":"/projects/nuxt-vvll#nuxt3-vvll","title":"Nuxt3 VVLL","titles":[],"content":"VVLL.net（Vite Vue Link Lab）是一个网站，主要提供关于Vite、Vue和相关开发文档的资源和信息。以下是该网站的主要内容和特点：Vite ：网站涵盖了关于Vite的开发文档和指南，介绍了Vite作为一个现代化的构建工具的特性和用法，帮助开发者快速了解和使用Vite进行项目开发。   Vue ：网站包含了关于Vue.js框架的开发文档和教程，涵盖了Vue的基础知识、组件开发、状态管理等方面的内容，帮助开发者掌握Vue.js的使用技巧。   Link Lab ：Link Lab部分提供了有关前端开发中常用的链接、资源和工具，包括前端框架、UI库、插件等相关内容，帮助开发者发现和使用与前端开发相关的资源。通过VVLL.net，开发者可以获取关于Vite、Vue和前端开发相关的最新资讯、文档和教程，帮助他们更好地理解和应用这些技术，提升前端开发能力和效率。","level":1},{"id":"/sub/guide#sub-guidemd","title":"sub Guide.md","titles":[],"content":"Back to Home","level":1},{"id":"/sub/other#sub-othermd","title":"sub other.md","titles":[],"content":"sub index","level":1},{"id":"/tags/ai/chatgpt#chatgpt","title":"ChatGPT","titles":[],"content":"ChatGPT 是由 OpenAI 开发的一种基于 GPT（Generative Pre-trained Transformer）架构的自然语言处理模型。它通过大量的文本数据进行预训练，并能够生成类似人类的文本响应。以下是对 ChatGPT 的详细介绍：","level":2},{"id":"/tags/ai/chatgpt#chatgpt-的主要特点","title":"ChatGPT 的主要特点","titles":["ChatGPT"],"content":"强大的自然语言理解和生成能力 ：\nChatGPT 能够理解并生成自然语言，适用于多种语言任务，如对话、文本生成、翻译、问答、文本摘要等。   基于 GPT-4 架构 ：\nChatGPT 基于最新的 GPT-4 架构，这使得它在理解上下文和生成连贯文本方面表现出色。相比于前代模型，GPT-4 具有更大的参数量和更强的推理能力。   大规模预训练 ：\nChatGPT 在大规模文本数据上进行预训练，这使其具备丰富的语言知识和上下文理解能力。预训练数据包括各种书籍、文章、网站等，涵盖广泛的主题和领域。   多轮对话能力 ：\nChatGPT 能够进行多轮对话，保持上下文信息，使对话更加连贯和自然。这在对话系统和客服机器人中尤为重要。   定制和微调 ：\n用户可以通过微调 ChatGPT 模型，使其适应特定领域或任务的需求。这种定制化能力使得 ChatGPT 能够更好地满足不同场景下的应用需求。","level":3},{"id":"/tags/ai/chatgpt#使用场景","title":"使用场景","titles":["ChatGPT"],"content":"对话系统和客服 ：\nChatGPT 可以用于构建智能对话系统和客服机器人，帮助企业自动化处理客户咨询和支持请求。   内容生成 ：\nChatGPT 可以生成各种类型的内容，包括文章、博客、产品描述、创意写作等，帮助内容创作者提高效率。   语言翻译 ：\nChatGPT 能够进行高质量的语言翻译，支持多种语言之间的相互转换。   教育和辅导 ：\nChatGPT 可以作为虚拟教师或辅导助手，为学生提供问题解答、作业辅导和学习建议。   问答系统 ：\nChatGPT 可以构建智能问答系统，为用户提供准确的答案和信息查询服务。   文本摘要 ：\nChatGPT 可以对长文档进行自动摘要，提取关键信息，帮助用户快速了解内容。","level":3},{"id":"/tags/ai/chatgpt#优势和局限","title":"优势和局限","titles":["ChatGPT"],"content":"","level":3},{"id":"/tags/ai/chatgpt#优势","title":"优势","titles":["ChatGPT","优势和局限"],"content":"强大的生成能力 ：\nChatGPT 能够生成流畅、自然的文本，适用于各种语言任务。   广泛的应用场景 ：\n其多功能性使得 ChatGPT 在多个领域都有广泛应用，如对话系统、内容生成、翻译等。   持续改进 ：\nOpenAI 持续改进和优化 ChatGPT 模型，提供更好的性能和功能。","level":4},{"id":"/tags/ai/chatgpt#局限","title":"局限","titles":["ChatGPT","优势和局限"],"content":"依赖训练数据 ：\nChatGPT 的生成质量和准确性取决于其训练数据，可能在特定领域表现不佳。   潜在的偏见和不准确 ：\n由于训练数据中的偏见和噪音，ChatGPT 可能生成带有偏见或不准确的信息。   缺乏真正的理解 ：\n虽然 ChatGPT 表现出色，但它并不具备真正的理解能力，仅仅是通过模式匹配生成文本。","level":4},{"id":"/tags/ai/chatgpt#示例","title":"示例","titles":["ChatGPT","优势和局限"],"content":"以下是一个 ChatGPT 的示例对话：用户：什么是量子计算？ChatGPT：量子计算是一种基于量子力学原理的新型计算方式。与传统计算机使用二进制比特（0和1）不同，量子计算机使用量子比特（量子位或qubit）。量子比特可以同时处于多种状态的叠加，这使得量子计算机在处理某些复杂问题时具有潜在的巨大优势，如因子分解、优化问题和模拟量子系统等。量子计算的核心概念包括叠加、纠缠和量子门操作。","level":3},{"id":"/tags/ai/chatgpt#总结","title":"总结","titles":["ChatGPT","优势和局限"],"content":"ChatGPT 是一种强大的自然语言处理模型，具备广泛的应用场景和强大的生成能力。它在对话系统、内容生成、翻译、教育等领域表现出色。虽然存在一定的局限，但随着技术的不断进步，ChatGPT 及其后续版本将为各类应用提供更优质的解决方案。","level":3},{"id":"/tags/ai/edagedb-ai#edgedb-ai","title":"EdgeDB AI","titles":[],"content":"EdgeDB 并不是一个与人工智能（AI）直接相关的产品或技术。EdgeDB 实际上是一个现代化的面向对象关系数据库管理系统（RDBMS），旨在提供强大的数据建模、查询和持久化能力。以下是对 EdgeDB 的简要介绍：此数据更新截至 2022 年 1 月","level":2},{"id":"/tags/ai/edagedb-ai#edgedb-的特点和功能","title":"EdgeDB 的特点和功能","titles":["EdgeDB AI"],"content":"面向对象的数据建模 ：\nEdgeDB 支持复杂数据模型的定义，包括实体（Entity）、关系（Relationship）、枚举（Enum）等，使得数据模型更加清晰和直观。   声明式查询语言 ：\nEdgeDB 提供了一种声明式的查询语言，旨在简化复杂查询的编写和理解。它结合了关系型数据库的强大查询能力和面向对象数据库的灵活性。   类型安全和数据完整性 ：\n通过类型系统和约束，EdgeDB 提供了高度的数据安全性和完整性保障，防止无效数据插入和数据冲突。   内置版本控制 ：\nEdgeDB 内置了版本控制功能，允许用户跟踪和管理数据模型的演变历史，轻松进行数据库架构的变更和回滚。   开发者友好 ：\nEdgeDB 设计简单且易于使用，适合开发人员快速上手，并支持与现有应用程序和工具的集成。   跨平台支持 ：\nEdgeDB 可以在多种操作系统上运行，包括 Linux、macOS 和 Windows，适合各种部署环境和开发团队的需求。","level":3},{"id":"/tags/ai/edagedb-ai#edgedb-与人工智能的关系","title":"EdgeDB 与人工智能的关系","titles":["EdgeDB AI"],"content":"虽然 EdgeDB 本身并不是一种人工智能技术或产品，但是在某些人工智能应用程序的开发和部署过程中，数据库技术扮演着重要角色。例如，在存储和管理大量的结构化数据时，数据库系统如 EdgeDB 能够为机器学习模型的训练和推断提供有效的支持。","level":3},{"id":"/tags/ai/edagedb-ai#总结","title":"总结","titles":["EdgeDB AI"],"content":"EdgeDB 是一种现代化的关系型数据库管理系统，提供了强大的数据建模和查询能力。它适合于开发人员构建复杂的应用程序和服务，尤其在需要高度结构化和类型安全的数据存储时特别有用。虽然 EdgeDB 自身并不涉及人工智能领域，但在支持和优化人工智能应用程序的数据管理方面，数据库技术具有重要的作用。","level":3},{"id":"/tags/backend/abp#aspnet-boilerplate","title":"ASP.NET Boilerplate","titles":[],"content":"https://aspnetboilerplate.com/ASP.NET Boilerplate（ABP）是一个为 ASP.NET 平台设计的应用程序框架，旨在帮助开发者更快速、更高效地构建企业级的应用程序。它提供了一套完整的解决方案，包括数据访问、业务逻辑、用户界面等多个层面，使得开发者能够专注于业务功能的实现，而不需要从头开始构建基础架构。ABP 框架的主要特点包括：模块化设计 ：ABP 框架采用模块化的设计方式，允许开发者根据项目的需求灵活地添加或移除功能模块。   领域驱动设计（DDD） ：ABP 框架遵循领域驱动设计的思想，通过定义清晰的领域模型和业务规则，使得代码更加可维护和可扩展。   数据访问与集成 ：ABP 框架提供了多种数据访问技术，如 Entity Framework、Dapper 等，使得开发者能够轻松地与数据库进行交互。同时，它还支持与其他系统的集成，如消息队列、缓存等。   安全性与认证 ：ABP 框架内置了强大的安全性和认证机制，支持多种身份验证方式，如用户名/密码、OAuth、OpenID 等，确保应用程序的安全性。   用户界面与体验 ：ABP 框架提供了丰富的用户界面组件和模板，使得开发者能够快速地构建出美观且易用的用户界面。通过使用 ABP 框架，开发者可以极大地提高开发效率，减少重复性工作，并确保代码的质量和可维护性。同时，ABP 框架还拥有一个活跃的社区和丰富的文档资源，为开发者提供了良好的支持和帮助。请注意，ASP.NET Boilerplate 是一个不断发展的框架，随着技术的不断进步和新的需求出现，它也在不断地更新和演进。因此，建议在使用之前查阅最新的文档和社区资源，以了解最新的功能和最佳实践。","level":2},{"id":"/tags/backend/abpvnext#abp-vnext","title":"Abp vNext","titles":[],"content":"https://abp.io/ABP VNext 是 abp 团队重新设计的主要版本的 ASP.NET Boilerplate 框架，是一个开源的应用框架，用于开发现代化的企业级 Web 应用程序。它基于.NET 平台，提供了一套丰富的工具和功能，帮助开发人员快速构建可扩展、可维护和可测试的应用程序。ABP VNext 改进了多个方面，其核心 Abp 包包含许多功能，如 DDD 类、审计、授权、后台作业、事件总线、json 序列化、本地化、多租户、线程、时间等。此外，它不再支持 ASP.NET MVC 5.x、Entity Framework 6.x 和其他传统技术，而是基于.net standard，可以在新的 ABP 框架中使用完整的.net framework 或.net core。ABP VNext 框架具有模块化的设计，可以将应用程序拆分为多个模块，每个模块专注于特定的功能，使得应用程序的开发和维护更加灵活和可扩展。同时，它提供了一种标准的多层架构设计模式，将应用程序分为表示层、应用层、领域层和基础设施层，使得应用程序的不同部分可以独立开发和测试，提高了代码的可维护性和可测试性。此外，ABP VNext 还提供了一系列通用模块，包括身份认证、授权、多租户、本地化、设置管理、日志记录等，这些通用模块可以大大加快应用程序的开发速度，减少代码重复。总的来说，ABP VNext 是一个功能丰富、灵活可扩展的框架，适用于现代化的企业级 Web 应用程序的开发。如需更多关于 ABP VNext 的信息，建议访问其官方文档或社区，以获取最新的使用说明、教程和案例。","level":2},{"id":"/tags/backend/efcore#entity-framework-core","title":"Entity Framework Core","titles":[],"content":"Entity Framework Core（简称EF Core）是一个现代的、跨平台的、开源的对象关系映射（ORM）框架，由微软开发。它允许.NET开发者通过.NET对象与关系型数据库进行交互，而无需编写大部分的数据访问代码。EF Core通过对象关系映射减少了数据访问代码的编写，使得开发者可以更加专注于业务逻辑。EF Core支持数据库的迁移，允许开发者通过代码来管理数据库的版本和结构变化。它还支持将LINQ查询自动转换为SQL命令，使得数据访问更加直观和简单。此外，EF Core具有模型级查询过滤器和数据库上下文池等特性，可以提高查询的效率和性能。EF Core的使用一般需要以下步骤：首先，使用NuGet包管理器安装适用于项目的EF Core包；其次，创建数据库上下文类，该类是EF Core的入口点，用于连接到数据库并管理实体（数据库表的映射对象）；最后，根据需要配置数据库连接字符串和映射的实体。总之，Entity Framework Core是一个功能强大且易于使用的ORM框架，它简化了.NET开发者与关系型数据库的交互过程，提高了开发效率和代码质量。如需更多信息，建议查阅微软官方文档或相关教程。","level":2},{"id":"/tags/backend/elasticsearch#elasticsearch","title":"Elasticsearch","titles":[],"content":"Elasticsearch 是一个分布式、RESTful 风格的搜索和分析引擎，基于开源的 Apache Lucene 项目构建。它最常用于实现复杂的搜索功能和实时数据分析。以下是对 Elasticsearch 的详细介绍：","level":2},{"id":"/tags/backend/elasticsearch#主要特点和功能","title":"主要特点和功能","titles":["Elasticsearch"],"content":"分布式架构 ：\nElasticsearch 设计为分布式系统，能够横向扩展，以适应大规模数据存储和处理需求。数据在集群中的不同节点上分片存储，确保高可用性和可靠性。   全文搜索 ：\n作为搜索引擎，Elasticsearch 提供强大的全文搜索功能，支持多种查询方式（如关键词搜索、布尔查询、模糊搜索等），并能处理自然语言处理（NLP）任务。   实时搜索和分析 ：\nElasticsearch 能够实时索引和搜索数据，这使其非常适合需要快速响应的应用，如实时日志分析和监控。   RESTful API ：\nElasticsearch 提供丰富的 RESTful API，支持通过 HTTP 协议进行数据操作和查询，方便与各种编程语言和框架集成。   丰富的查询语言 ：\n使用 Elasticsearch 的查询 DSL（Domain Specific Language），用户可以构建复杂的查询和过滤器，进行高级数据检索和分析。   集成和扩展性 ：\nElasticsearch 可以与其他工具无缝集成，如 Kibana（用于数据可视化）、Logstash（用于日志收集和处理）和 Beats（用于轻量数据传输），构成完整的 Elastic Stack（ELK Stack）。   强大的分析功能 ：\n支持多种聚合操作，如计数、平均值、最小值、最大值、统计分析和直方图等，适用于复杂的数据分析和商业智能应用。","level":3},{"id":"/tags/backend/elasticsearch#核心概念","title":"核心概念","titles":["Elasticsearch"],"content":"索引（Index） ：\nElasticsearch 中的数据存储单位，类似于关系数据库中的数据库。每个索引包含多个文档，并且每个文档都有一个唯一的 ID。   文档（Document） ：\nElasticsearch 中的数据条目，类似于关系数据库中的行。文档使用 JSON 格式表示，包含各种字段和数据。   分片（Shard） ：\n为了实现水平扩展，Elasticsearch 将索引拆分为多个分片（primary shard），每个分片可以独立存储和搜索。分片可以进一步复制（replica shard）以提高数据的可靠性和查询性能。   节点（Node） ：\nElasticsearch 集群中的一个实例，负责存储数据和处理查询。多个节点可以组成一个集群，共同分担负载和提高容错能力。   集群（Cluster） ：\n一组节点的集合，协同工作来处理数据存储和查询任务。集群中的所有节点共享同一个集群名。","level":3},{"id":"/tags/backend/elasticsearch#使用场景","title":"使用场景","titles":["Elasticsearch"],"content":"日志和事件数据分析 ：\n通过与 Logstash 和 Beats 集成，Elasticsearch 常用于日志和事件数据的收集、存储、搜索和分析，是构建实时监控和告警系统的理想选择。   网站搜索 ：\n提供高性能的全文搜索功能，可以用于实现网站内的内容搜索，提高用户的搜索体验。   实时应用程序监控 ：\n收集和分析应用程序性能指标和日志，帮助运维人员及时发现和解决问题。   商业智能和分析 ：\n使用强大的聚合功能，对业务数据进行深度分析，生成统计报表和可视化图表，支持决策制定。   电子商务和推荐系统 ：\n支持复杂的产品搜索和推荐算法，实现个性化的购物体验和推荐服务。","level":3},{"id":"/tags/backend/elasticsearch#总结","title":"总结","titles":["Elasticsearch"],"content":"Elasticsearch 是一个强大且灵活的搜索和分析引擎，适用于各种需要快速搜索和实时数据分析的应用场景。通过其分布式架构、丰富的查询语言和强大的集成功能，Elasticsearch 成为现代数据驱动应用中不可或缺的工具。","level":3},{"id":"/tags/backend/graphql#graphql","title":"GraphQL","titles":[],"content":"GraphQL是一种由Facebook公司于2012年开发的API查询语言。它不仅定义API的查询语法和数据规范，还具有灵活性、性能优化、自描述性等优点。GraphQL旨在提高客户端应用程序的数据获取效率，通过定义数据的类型和结构使得API更加灵活和可扩展。与传统的API不同，GraphQL允许客户端指定需要哪些数据，从而减少了不必要的数据传输和处理，提高了API的效率和可用性。GraphQL基于类型系统，并提供了强大的查询语言，允许客户端自由组合和嵌套查询，以获取所需的精确数据。这种灵活性使得前端开发人员能够更自由地设计和开发用户界面，并减少后端API变更对前端的影响。同时，GraphQL使用单一请求来获取所有需要的数据，减少了多次请求的开销，从而减少了网络延迟，提高了应用程序的性能。此外，GraphQL的自描述性也是其重要特性之一。它使用类型系统和强大的查询语言，使得API具有自描述性。客户端可以通过introspection查询来了解API的结构和可用字段，从而更好地理解和使用API。在生态系统支持方面，GraphQL拥有活跃的社区和丰富的生态系统。许多主流编程语言都有GraphQL的库和工具支持，使得开发人员能够快速上手和使用GraphQL。然而，GraphQL也存在一些潜在的劣势，例如可能需要更多的开发工作来适应其查询语法和数据规范，以及在某些情况下可能需要更多的服务器资源来处理复杂的查询。总的来说，GraphQL是一种强大而灵活的API查询语言，适用于需要高效、灵活和可扩展数据获取的场景。","level":2},{"id":"/tags/backend/hangfire#hangfire","title":"Hangfire","titles":[],"content":"https://www.hangfire.io/Hangfire 是一个开源的 .NET 库，旨在简化和管理后台任务的执行。它允许开发人员轻松地将定时任务、延迟任务和持续运行的后台任务集成到他们的应用程序中，而无需编写复杂的代码。Hangfire 提供了强大的功能和易用的 API，使得任务调度和管理变得简单和高效。","level":2},{"id":"/tags/backend/hangfire#主要特点和功能","title":"主要特点和功能","titles":["Hangfire"],"content":"持久化任务存储 ：\nHangfire 支持将任务持久化存储在各种后端数据库中，如 SQL Server、PostgreSQL、MongoDB 和 Redis。这意味着即使应用程序重启或崩溃，任务也不会丢失，能够在恢复后继续执行。   多种任务类型 ：    火即执行任务（Fire-and-forget job） ：立即执行一次的任务。   延迟任务（Delayed job） ：在指定时间后执行的任务。   定时任务（Recurring job） ：按计划周期性执行的任务。   连续任务（Continuations） ：在另一个任务完成后执行的任务。   自动重试机制 ：\n任务失败时，Hangfire 会自动重试任务执行，确保任务最终完成。重试策略可以根据需要进行配置。   分布式处理 ：\nHangfire 支持在多个服务器上分布式执行任务，利用多个工作节点共同处理任务队列，从而提高任务处理的并发性和可靠性。   实时监控 ：\n提供一个基于 Web 的仪表板，允许开发人员监控任务的执行状态、任务队列、任务历史记录和任务失败原因等。仪表板还支持重新排队和删除任务。   简便的集成 ：\n通过简单的 NuGet 包安装和配置，即可将 Hangfire 集成到现有的 .NET 应用程序中。其直观的 API 使得任务的定义和管理变得非常容易。","level":3},{"id":"/tags/backend/hangfire#使用场景","title":"使用场景","titles":["Hangfire"],"content":"电子邮件通知 ：\n在后台处理电子邮件发送任务，避免阻塞主线程，提高应用程序响应速度。   数据处理和分析 ：\n在后台执行数据处理、转换和分析任务，如批量数据导入、定期数据清理等。   报告生成 ：\n定期生成报表并将结果发送给用户或存储在系统中。   定时任务 ：\n例如，每天凌晨执行系统备份，定期发送提醒通知等。   任务工作流 ：\n组合多个任务形成复杂的工作流，每个任务依赖于前一个任务的完成。","level":3},{"id":"/tags/backend/hangfire#简单示例","title":"简单示例","titles":["Hangfire"],"content":"下面是一个简单的 ASP.NET Core 项目中集成 Hangfire 的示例：安装 Hangfire ：\n在项目中通过 NuGet 包管理器安装 Hangfire：     配置 Hangfire ：\n在    文件中进行配置：     定义任务 ：\n在应用程序中定义一个简单的任务并进行调度：","level":3},{"id":"/tags/backend/hangfire#总结","title":"总结","titles":["Hangfire"],"content":"Hangfire 是一个功能强大的后台任务管理工具，适用于各种 .NET 应用程序。它提供了丰富的任务调度和管理功能，支持任务的持久化存储和分布式执行，简化了后台任务的开发和维护工作。通过 Hangfire，开发人员可以轻松实现高效、可靠的后台任务处理，提高应用程序的性能和用户体验。","level":3},{"id":"/tags/backend/jwt#hangfire","title":"Hangfire","titles":[],"content":"JWT，即 Json Web Token（JSON Web 令牌），是一种基于 JSON 的开放标准（RFC 7519），它提供了一种在网络应用环境间传递声明的方式。这种令牌设计得紧凑且安全，特别适用于分布式站点的单点登录（SSO）场景。JWT 的声明通常用于在身份提供者和服务提供者之间传递经过认证的用户身份信息，以便从资源服务器获取资源。此外，JWT 也可以包含其他必要的业务逻辑声明信息。JWT 在实际应用中是一个字符串，用于在 Web 环境下两个实体之间传输数据。作为目前最流行的跨域身份验证解决方案，JWT 的精髓在于其“去中心化”的特性，即数据保存在客户端。这种设计使得 JWT 在授权认证和信息交换方面表现出色。在授权认证方面，一旦用户登录，每个后续请求都将包括 JWT，从而允许用户访问令牌所允许的路由、服务和资源。单点登录是 JWT 广泛应用的一个功能，因为它开销小，且能在不同域中轻松使用。在信息交换方面，JWT 是各方之间安全传输信息的好方法。由于 JWT 可以签名（例如，使用公钥/私钥对），因此可以确保发送者的身份真实可靠，并且内容在传输过程中未被篡改。JWT 的优点包括无需依赖数据库、Redis 等中间件，因为令牌自带加密的用户和权限信息，后端直接解析即可获取。此外，JWT 还自带有效期，后端无需存储维护，只需进行校验。然而，JWT 也存在一些缺点，如创建后后端无法销毁，需要开发短时间有效期的令牌刷新机制；令牌过长可能导致在前端页面交互跳转时无法被传递；以及安全性相对较差，需要额外的加密处理。总的来说，JWT 是一种强大且灵活的工具，适用于各种网络应用环境间的数据传递和身份验证需求。然而，在使用 JWT 时也需要考虑其潜在的缺点，并根据具体的应用场景和需求进行合理的选择和配置。","level":2},{"id":"/tags/backend/minio#minio","title":"MinIO","titles":[],"content":"https://min.ioMinIO 是一个高性能的对象存储服务器，完全兼容亚马逊 S3 (Amazon S3) API。它专为大规模数据存储和高可用性场景设计，特别适用于私有云和混合云环境。以下是对 MinIO 的详细介绍：","level":2},{"id":"/tags/backend/minio#主要特点和功能","title":"主要特点和功能","titles":["MinIO"],"content":"高性能 ：\nMinIO 采用了高效的 Golang 编写，优化了 I/O 操作，能够在常规硬件上提供非常高的吞吐量和低延迟。它专为大数据处理和机器学习工作负载设计。   S3 兼容性 ：\nMinIO 完全兼容 Amazon S3 API，允许开发者使用现有的 S3 客户端库、应用程序和工具，无需进行任何代码修改。   分布式架构 ：\nMinIO 支持分布式部署，能够在多台服务器上存储数据，实现高可用性和容错能力。分布式部署支持数据冗余和自动故障恢复。   数据保护 ：\nMinIO 提供多种数据保护机制，包括 erasure coding（纠删码）、位旋转和散列校验，确保数据的完整性和持久性。   可扩展性 ：\nMinIO 的架构允许通过添加更多节点来扩展存储容量和性能，适用于大规模数据存储需求。   多租户支持 ：\nMinIO 支持多租户环境，通过策略和访问控制列表（ACL）管理用户权限，确保数据隔离和安全。   简单安装和管理 ：\nMinIO 提供了简单的安装和配置流程，支持 Docker、Kubernetes 等容器化部署，提供了 Web 控制台和 CLI 工具用于管理和监控。","level":3},{"id":"/tags/backend/minio#使用场景","title":"使用场景","titles":["MinIO"],"content":"大数据存储 ：\nMinIO 可用于存储和管理大规模的非结构化数据，如日志、备份、媒体文件等，适用于大数据分析和处理。   机器学习 ：\n由于其高性能和高可用性，MinIO 是机器学习工作负载的数据存储的理想选择，支持快速的数据读写和处理。   混合云和私有云存储 ：\nMinIO 可以部署在本地数据中心，也可以与公有云集成，适用于构建混合云存储解决方案。   灾难恢复 ：\n通过分布式部署和数据冗余，MinIO 可用于构建高可靠性的灾难恢复解决方案，确保数据在不同地点的备份和恢复。","level":3},{"id":"/tags/backend/minio#安装和使用示例","title":"安装和使用示例","titles":["MinIO"],"content":"以下是一个在本地安装和使用 MinIO 的简单示例：下载和安装 MinIO ：\n使用官方提供的可执行文件快速启动 MinIO 服务器：     访问 MinIO 控制台 ：\n默认情况下，MinIO 服务器启动后可以通过浏览器访问其控制台，URL 类似于   。使用启动时显示的访问密钥和秘密密钥进行登录。   使用 MinIO 客户端（mc）管理存储 ：\nMinIO 提供了一个命令行工具   ，用于与 MinIO 服务器交互：","level":3},{"id":"/tags/backend/minio#总结","title":"总结","titles":["MinIO"],"content":"MinIO 是一个强大且灵活的对象存储解决方案，兼容 S3 API，提供高性能、高可用性和可扩展性，适用于各种大规模数据存储和处理场景。通过简单的安装和配置，开发人员和运维人员可以快速部署和管理 MinIO，构建可靠的数据存储基础设施。","level":3},{"id":"/tags/backend/net#net","title":".NET","titles":[],"content":".NET 是一个由 Microsoft 开发的跨平台应用程序开发框架，它提供了一个统一的编程模型，以及丰富的类库和工具集，用于构建各种类型的应用程序，包括 Web、桌面、移动、游戏、物联网等。以下是 .NET 的一些主要特点和优势：跨平台性 ：.NET Core 和 .NET 5/6/7 等后续版本支持在多种操作系统上运行，包括 Windows、Linux 和 macOS，使得开发者能够在不同平台上使用统一的编程模型和开发体验。   强大的类库和工具 ：.NET 框架包含了大量的预编译类和接口，覆盖了网络编程、数据库访问、图形用户界面设计、XML 解析等常见任务，简化了应用程序的开发过程。此外，Visual Studio 等开发工具提供了丰富的功能和集成环境，提高了开发效率。   语言互操作性 ：.NET 支持多种编程语言，如 C#、VB.NET、F# 等。这些语言在 .NET 运行时环境下可以互相调用对方的代码和类库，使得开发者可以根据自己的习惯和项目的需求选择合适的编程语言。   性能优化 ：.NET 运行时环境采用了即时编译（JIT）技术，将中间语言（IL）代码转换为本地机器码，提高了应用程序的执行效率。同时，.NET 还提供了垃圾回收、内存管理等机制，降低了内存泄漏和内存碎片化的风险。   安全性 ：.NET 提供了强大的安全性保障，包括类型安全、代码访问安全等机制，防止了恶意代码的执行和数据泄露。   云原生支持 ：随着云计算的普及，.NET 也提供了对云原生的支持，包括与 Azure 等云平台的集成、微服务架构的支持等，使得开发者能够轻松构建和部署云应用程序。总的来说，.NET 是一个功能强大、易于使用且高度可定制的应用程序开发框架，适用于各种规模和复杂度的项目。无论是初学者还是经验丰富的开发者，都可以通过 .NET 框架快速构建高质量的应用程序。","level":2},{"id":"/tags/backend/netcore#net-core","title":".NET Core","titles":[],"content":".NET Core是微软开发的跨平台开源应用程序框架，适用于Windows、Linux和macOS等多种操作系统。它不仅是微软官方推出的第一个跨平台.NET实现，也是.NET 5、.NET 6等后续版本的基础。作为一个开源项目，.NET Core促进了更加透明的开发过程和积极参与的社区。在.NET Core中开发的应用程序具有代码可重用的特点，无需关心目标平台是什么。这得益于其跨平台的特性，使得开发者能够更容易地在不同操作系统上部署和运行应用程序。此外，.NET Core提供了灵活的部署方式。开发者可以选择依赖于框架的部署方式，此时应用程序依赖于安装了.NET Core的系统范围版本。或者选择自包含的部署方式，这种方式下应用程序会包含所有必要的.NET Core组件，无需在目标系统上预先安装.NET Core。在功能层面，.NET Core包含了许多核心组件，如采用RyuJIT编译的运行平台Core CLR、编译器平台.NET Compiler Platform等。RyuJIT是微软发展的新式即地编译器，用以替换现有的.NET Framework的JIT编译器，并提供了性能上的显著提升。总的来说，.NET Core是一个功能强大、灵活且跨平台的应用程序开发框架，适用于各种类型的应用程序开发需求。无论你是初学者还是经验丰富的开发者，都可以通过.NET Core来构建高质量、高性能的应用程序。","level":2},{"id":"/tags/backend/nuget#nuget","title":"NuGet","titles":[],"content":"NuGet 是一个自由开源的软件包管理系统，专为 Microsoft 开发平台设计。它最初被称为 NuPack，作为 Visual Studio 的扩展，能够简化在 Visual Studio 项目中添加、更新和删除库（以程序包的形式部署）的操作。NuGet 包是打包成单个 ZIP 文件的，使用开放打包约定（OPC）格式，包含编译代码（Dll）、与该代码相关的其他文件以及描述性清单（包含包版本号等信息）。NuGet 不仅是一个包管理平台，更确切地说，它是.NET 平台的包管理工具。它提供了一系列客户端用于生成、上传和使用包，并拥有一个用于存储所有包的中心库——NuGet Gallery。如果有需要，也可以搭建自己的私有 NuGet 库。NuGet 的实现均为开源项目，包括了客户端工具、服务器、官方网站，以及各语言的文档等。NuGet 作为 Visual Studio 的扩展，能够方便地合并第三方的组件库，使开发人员能够分享自己开发的工具或库。当需要分享时，开发人员只需建立一个 NuGet 包，并将其放到 NuGet 的站点上。这使得 NuGet 能够更方便地将一些 dll 和文件（如 jquery）添加到项目中，而无需从文件中复制粘贴。NuGet 还支持在云中（如在 Azure DevOps 上）、在私有网络中或者甚至直接在本地文件系统以私密方式托管包。它支持公用 nuget.org 主机旁边的专用主机，因此，开发人员可以使用 NuGet 包来共享组织或工作组专用的代码。总的来说，NuGet 是一个功能强大且灵活的包管理工具，可以大大简化.NET 开发人员在项目中的库管理任务，提高开发效率。","level":2},{"id":"/tags/backend/oauth#oauth","title":"OAuth","titles":[],"content":"OAuth 是一个开放标准，它为用户资源的授权提供了一个安全的、开放而又简易的方式。OAuth 允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。OAuth 的核心思想是，用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站在特定的时段内访问特定的资源。这样，OAuth 让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。OAuth 具有多个显著的优点。首先，它提高了系统的安全性，因为客户端无需接触用户的密码。其次，OAuth 被广泛应用，已被许多公司和组织采用，这使得使用 OAuth 的应用更容易被其他公司或组织集成。此外，OAuth 使用短寿命的访问令牌，减少了泄露和攻击的风险，并提供了灵活的令牌封装机制，方便不同的客户端和应用使用令牌获取授权。然而，OAuth 也存在一些缺点。例如，使用 OAuth 进行认证和授权需要理解并实现许多概念，可能会使对接流程变得相对复杂和耗时。在实际应用中，OAuth 被广泛用于第三方登录、开放平台等场景。例如，当自己开发的系统需要引入微信、QQ 等第三方登录时，可以使用 OAuth 协议。同样，当自己的系统需要开放一些接口供第三方应用查询使用相关信息时，OAuth 也是一个很好的选择。总的来说，OAuth 是一个功能强大、安全且广泛应用的开放标准，它极大地简化了用户资源的授权过程，并提高了系统的安全性。","level":2},{"id":"/tags/backend/prisma#prisma","title":"Prisma","titles":[],"content":"Prisma 是一个现代化的数据库访问工具，旨在简化开发人员与数据库的交互，并提供高效、类型安全的数据访问方式。它支持多种数据库，包括 MySQL、PostgreSQL、SQLite 等，使开发人员能够轻松地与数据库进行交互。Prisma 具有以下几个显著的特点：类型安全 ：通过生成类型安全的 API，Prisma 使得开发人员可以在编译时发现和纠正错误，降低了运行时错误的发生概率。   自动生成数据库访问代码 ：Prisma 可以根据数据库模型自动生成数据库访问代码，从而减少了手动编写数据库访问层的工作量。   实时数据同步 ：Prisma 提供了实时数据同步功能，当数据库发生变化时，它可以自动更新客户端的数据，保持数据的实时性。   复杂数据关系模型的支持 ：Prisma 支持定义复杂的数据关系模型，包括一对一、一对多、多对多等关系，这使得数据库设计更加灵活。   性能优化 ：Prisma 在设计时考虑了性能优化问题，生成的 SQL 查询语句效率高，可以满足高并发和大数据量的需求。   可扩展性 ：作为一个开源项目，Prisma 具有良好的可扩展性，可以根据需要自定义插件和扩展功能。Prisma 的应用场景非常广泛，它可以作为 Web 应用的后端数据存储层，也可以与移动应用结合，通过 GraphQL API 为 iOS 和 Android 应用提供数据服务。在微服务架构中，每个服务都可以独立地使用 Prisma 与自己的数据库进行通信。综上所述，Prisma 是一个功能强大、灵活且易于使用的数据库访问工具，它极大地简化了开发人员与数据库的交互过程，提高了开发效率和数据访问的安全性。","level":2},{"id":"/tags/backend/quartz#quartz","title":"Quartz","titles":[],"content":"Quartz 是一个功能强大的开源作业调度库，主要用于 Java 应用程序。它允许开发人员在应用程序中调度和管理各种任务，例如定时任务、周期性任务和复杂的工作流任务。Quartz 具有高度的灵活性和可扩展性，可以在单机和分布式环境中使用。","level":2},{"id":"/tags/backend/quartz#主要特点和功能","title":"主要特点和功能","titles":["Quartz"],"content":"丰富的调度能力 ：\nQuartz 支持各种调度需求，包括简单的时间间隔调度、复杂的 Cron 表达式调度、以及基于日历的调度等。     作业和触发器 ：\nQuartz 通过作业（Job）和触发器（Trigger）来定义和控制任务的执行。作业是实际执行的任务逻辑，而触发器则定义了任务的执行时间和条件。     持久化支持 ：\nQuartz 可以将调度信息持久化到数据库中，支持多种数据库，包括 MySQL、PostgreSQL、Oracle 等。这使得任务调度信息可以在应用程序重启后恢复。     分布式调度 ：\nQuartz 支持分布式部署，能够在多个节点之间协调任务调度和执行，提高系统的可靠性和可扩展性。   错过处理和异常处理 ：\nQuartz 提供了灵活的机制来处理任务的错过执行和异常情况，可以配置重试策略、错误处理逻辑等。   插件和扩展 ：\nQuartz 提供了一些内置的插件，并允许开发人员创建自定义插件，以扩展其功能。例如，Quartz 支持邮件通知、JMX 集成等。","level":3},{"id":"/tags/backend/quartz#使用方法","title":"使用方法","titles":["Quartz"],"content":"引入 Quartz 库 ：\n在 Maven 项目中引入 Quartz 依赖：     创建调度器 ：\n创建和启动一个调度器实例：     定义作业和触发器 ：\n定义一个简单的作业和触发器，并将其调度：     停止调度器 ：\n当不再需要时，可以停止调度器：","level":3},{"id":"/tags/backend/quartz#示例应用场景","title":"示例应用场景","titles":["Quartz"],"content":"定时报告生成 ：\n定期生成并发送报告，例如每周一早上生成上周的销售报告并发送到相关人员的邮箱。   系统监控和维护任务 ：\n定期执行系统监控和维护任务，例如每晚执行数据库备份、磁盘清理等。   提醒和通知系统 ：\n基于时间的提醒和通知，例如每天下午提醒用户完成每日任务、到期日提醒等。   数据同步 ：\n定期同步不同系统之间的数据，确保数据一致性和及时性。","level":3},{"id":"/tags/backend/quartz#总结","title":"总结","titles":["Quartz"],"content":"Quartz 是一个强大且灵活的作业调度框架，适用于各种复杂的调度需求。通过其丰富的功能和易用的 API，开发人员可以轻松实现各种定时任务和后台作业，提升应用程序的自动化和可靠性。Quartz 的持久化支持和分布式调度能力使得它在高可用性和大规模系统中表现出色。","level":3},{"id":"/tags/backend/rabbitmq#rabbitmq","title":"RabbitMQ","titles":[],"content":"RabbitMQ 是一个开源的消息代理软件（也称为消息中间件），用于在分布式系统中通过消息传递实现应用程序和服务之间的通信。RabbitMQ 支持多种消息传递协议和消息队列模式，能够在高并发和高可用性的场景中提供可靠的消息传输和处理。以下是对 RabbitMQ 的详细介绍：","level":2},{"id":"/tags/backend/rabbitmq#主要特点和功能","title":"主要特点和功能","titles":["RabbitMQ"],"content":"支持多种消息协议 ：\nRabbitMQ 支持多种消息传递协议，如 Advanced Message Queuing Protocol (AMQP)、Message Queuing Telemetry Transport (MQTT) 和 Streaming Text Oriented Messaging Protocol (STOMP)。   多语言客户端库 ：\nRabbitMQ 提供了多种编程语言的客户端库，支持 Java、Python、Ruby、.NET、Go、JavaScript 等，方便不同技术栈的应用集成。   消息持久化 ：\nRabbitMQ 支持消息持久化，可以将消息存储在磁盘上，确保在系统崩溃或重启后消息不丢失。   高可用性 ：\nRabbitMQ 支持集群部署和镜像队列，能够在节点发生故障时自动切换和恢复，确保消息服务的高可用性。   灵活的路由机制 ：\nRabbitMQ 提供多种交换器类型（Direct、Fanout、Topic、Headers），支持复杂的消息路由规则，可以根据不同的需求灵活地分发消息。   管理和监控工具 ：\nRabbitMQ 提供了强大的管理和监控工具，如 Web 管理界面、命令行工具和插件，方便管理员进行配置、监控和调试。   扩展性 ：\n通过插件机制，RabbitMQ 可以扩展其功能，支持额外的协议、身份认证方式、日志记录等。","level":3},{"id":"/tags/backend/rabbitmq#核心概念","title":"核心概念","titles":["RabbitMQ"],"content":"生产者（Producer） ：\n发送消息到 RabbitMQ 的应用程序或服务。生产者将消息发送到交换器（Exchange）。   消费者（Consumer） ：\n从 RabbitMQ 中接收和处理消息的应用程序或服务。消费者从队列（Queue）中获取消息进行处理。   队列（Queue） ：\n存储消息的缓冲区，消费者从队列中接收消息进行处理。队列是消息的实际存储位置。   交换器（Exchange） ：\n接受来自生产者的消息，并根据绑定规则将消息路由到一个或多个队列。交换器类型包括 Direct、Fanout、Topic 和 Headers。   绑定（Binding） ：\n定义交换器和队列之间的路由规则。绑定决定了消息从交换器到队列的传递路径。   消息（Message） ：\n生产者发送的数据信息，包含消息头（Headers）和消息体（Body）。消息头用于存储元数据，消息体是实际的数据内容。","level":3},{"id":"/tags/backend/rabbitmq#使用场景","title":"使用场景","titles":["RabbitMQ"],"content":"任务队列 ：\n用于在分布式系统中异步处理任务，将任务分发到多个工作进程，平衡负载和提高处理效率。   消息广播 ：\n在发布/订阅模式中，将消息广播给多个消费者，实现实时通知和事件驱动架构。   请求/响应模式 ：\n支持 RPC（远程过程调用）模式，实现服务之间的同步通信和请求响应。   日志收集和分析 ：\n将日志信息发送到 RabbitMQ 进行集中收集和分析，支持实时监控和故障排查。   数据流处理 ：\n用于流数据的传输和处理，支持大数据和实时分析应用。","level":3},{"id":"/tags/backend/rabbitmq#优势","title":"优势","titles":["RabbitMQ"],"content":"可靠性 ：\n支持消息确认机制、持久化和高可用性，确保消息传输的可靠性和数据不丢失。   灵活性 ：\n多种交换器和绑定规则，支持复杂的消息路由和分发。   可扩展性 ：\n集群和镜像队列支持，能够处理大规模消息传输和高并发场景。   易管理性 ：\n提供丰富的管理工具和插件，方便运维和监控。","level":3},{"id":"/tags/backend/rabbitmq#总结","title":"总结","titles":["RabbitMQ"],"content":"RabbitMQ 是一个功能强大且灵活的消息中间件，广泛应用于分布式系统中实现异步消息传递和任务处理。通过其可靠性、灵活性和可扩展性，RabbitMQ 能够满足各种高并发和高可用性应用场景的需求，成为现代微服务架构和消息驱动架构中的关键组件。","level":3},{"id":"/tags/backend/swagger#swagger","title":"Swagger","titles":[],"content":"Swagger 是一个规范和完整的框架，主要用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。它旨在使客户端和文件系统作为服务器以同样的速度来更新，并确保文件的方法、参数和模型紧密集成到服务器端的代码，以保持 API 的同步。Swagger 的主要功能和特点包括：接口文档自动生成 ：Swagger 可以从源代码中自动生成接口文档，包括接口名称、描述、请求参数、响应数据等信息，减少了手动编写和维护文档的工作量。   在线文档展示 ：Swagger 提供了一个直观的、可交互的接口文档界面，使得开发人员可以方便地查看和测试接口，无需打开传统的文档文件。   功能测试 ：Swagger 支持对请求参数进行校验，并提供模拟请求的功能，使开发人员能够在不依赖真实数据的情况下进行接口测试。   接口版本管理 ：Swagger 支持对接口的版本管理，以及对不同版本接口的文档的展示和对比，有助于开发人员进行接口的迭代和升级。Swagger 还有一组开源项目，包括 Swagger-tools（提供各种与 Swagger 进行集成和交互的工具）、Swagger-js（用于 JavaScript 的 Swagger 实现）以及 Swagger-node-express（用于 node.js 的 Express web 应用框架的 Swagger 模块）等。请注意，虽然 Swagger 在生产环境中可以使用，但在发布时可能需要配置相关参数，以确保生产环境的稳定性和安全性。具体配置方法可能因使用的技术和框架而有所不同，建议查阅相关文档或寻求专业人士的帮助。如需了解更多关于 Swagger 的详细信息和使用方法，建议查阅其官方文档或相关教程。","level":2},{"id":"/tags/backend/typeorm#typeorm","title":"TypeORM","titles":[],"content":"TypeORM 是一个在 Node.js 中使用的对象关系映射（ORM）库，它允许开发者使用面向对象的方式来操作数据库。通过 TypeORM，开发者可以将数据库表映射为类，将表中的行映射为类的实例，从而简化了数据库操作的编写和维护。TypeORM 支持多种主流数据库系统，包括但不限于 MySQL、PostgreSQL、MariaDB、SQLite、MS SQL Server、Oracle 和 WebSQL 等。这使得开发者可以根据项目需求选择适合的数据库进行开发。TypeORM 提供了丰富的查询 API，支持复杂的查询条件、关联查询、分页查询等，方便开发者进行数据检索和分析。此外，它还支持数据库迁移功能，可以方便地管理数据库结构的变更，避免手动修改数据库结构带来的问题。TypeORM 还提供了缓存功能，可以提高数据库查询的性能和响应速度。通过缓存，开发者可以减少对数据库的频繁访问，从而提高应用的性能和用户体验。TypeORM 的应用场景非常广泛，可以用于构建各种类型的 Web 应用程序，包括电子商务网站、社交媒体平台、博客等。同时，它也可以用于开发各种后台管理系统和数据分析平台。此外，TypeORM 还提供了与 Express 框架的无缝集成支持，进一步简化了数据库操作的代码编写。总的来说，TypeORM 是一个功能强大、灵活且易于使用的 ORM 库，它极大地简化了 Node.js 中的数据库操作，提高了开发效率和代码质量。","level":2},{"id":"/tags/backend/websocket#websocket","title":"WebSocket","titles":[],"content":"WebSocket 是一种在单个 TCP 连接上进行全双工通信的网络协议，它允许客户端和服务器之间进行实时数据传输。WebSocket 解决了传统的 HTTP 协议在通信效率和实时性方面的限制，特别适用于需要频繁数据交换和实时更新的应用场景。以下是对 WebSocket 的详细介绍：","level":2},{"id":"/tags/backend/websocket#特点和优势","title":"特点和优势","titles":["WebSocket"],"content":"全双工通信 ：\nWebSocket 通过在客户端和服务器之间建立持久连接，实现了全双工通信，即客户端和服务器可以同时发送和接收数据，而无需每次通信都建立新的连接。   低延迟和高效性 ：\n由于建立了持久连接，WebSocket 可以实现较低的延迟，避免了传统的 HTTP 请求和响应模型中频繁建立和关闭连接的开销，从而提高了通信效率。   跨域支持 ：\nWebSocket 支持跨域通信，即在不同的域名下的客户端和服务器之间也可以建立连接和进行数据交换，而不受同源策略的限制。   实时性和即时更新 ：\nWebSocket 适用于需要实时数据传输的应用场景，如即时通讯、实时位置跟踪、在线游戏、股票市场数据更新等，可以实时推送数据给客户端，实现即时更新。   支持多种应用协议 ：\nWebSocket 协议本身是一个通用的协议，不限于特定的应用领域，因此可以支持多种应用的实时通信需求。","level":3},{"id":"/tags/backend/websocket#websocket-的工作原理","title":"WebSocket 的工作原理","titles":["WebSocket"],"content":"握手阶段 ：   客户端通过 HTTP 或 HTTPS 发起 WebSocket 握手请求，请求头中包含特定的 Upgrade 和 Connection 字段，告知服务器希望升级到 WebSocket 协议。  服务器收到请求后，如果支持 WebSocket，会返回状态码 101 Switching Protocols，表示升级成功，此时连接升级为 WebSocket。   数据传输阶段 ：   客户端和服务器之间的连接升级后，可以直接通过发送数据帧（frame）进行通信，数据帧可以是文本帧、二进制帧或控制帧。  客户端和服务器都可以发送数据帧，并且数据帧可以包含应用层协议的数据。   连接关闭阶段 ：   客户端或服务器可以发送关闭帧（close frame）来关闭连接，关闭帧包含关闭状态码和可选的关闭原因。","level":3},{"id":"/tags/backend/websocket#websocket-和-http-的区别","title":"WebSocket 和 HTTP 的区别","titles":["WebSocket"],"content":"连接方式 ：   HTTP 是一种请求-响应协议，每次请求都需要建立新的连接，请求结束后即关闭连接。  WebSocket 建立一次连接后保持持久连接状态，客户端和服务器可以随时进行数据交换。   通信效率 ：   HTTP 在每次请求时都需要重新建立连接和传输头部信息，效率较低。  WebSocket 通过持久连接和数据帧传输，可以实现低延迟和高效率的通信。   实时性 ：   HTTP 通常不适用于需要实时数据传输的应用场景。  WebSocket 适用于实时性要求高的应用，可以实时推送数据给客户端。","level":3},{"id":"/tags/backend/websocket#websocket-的应用场景","title":"WebSocket 的应用场景","titles":["WebSocket"],"content":"即时通讯和聊天应用 ：如在线聊天室、社交应用中的实时消息传递。   实时位置跟踪 ：如地图应用中的实时位置更新和导航信息推送。   在线游戏 ：支持实时多人游戏中的数据传输和状态同步。   金融市场 ：如股票交易平台中的实时股价更新和交易通知。   监控和控制系统 ：如实时监控系统中的数据传输和告警通知。","level":3},{"id":"/tags/backend/websocket#总结","title":"总结","titles":["WebSocket"],"content":"WebSocket 是一种现代化的网络通信协议，通过建立持久连接和全双工通信，实现了低延迟、高效率和实时性的数据传输。它在多种应用场景中广泛应用，为实时数据交换提供了有效的解决方案，成为许多实时应用程序的重要组成部分。","level":3},{"id":"/tags/databases/edgedb#edgedb","title":"EdgeDB","titles":[],"content":"EdgeDB 是一种现代的数据库管理系统，旨在解决传统关系型数据库和 NoSQL 数据库的一些局限性。它结合了关系数据库和图数据库的优点，提供了强大的数据建模能力和灵活的查询语言。以下是对 EdgeDB 的详细介绍：","level":2},{"id":"/tags/databases/edgedb#edgedb-的主要特点","title":"EdgeDB 的主要特点","titles":["EdgeDB"],"content":"基于图的关系模型 ：\nEdgeDB 使用图模型来表示数据，但仍然保留了关系数据库的优势。这种方法允许更加自然和直观的数据建模，特别是对于复杂的、具有多层嵌套关系的数据结构。   强类型系统 ：\nEdgeDB 提供了强类型系统，这意味着数据类型在数据库模式中有严格的定义和验证。这有助于减少运行时错误并提高数据的一致性和可靠性。   高级查询语言（EdgeQL） ：\nEdgeQL 是 EdgeDB 提供的高级查询语言，设计目标是比 SQL 更加易读和强大。EdgeQL 支持复杂的查询和数据操作，同时简化了多表关联、嵌套选择等操作。   自动迁移 ：\nEdgeDB 具备内置的迁移工具，能够自动生成数据库迁移脚本，帮助开发者轻松管理数据库模式的演变。   内置权限管理 ：\nEdgeDB 提供了细粒度的权限管理，可以基于用户角色设置不同的访问权限，增强了数据安全性。   JSON 支持 ：\nEdgeDB 原生支持 JSON 数据类型，允许开发者存储和查询 JSON 数据，同时保留关系型数据库的特性。","level":3},{"id":"/tags/databases/edgedb#安装和使用","title":"安装和使用","titles":["EdgeDB"],"content":"","level":3},{"id":"/tags/databases/edgedb#安装-edgedb","title":"安装 EdgeDB","titles":["EdgeDB","安装和使用"],"content":"EdgeDB 支持多种操作系统的安装，包括 macOS、Linux 和 Windows。可以通过以下命令进行安装：","level":4},{"id":"/tags/databases/edgedb#创建和管理数据库","title":"创建和管理数据库","titles":["EdgeDB","安装和使用"],"content":"安装完成后，可以通过命令行工具创建并管理 EdgeDB 数据库。","level":4},{"id":"/tags/databases/edgedb#定义模式","title":"定义模式","titles":["EdgeDB","安装和使用"],"content":"EdgeDB 使用 SDL（Schema Definition Language）来定义数据库模式。例如：上述定义表示一个    类型，其中包含一个必需的    属性和一个多值的    链接，指向其他    实例。","level":4},{"id":"/tags/databases/edgedb#执行查询","title":"执行查询","titles":["EdgeDB","安装和使用"],"content":"可以使用 EdgeQL 进行数据查询和操作。例如，插入和查询数据：","level":4},{"id":"/tags/databases/edgedb#应用场景","title":"应用场景","titles":["EdgeDB","安装和使用"],"content":"EdgeDB 适用于各种需要复杂数据建模和高效查询的应用场景，包括但不限于：社交网络 ：处理用户之间的关系和互动。   推荐系统 ：基于用户行为和关系进行推荐。   知识图谱 ：存储和查询复杂的知识数据。   内容管理系统 ：管理多层次的内容结构。","level":3},{"id":"/tags/databases/edgedb#总结","title":"总结","titles":["EdgeDB","安装和使用"],"content":"EdgeDB 通过结合关系型数据库和图数据库的优点，提供了一种现代、高效、灵活的数据库管理解决方案。它的强类型系统、高级查询语言 EdgeQL、自动迁移和内置权限管理等特性，使其在处理复杂数据结构和高效查询方面表现出色。对于需要高性能和复杂数据建模的应用场景，EdgeDB 是一个值得考虑的选择。","level":3},{"id":"/tags/databases/mongodb#mongodb","title":"MongoDB","titles":[],"content":"MongoDB 是一个基于分布式文件存储的数据库，由 C++语言编写，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。它是一个介于关系数据库和非关系数据库之间的产品，具备非关系数据库中最丰富的功能，并且非常接近关系数据库。MongoDB 的主要特点包括高性能、易部署、易使用，以及存储数据的便捷性。它使用面向集合的存储方式，可以存储对象类型的数据，并且模式自由，意味着不需要预先定义数据的结构。MongoDB 支持动态查询，并允许对数据建立索引。此外，它使用高效的二进制数据存储方式，包括大型对象（如视频等），并且能够自动处理碎片，以支持云计算层次的扩展性。MongoDB 支持多种语言，如 Golang、RUBY、PYTHON、JAVA、C++、PHP、C#等，其文件存储格式为 BSON，这是一种类似 JSON 的扩展格式，使得它可以存储复杂的数据类型。BSON 的使用使得 MongoDB 能够支持非常强大的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能。MongoDB 适用于多种场景，如网站实时数据处理、缓存、高伸缩性场景等。然而，它并不适用于需要高度事务性的系统、传统的商业智能应用以及复杂的跨文档（表）级联查询。在实际应用中，MongoDB 在多个领域都有广泛的应用，如移动和物联网应用、电子商务平台、地理空间和位置数据、游戏开发、机器学习和人工智能、日志和事件数据，以及任务和工作流管理等。在这些场景中，MongoDB 能够提供灵活的数据模型和高效的数据处理能力，满足各种复杂的数据需求。总的来说，MongoDB 是一个功能强大、灵活且易于使用的数据库系统，适用于各种需要高性能数据存储和处理的场景。","level":2},{"id":"/tags/databases/mssql#主要特点","title":"主要特点","titles":[],"content":"关系型数据库 ：SQL Server 是一种关系型数据库管理系统，支持标准的 SQL 查询语言，具有良好的数据完整性和一致性。   多版本支持 ：SQL Server 提供多个版本，包括企业版、标准版、开发者版和免费的 Express 版本，以满足不同规模和需求的数据库应用。   跨平台支持 ：最新的 SQL Server 版本已经支持在 Windows 和 Linux 平台上运行，提供更多的部署选择。   安全性 ：SQL Server 提供强大的安全功能，包括数据加密、访问控制、身份验证和审计功能，确保数据库中的数据安全性。   高可用性和容错性 ：SQL Server 支持高可用性解决方案，如故障转移集群（Failover Cluster）、数据库镜像（Database Mirroring）和始终可用组（Always On Availability Groups），确保数据库的稳定性和可靠性。   扩展性 ：SQL Server 提供了水平和垂直扩展的选项，可以根据需要增加服务器资源和处理能力，应对不断增长的数据量和用户需求。   BI 和数据分析支持 ：SQL Server 集成了业务智能（BI）和数据分析服务，如报表服务（Reporting Services）、分析服务（Analysis Services）和集成服务（Integration Services），支持复杂的数据分析和报告生成。   开发者友好 ：SQL Server 提供了丰富的开发工具和 SDK，支持多种开发语言和平台的集成，如 .NET、Java、Python 等，方便开发者进行应用程序开发和数据库集成。","level":3},{"id":"/tags/databases/mssql#应用场景","title":"应用场景","titles":[],"content":"企业应用程序 ：SQL Server 被广泛应用于企业级应用程序的数据库后端，如 ERP 系统、CRM 系统等。   Web 应用程序 ：作为 Web 应用程序的数据库支持，用于存储和管理网站和应用程序的数据。   商业智能和数据分析 ：SQL Server 提供强大的数据分析和报表服务，支持企业进行业务智能和数据驱动决策。   数据仓库 ：SQL Server 可以用作数据仓库解决方案，用于集成和存储大量结构化和非结构化数据，并支持复杂的数据分析查询。   开发和测试环境 ：SQL Server 提供了免费的 Express 版本，适用于开发者在本地开发和测试应用程序时使用。   云环境 ：SQL Server 在 Azure 平台上提供云数据库服务，支持在云端灵活部署和管理数据库。","level":3},{"id":"/tags/databases/mssql#发展与历史","title":"发展与历史","titles":[],"content":"发布历史 ：SQL Server 最早发布于 1989 年，自那时以来，它经历了多个版本的更新和改进，增强了性能、安全性和功能特性。   社区支持和生态系统 ：SQL Server 拥有庞大的用户社区和丰富的生态系统，包括第三方工具、插件和扩展，支持用户定制和扩展数据库功能。","level":3},{"id":"/tags/databases/mssql#总结","title":"总结","titles":[],"content":"Microsoft SQL Server 是一款功能强大、安全可靠的关系型数据库管理系统，广泛应用于企业级数据库解决方案、数据分析和业务智能等领域。其丰富的特性和灵活的部署选项使得 SQL Server 成为许多组织和开发者的首选，帮助他们管理和利用数据资产，支持业务发展和创新。","level":3},{"id":"/tags/databases/mysql#mysql","title":"MySql","titles":[],"content":"MySQL 是一个流行的开源关系型数据库管理系统（RDBMS），由瑞典 MySQL AB 公司开发，后来被甲骨文公司（Oracle）收购。它以其易用性、稳定性和高性能而闻名，被广泛用于各种规模的应用，从个人项目到大型企业级应用。MySQL 使用结构化查询语言（SQL）作为数据库管理语言，支持标准的 SQL 功能，如数据查询、插入、更新和删除等。它还提供了丰富的 API 接口，可以与多种编程语言进行集成，如 C、C++、Python、Java 等，使得开发者能够方便地在应用程序中操作数据库。MySQL 具有以下几个显著的特点：高性能 ：MySQL 采用了多种优化技术，如索引、查询缓存和并行处理等，以提高数据库操作的性能。它支持高并发访问，可以处理大量数据和复杂查询，满足企业级应用的需求。   易用性 ：MySQL 提供了友好的图形化界面管理工具，如 phpMyAdmin 等，使得用户可以直观地管理和操作数据库。同时，它也提供了丰富的文档和社区支持，帮助用户解决使用过程中的问题。   可靠性 ：MySQL 具有强大的数据备份和恢复功能，可以确保数据的安全性和可靠性。它还支持事务处理，保证数据的完整性和一致性。   可扩展性 ：MySQL 可以根据需要进行扩展，支持分布式部署和读写分离读写等高级功能，以满足不同规模应用的需求。此外，MySQL 还是开源的，这意味着任何人都可以查看和修改其源代码，这使得 MySQL 拥有庞大的社区支持和丰富的插件资源。用户可以根据自己的需求进行定制和扩展，实现更灵活的功能。总的来说，MySQL 是一个功能强大、易用、可靠且高性能的关系型数据库管理系统，广泛应用于各种应用场景，是开发者和企业级应用的理想选择。","level":2},{"id":"/tags/databases/oracle#oracle","title":"Oracle","titles":[],"content":"Oracle 是全球最大的信息管理软件及服务供应商，总部位于美国加州 Redwood Shore。Oracle 公司（甲骨文）自 1977 年成立以来，始终致力于提供卓越的数据库解决方案和软件服务。Oracle 开发的关系数据库产品性能卓越，被广泛采用于财富排行榜上的前 1000 家公司以及众多大型网站，是世界最好的数据库产品之一。Oracle 的核心产品之一是 Oracle 数据库，它是一个关系型数据库管理系统，用于存储、管理和检索大量数据。此外，Oracle 还提供了基于云的数据库服务，提供灵活的数据库即服务（DBaaS）解决方案，以满足不同企业的需求。除了数据库产品，Oracle 还开发了一系列其他应用程序和软件，包括 Oracle EBusiness Suite（一套完整的企业资源规划（ERP）和客户关系管理（CRM）解决方案）以及 Oracle 中间件（如 Oracle WebLogic Server，一个用于构建、部署和管理企业级应用程序的 Java 应用服务器）。Oracle 系统以 Oracle 关系数据库为构架基础，构建出强大的数据库管理系统。该系统支持 SQL 语言，定位于高端工作站以及作为服务器的小型计算机，如 IBM P 系列服务器、HP 的 Integraty 服务器、Sun Fire 服务器等。Oracle 的数据库产品在集群技术、高可用性、商业智能、安全性、系统管理等方面都领跑业界。尤其在银行业，Oracle 数据库系统使用较多。此外，Oracle 的产品线还包括企业商务应用套件、应用开发和决策支持工具等，为企业提供了全面的信息化解决方案。值得一提的是，Oracle 公司的发展离不开其不断的技术创新和对市场需求的敏锐洞察。多年来，Oracle 通过发布多个版本的数据库产品，不断提升产品的性能、稳定性和可移植性，以满足不同行业的需求。然而，随着企业数据化程度的不断提高，Oracle 数据库工程师的需求量也在不断增加。由于 Oracle 数据库工程师的技能要求较高，需要具备丰富的经验和深厚的专业知识，因此目前市场上具备相应技能和经验的工程师数量不足，造成了人才缺口。总的来说，Oracle 作为全球领先的企业软件和数据库解决方案供应商，在数据库技术、应用软件以及云服务等方面都有着卓越的表现和广泛的应用。无论是大型企业还是中小企业，都可以通过采用 Oracle 的产品和服务，提升企业的信息化水平，实现更高效、更智能的数据管理和应用。","level":2},{"id":"/tags/databases/postgresql#postgresql","title":"PostgreSQL","titles":[],"content":"PostgreSQL 是一种特性非常齐全的自由软件的对象-关系型数据库管理系统（ORDBMS）。它最初是基于加州大学计算机系开发的 POSTGRES 4.2 版本进行设计的，并在此基础上进行了大量的改进和扩展。PostgreSQL 支持大部分的 SQL 标准，并提供了许多其他现代特性，如复杂查询、外键、触发器、视图、事务完整性以及多版本并发控制等。PostgreSQL 具有高度可定制性，可以根据应用程序的需求进行灵活调整和优化。其强大的并发控制能力确保即使在高并发的情况下，数据库也能提供高性能和可靠性。此外，PostgreSQL 还支持 ACID（原子性、一致性、隔离性、持久性）事务，保证了数据的完整性和一致性。在数据类型方面，PostgreSQL 支持基本数据类型（如整数、字符串、日期等）以及复杂数据类型（如数组、JSON、GIS 等），使得处理各种类型的数据变得轻松。此外，它还支持触发器，可以在数据插入、更新或删除时执行自定义的操作，实现复杂的业务逻辑。安全性是 PostgreSQL 的另一个重要特性。它提供了用户身份验证、数据加密和访问控制等安全措施，确保数据的安全性和保密性。此外，PostgreSQL 还具有很好的兼容性，可以与其他数据库系统进行方便的交互。值得一提的是，PostgreSQL 是一个开源项目，其许可证非常灵活，任何人都可以以任何目的免费使用、修改和分发。这使得 PostgreSQL 在全球范围内得到了广泛的应用，并赢得了很高的赞誉。无论是开发者还是机构，PostgreSQL 都成为了他们首选的开源关系数据库系统。总之，PostgreSQL 凭借其强大的功能、高度的可定制性、出色的并发控制能力以及丰富的数据类型支持等特点，成为了关系型数据库领域的佼佼者。","level":2},{"id":"/tags/databases/redis#redis","title":"Redis","titles":[],"content":"Redis（Remote Dictionary Server），即远程字典服务，是一个开源的使用 ANSI C 语言编写的、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。它支持存储的 value 类型相对更多，包括 string（字符串）、list（链表）、set（集合）、zset（sorted set --有序集合）和 hash（哈希类型）。这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。此外，Redis 还支持各种不同方式的排序。Redis 被广泛应用于缓存、消息队列、会话管理等场景，具有高性能、高可用性和可扩展性等特点。它主要基于内存操作，读写速度非常快，适合高并发场景。同时，Redis 支持数据持久化，可以将数据保存到磁盘上，以防止数据丢失。此外，Redis 还支持主从复制，可以将数据从一个 Redis 实例复制到多个 Redis 实例，以实现数据的备份和高可用性。在 Web Server 和数据库之间，Redis 常被用作缓存层，使 Web Server 能够直接从 Redis 中快速获取数据并返回，从而加快响应速度。例如，在电商领域，Redis 可以缓存热门商品的静态信息或用户数据，以应对大流量访问。此外，Redis 的持久化功能也使其可以作为数据库使用，将配置等全局数据加载到内存中，加快查询速度。总的来说，Redis 是一个功能强大、性能优越的 Key-Value 数据库，能够满足各种复杂的业务需求，提高系统的整体性能和稳定性。如需更多信息，建议查阅 Redis 的官方文档或相关教程。","level":2},{"id":"/tags/databases/sqlite#sqlite-是一款功能强大轻量级且易于使用的数据库系统适用于各种需要嵌入式或轻量级数据库支持的应用场景","title":"SQLite 是一款功能强大、轻量级且易于使用的数据库系统，适用于各种需要嵌入式或轻量级数据库支持的应用场景。","titles":[],"content":"SQLite 是一款轻型的数据库，遵守 ACID 的关系型数据库管理系统，它包含在一个相对小的 C 库中。这款数据库由 D.RichardHipp 建立，并作为公有领域项目发布。它的设计目标是嵌入式的，而且已经在很多嵌入式产品中得到了应用，其数据库引擎库只有几百 KB，因此可以非常方便地嵌入到其他应用程序中使用。SQLite 的主要特点包括：轻量级与简单易用 ：SQLite 的数据库引擎库只有几百 KB，设计非常简明扼要，具有精简的 API，因此易于学习和使用。   开源与免费 ：SQLite 在公共领域发布，可以免费使用。   健壮性 ：SQLite 在处理数据时非常稳健可靠，能够支持多种类型的数据，并且具有事务处理和数据完整性等关键特性。   跨平台 ：SQLite 支持各种操作系统，包括 Windows、Linux、Unix、Mac OS X 等，因此可以方便地在不同的平台之间移植和交换数据。SQLite 的数据库存储方式采用单个文件，没有固定的服务器进程。其通信协议主要是在编程语言内的直接 API 调用，这在消耗总量、延迟时间和整体简单性上有积极的作用。此外，SQLite 也支持多种开发语言，如 C、C++、PHP、Perl、Java、C#、Python、Ruby 等，并包含 TCL 绑定，同时通过 Wrapper 支持其他语言的绑定。在应用方面，SQLite 广泛应用于移动应用开发、桌面应用程序、Web 应用程序、数据分析、IoT(物联网)应用、测试和教育等领域。它是 Android 和 iOS 系统默认的数据库系统，用于存储移动应用的数据。同时，由于其轻量级和易用性，SQLite 也常被用于嵌入式开发和需要简单、快速数据库支持的场景。总的来说，SQLite 是一款功能强大、轻量级且易于使用的数据库系统，适用于各种需要嵌入式或轻量级数据库支持的应用场景。","level":2},{"id":"/tags/deploy/docker#docker","title":"Docker","titles":[],"content":"Docker 是一种容器化平台，用于构建、部署和运行应用程序。以下是 Docker 的一些关键特点：容器化技术 ：Docker 利用容器化技术，将应用程序及其依赖项打包到一个容器中，实现应用程序与其运行环境的隔离。   轻量级 ：Docker 容器相比传统虚拟机更轻量级，启动速度快，资源占用少，使得应用程序更易于部署和扩展。   跨平台 ：Docker 容器可以在任何支持 Docker 的平台上运行，保持应用程序在不同环境中的一致性。   镜像管理 ：Docker 使用镜像（Image）来构建容器，镜像可以通过 Docker Hub 等仓库共享和下载，方便应用程序的部署和分享。   容器编排 ：Docker 提供了 Docker Compose 和 Docker Swarm 等工具，用于管理多个容器的编排和集群部署。   微服务架构 ：Docker 容器适合用于构建微服务架构，每个微服务可以打包为一个独立的容器，实现服务的独立部署和扩展。   持续集成/持续部署 ：Docker 与 CI/CD 工具结合使用，实现持续集成和持续部署，加速应用程序的开发和交付过程。   安全性 ：Docker 提供了安全隔离机制，可以限制容器的资源访问权限，保护应用程序和数据的安全。总的来说，Docker 是一种强大且灵活的容器化平台，为开发者提供了便捷的应用程序打包、部署和管理工具，使得应用程序的开发、测试和部署更加高效和可靠。Docker 在现代应用开发和部署中扮演着重要的角色。","level":2},{"id":"/tags/deploy/github-actions#github-actions","title":"GitHub Actions","titles":[],"content":"GitHub Actions 是 GitHub 提供的自动化工具，它允许开发者直接在 GitHub 仓库中设置、定制和执行工作流程。这个工具可以用来自动化各种软件开发活动，如构建、测试、部署代码等，从而简化了开发、测试和部署过程。GitHub Actions 的核心功能包括：工作流程自动化 ：通过提供一个集中化的空间来创建、分享和重用工作流程，从而消除了复杂的外部 CI/CD 系统的需求。   大量预构建的操作(Actions)生态系统 ：提供了大量预构建的操作，开发者可以直接使用，也可以自定义创建 Actions。   跨平台兼容性 ：为多种编程语言和操作系统提供了跨平台兼容性，使得工作流程的创建和执行更加灵活和高效。   可定制性 ：通过变量、密钥和输入来实现工作流程的可定制性，满足不同的项目需求。GitHub Actions 的工作基于“工作流”，一个工作流可以由一个或多个“作业”组成，这些作业定义了一系列要执行的“步骤”。每个作业由一系列步骤组成，步骤可以执行命令或使用 Actions。工作流可以被 GitHub 仓库中的特定事件触发，如 push、pull request、issue 创建等。总的来说，GitHub Actions 是一个功能强大的自动化工具，能够极大地提升开发工作流程的效率和生产力。如需了解更多 GitHub Actions 的详细信息和使用方法，建议查阅 GitHub 官方文档或相关教程。","level":2},{"id":"/tags/deploy/k8s#kubernetes","title":"Kubernetes","titles":[],"content":"Kubernetes，简称 K8s，是一个开源的容器编排系统，由 Google 开发并于 2014 年发布。Kubernetes 的名字来源于希腊语，意为“舵手”或“领航员”，在系统中负责管理和自动化容器的部署、扩展和管理等操作。其目标是让部署容器化的应用变得简单并且高效。Kubernetes 的主要功能包括：数据卷管理：使得 Pod 中的容器之间可以共享数据。  应用程序健康检查：通过设置监控检查策略，保证应用的健壮性。  复制应用程序实例：控制器会维护 Pod 副本数量，确保一个或多个同类的 Pod 始终可用。  弹性伸缩：根据设定的指标（如 CPU 利用率）自动缩放 Pod 副本数。  服务发现：使用环境变量或 DNS 服务插件，保证容器中程序能够发现 Pod 的入口访问地址。  负载均衡：为一组 Pod 副本分配一个私有的 ClusterIP 地址，负载均衡转发请求到后端容器。  滚动更新：更新服务时无需中断，一次更新一个 Pod，而不是同时删除整个服务。  自我修复：在节点故障时重新启动失败的容器，替换和重新部署，保证预期的副本数量。Kubernetes 集群由多个节点组成，每个节点都可以运行容器。节点可以是物理服务器、虚拟服务器或云服务器。集群可以在多个数据中心或云提供商之间分布，以实现高可用性和弹性。Kubernetes 还提供了丰富的 API 和可扩展性，使得用户可以根据自己的需求定制和扩展其功能。同时，它也支持多种存储和网络解决方案，能够轻松地与其他系统和工具集成。总的来说，Kubernetes 是一个功能强大、灵活且易于使用的容器编排系统，它使得容器化应用的部署、管理和扩展变得更加简单和高效，是云原生应用的标准解决方案。","level":2},{"id":"/tags/deploy/vercel#vercel","title":"Vercel","titles":[],"content":"Vercel 是一个云平台，专为构建、部署和扩展无服务器应用程序和静态网站而设计。由于其易用性、出色的速度以及处理大量流量的能力，它在开发人员中越来越受欢迎。以下是关于 Vercel 的详细介绍：自动化部署 ：Vercel 能够与版本控制系统（如 Git）集成，实现自动化部署项目。每当代码有新的提交时，Vercel 会自动构建和部署应用程序，大大降低了部署过程中的人工错误和时间浪费。   Serverless 架构 ：Vercel 提供了无服务器（Serverless）功能，允许开发者轻松构建和部署无服务器函数和 API，无需关心服务器的维护和扩展。这有助于开发者创建高度可伸缩和高性能的应用程序。   零配置部署 ：Vercel 使项目部署到全球分布的 CDN（内容分发网络）变得轻而易举，无需繁琐的配置。这确保了应用在世界各地的用户都能获得快速和可靠的访问。   自动缩放 ：根据流量的变化，Vercel 能够自动调整资源，确保应用程序始终保持良好的性能。   自定义域名与 SSL ：Vercel 提供了强大的域名管理功能，用户可以将自己的域名与 Vercel 集成，使应用程序在自定义域名下运行。此外，Vercel 还自动为应用程序提供免费的 SSL 证书，确保应用程序在安全的连接下运行。   预渲染和服务器渲染支持 ：Vercel 不仅支持静态网站的预渲染，以提供更快的页面加载速度，还支持服务器渲染（SSR）框架，如 Next.js。   灰度部署和 A/B 测试 ：Vercel 允许开发者将新功能部署到一小部分用户，进行灰度测试或 A/B 测试，从而评估其性能和用户体验。   团队协作 ：Vercel 支持团队协作开发应用程序，使得多人协作更加便捷。   免费层次 ：Vercel 提供了免费层次的服务，允许开发者在没有额外成本的情况下体验其服务。   监控和分析 ：Vercel 提供了应用程序的监控和分析工具，帮助开发者深入了解应用程序的性能和用户行为，及时发现和解决问题。值得一提的是，Vercel 在开发和推广 Jamstack 架构方面发挥了重要作用。Jamstack 强调静态站点生成和无服务器功能，以构建快速安全的 Web 应用程序。此外，Vercel 还是流行的 Next.js 框架背后的公司，这是一个基于 React 的框架，用于构建服务器渲染的应用程序。总的来说，Vercel 是一个功能丰富、易于使用的云平台，适合前端开发人员构建、部署和扩展现代 Web 应用程序。无论是个人项目还是大型企业应用，Vercel 都能提供灵活且强大的解决方案。","level":2},{"id":"/tags/frontend/angularjs#angularjs","title":"AngularJS","titles":[],"content":"AngularJS 是一个诞生于 2009 年的前端框架，由 Misko Hevery 等人创建，后被 Google 收购。它是为了克服 HTML 在构建应用上的不足而设计的，通过扩展 HTML 的语法和添加新的属性，使得开发者能够更方便地构建复杂的单页面应用（SPAs）。AngularJS 的主要特性包括：双向数据绑定 ：AngularJS 实现了数据模型和视图之间的双向数据同步。当数据模型发生变化时，视图会自动更新；反之，当视图发生变化时，数据模型也会自动更新。   模块化 ：AngularJS 采用模块化的设计，将应用程序拆分成多个模块，每个模块负责不同的功能，有助于代码的清晰和结构的合理。   依赖注入 ：AngularJS 使用依赖注入的方式来管理组件之间的依赖关系，这有助于开发者提高代码质量和可维护性。   MVVM 模式 ：AngularJS 采用了 MVVM（Model-View-ViewModel）模式，有助于将视图与数据模型进行分离，提高代码的可读性和可维护性。   语义化标签和指令 ：AngularJS 允许开发者使用自定义的指令来扩展 HTML 的功能，同时支持语义化标签，使得代码更易于理解和维护。AngularJS 在构建 CRUD（增加、查询、更新、删除）应用时表现出色，它提供了一系列工具和功能，包括数据绑定、表单验证、路由、组件重用等，使得开发者能够更高效地构建 Web 应用。此外，AngularJS 还有丰富的在线教程和社区资源，为开发者提供了良好的学习和支持环境。总的来说，AngularJS 是一个功能强大、灵活且易于使用的前端框架，适用于构建各种复杂的单页面应用。","level":2},{"id":"/tags/frontend/animate-css#animatecss","title":"Animate.css","titles":[],"content":"Animate.css 是一个轻量级的 CSS 动画库，专门用于在网页上添加各种动画效果。它提供了一组预先定义好的动画类，通过简单地将这些类应用到 HTML 元素上，即可实现各种动态效果，无需编写复杂的 JavaScript 或 CSS 动画代码。以下是对 Animate.css 的详细介绍：","level":2},{"id":"/tags/frontend/animate-css#主要特点和功能","title":"主要特点和功能","titles":["Animate.css"],"content":"预定义的动画效果 ：\nAnimate.css 包含了多种预定义的 CSS 动画效果，涵盖了常见的入场（进入）和出场（退出）动画，以及其他一些特效，如旋转、抖动、弹跳等。   轻量级和易用性 ：\nAnimate.css 的文件大小较小，易于集成到现有的网页项目中。用户只需将需要的动画类应用到 HTML 元素上，即可快速实现动画效果，无需深入学习复杂的动画技术。   跨浏览器兼容性 ：\nAnimate.css 经过广泛测试，能够在主流的现代浏览器（如 Chrome、Firefox、Safari、Edge 等）中良好运行，保证了动画效果的一致性和稳定性。   自定义和扩展性 ：\n尽管 Animate.css 提供了一组标准的动画效果，但用户仍可以通过修改现有的动画类或者添加自定义的 CSS 规则，来实现个性化的动画效果。   适用于响应式设计 ：\nAnimate.css 的动画效果可以根据屏幕大小和设备类型进行调整和响应，使其在不同设备上都能呈现出优美的动态效果。","level":3},{"id":"/tags/frontend/animate-css#使用方法","title":"使用方法","titles":["Animate.css"],"content":"引入 Animate.css 文件 ：\n在 HTML 文件中通过链接引入 Animate.css 文件，可以从官方网站直接下载或通过 CDN 获取：     应用动画类 ：\n在需要添加动画效果的 HTML 元素上，添加相应的 Animate.css 类即可。例如，要为一个元素添加淡入动画效果，可以添加类名   ：     触发动画 ：\nAnimate.css 的动画效果默认会在元素加载时自动触发。用户也可以通过 JavaScript 或添加特定的 CSS 类来手动触发或控制动画的开始和结束。","level":3},{"id":"/tags/frontend/animate-css#示例动画效果","title":"示例动画效果","titles":["Animate.css"],"content":"Animate.css 提供了多种动画效果，以下是几个示例：：淡入动画效果，使元素逐渐显示。   ：弹跳效果，使元素以弹簧的方式反复弹跳。   ：旋转进入效果，使元素旋转并逐渐显示。   ：向左滑出效果，使元素向左侧滑动并消失。","level":3},{"id":"/tags/frontend/animate-css#总结","title":"总结","titles":["Animate.css"],"content":"Animate.css 是一个简单易用的 CSS 动画库，为网页设计师和开发者提供了丰富的动画效果，能够快速增添页面的视觉吸引力和交互性。通过 Animate.css，用户可以轻松地实现各种动态效果，改善用户体验，使网页内容更加生动和引人注目。","level":3},{"id":"/tags/frontend/axios#axios","title":"Axios","titles":[],"content":"Axios 是一个基于 Promise 的 HTTP 客户端，用于在浏览器和 Node.js 中发送 HTTP 请求。它的设计简单且易于使用，能够处理多种类型的请求和响应。以下是一些关于 Axios 的关键特性和使用方法：","level":2},{"id":"/tags/frontend/axios#关键特性","title":"关键特性","titles":["Axios"],"content":"支持所有的请求类型 ：GET、POST、PUT、DELETE、PATCH 等。   自动转换 JSON 数据 ：Axios 会自动将响应数据转换为 JSON 格式。   拦截请求和响应 ：允许在请求或响应被处理之前拦截它们。   取消请求 ：使用取消令牌来取消请求。   支持并发请求 ：可以使用    来处理并发请求。   请求和响应的转换 ：允许在请求发送到服务器之前或收到响应之后对其进行转换。   防止 CSRF ：可以方便地配置和发送 CSRF 令牌。","level":3},{"id":"/tags/frontend/axios#安装","title":"安装","titles":["Axios"],"content":"在项目中使用 Axios，可以通过 npm 或 yarn 安装：或者","level":3},{"id":"/tags/frontend/axios#基本用法","title":"基本用法","titles":["Axios"],"content":"以下是一些基本的用法示例：","level":3},{"id":"/tags/frontend/axios#发送-get-请求","title":"发送 GET 请求","titles":["Axios","基本用法"],"content":"","level":4},{"id":"/tags/frontend/axios#发送-post-请求","title":"发送 POST 请求","titles":["Axios","基本用法"],"content":"","level":4},{"id":"/tags/frontend/axios#设置请求头","title":"设置请求头","titles":["Axios","基本用法"],"content":"","level":4},{"id":"/tags/frontend/axios#拦截请求和响应","title":"拦截请求和响应","titles":["Axios","基本用法"],"content":"","level":4},{"id":"/tags/frontend/axios#并发请求","title":"并发请求","titles":["Axios","基本用法"],"content":"","level":3},{"id":"/tags/frontend/axios#取消请求","title":"取消请求","titles":["Axios","基本用法"],"content":"","level":3},{"id":"/tags/frontend/axios#总结","title":"总结","titles":["Axios","基本用法"],"content":"Axios 提供了简洁而强大的 API，使得发送 HTTP 请求和处理响应变得非常容易。无论是在前端还是在后端开发中，Axios 都是一个非常有用的工具。","level":3},{"id":"/tags/frontend/css#css","title":"CSS","titles":[],"content":"CSS（Cascading Style Sheets）是用于描述文档样式和布局的样式表语言，用于控制网页的外观和样式。CSS 定义了各种属性和值，用于设置元素的样式，如颜色、字体、间距、边框等。CSS3 是 CSS 的第三个主要版本，引入了许多新的特性和功能，使得开发者能够实现更丰富、更复杂的样式效果。以下是 CSS3 相对于 CSS 的一些主要改进和新增功能：圆角边框 ：CSS3 引入了  属性，可以实现圆角边框效果，而在 CSS 中需要使用背景图片来实现。   阴影效果 ：CSS3 引入了  属性，可以实现元素的阴影效果，而在 CSS 中通常需要使用背景图片来模拟。   渐变背景 ：CSS3 引入了  和  属性，可以实现元素的渐变背景效果，而在 CSS 中通常需要使用背景图片。   多列布局 ：CSS3 引入了多列布局属性，可以实现元素的多列文本布局，而在 CSS 中通常需要使用浮动或表格布局。   动画效果 ：CSS3 引入了  规则和  属性，可以实现元素的动画效果，而在 CSS 中通常需要使用 JavaScript。   媒体查询 ：CSS3 引入了媒体查询（Media Queries），可以根据设备的特性和屏幕尺寸应用不同的样式，实现响应式设计。总的来说，CSS3 相对于 CSS 具有更多的新特性和功能，使得开发者能够实现更加丰富、现代化的样式效果，提升了网页设计的灵活性和创造力。","level":2},{"id":"/tags/frontend/d3js#d3js","title":"D3.js","titles":[],"content":"D3.js 是一个强大的 JavaScript 数据可视化库，提供了丰富的 API 和工具，用于创建交互式的数据图表、地图等可视化效果。它的核心理念是将数据绑定到 DOM 元素上，并使用数据驱动的方式来更新元素的样式、位置和属性。D3.js 的特点主要体现在以下几个方面：灵活性 ：D3.js 提供了大量的 API 和工具，允许开发者自定义可视化效果，满足不同的需求。它支持 SVG、Canvas 等绘图技术，使得开发者可以创建出丰富多样的数据可视化作品。   交互性 ：D3.js 提供了丰富的交互功能，如鼠标事件、动画效果、提示框等，增强了用户体验和数据展示效果。这些交互功能使得数据可视化不仅仅是静态的展示，而是可以与用户进行互动的、生动的表现。   社区活跃 ：D3.js 拥有庞大的用户群体和活跃的社区，这意味着开发者可以方便地获取文档、示例和支持。当遇到问题时，可以在社区中寻求帮助，也可以从其他开发者的经验和作品中获得灵感。   丰富的可视化元素库 ：D3.js 提供了丰富的可视化元素库，如图表、地图和网络图等，使得开发者可以快速创建各种类型的数据可视化作品。无论是折线图、柱状图还是饼图，D3.js 都能轻松应对。在实际应用中，D3.js 广泛应用于 Web 数据可视化领域。开发者可以将需要展示的数据准备好，然后使用 D3.js 将数据绑定到 DOM 元素上，并通过数据驱动的方式来更新元素的样式和位置。这样，就可以创建出各种类型的数据图表和地图，直观地展示数据的分布和趋势。此外，D3.js 还可以与其他前端框架和库集成，如 React、Angular、Vue 等，提供更丰富的可视化效果和交互功能。这使得开发者可以在熟悉的开发环境中使用 D3.js，提高开发效率。总之，D3.js 是一个功能强大、灵活且社区活跃的 JavaScript 数据可视化库，它可以帮助开发者创建出丰富多样的数据可视化作品，提升数据的展示效果和用户体验。","level":2},{"id":"/tags/frontend/dayjs#dayjs","title":"Day.js","titles":[],"content":"Day.js 是一个轻量级的 JavaScript 库，用于解析、验证、操作和显示日期和时间。它的 API 设计与 Moment.js 十分相似，但其大小仅为 2KB（gzip 压缩后），因此在性能和包大小方面具有明显优势。Day.js 是一个现代替代方案，适合那些需要高性能和小体积日期处理库的项目。","level":2},{"id":"/tags/frontend/dayjs#安装-dayjs","title":"安装 Day.js","titles":["Day.js"],"content":"","level":3},{"id":"/tags/frontend/dayjs#使用-npm-安装","title":"使用 npm 安装","titles":["Day.js","安装 Day.js"],"content":"","level":4},{"id":"/tags/frontend/dayjs#使用-yarn-安装","title":"使用 yarn 安装","titles":["Day.js","安装 Day.js"],"content":"","level":4},{"id":"/tags/frontend/dayjs#在浏览器中使用","title":"在浏览器中使用","titles":["Day.js","安装 Day.js"],"content":"通过 CDN 引入 Day.js：","level":4},{"id":"/tags/frontend/dayjs#基本用法","title":"基本用法","titles":["Day.js","安装 Day.js"],"content":"","level":3},{"id":"/tags/frontend/dayjs#导入-dayjs","title":"导入 Day.js","titles":["Day.js","安装 Day.js","基本用法"],"content":"在 Node.js 或使用模块化的前端项目中，可以这样导入 Day.js：","level":4},{"id":"/tags/frontend/dayjs#创建日期对象","title":"创建日期对象","titles":["Day.js","安装 Day.js","基本用法"],"content":"使用 Day.js 创建日期对象非常简单，可以使用当前日期、指定日期字符串、时间戳等多种方式创建。","level":4},{"id":"/tags/frontend/dayjs#格式化日期","title":"格式化日期","titles":["Day.js","安装 Day.js","基本用法"],"content":"Day.js 提供了    方法将日期对象格式化为指定的字符串格式。","level":4},{"id":"/tags/frontend/dayjs#解析日期","title":"解析日期","titles":["Day.js","安装 Day.js","基本用法"],"content":"Day.js 可以解析多种格式的日期字符串，并将其转换为日期对象。","level":4},{"id":"/tags/frontend/dayjs#操作日期","title":"操作日期","titles":["Day.js","安装 Day.js","基本用法"],"content":"Day.js 提供了许多方法来操作日期对象，例如加减天数、月数、年数等。","level":4},{"id":"/tags/frontend/dayjs#比较日期","title":"比较日期","titles":["Day.js","安装 Day.js","基本用法"],"content":"Day.js 提供了多种比较日期的方法，可以方便地进行日期比较。","level":4},{"id":"/tags/frontend/dayjs#插件支持","title":"插件支持","titles":["Day.js","安装 Day.js"],"content":"Day.js 的核心非常小巧，但是可以通过插件来扩展其功能。常用插件包括时区支持、相对时间、ISO 8601 解析等。","level":3},{"id":"/tags/frontend/dayjs#安装插件","title":"安装插件","titles":["Day.js","安装 Day.js","插件支持"],"content":"例如安装相对时间插件：","level":4},{"id":"/tags/frontend/dayjs#使用插件","title":"使用插件","titles":["Day.js","安装 Day.js","插件支持"],"content":"使用插件时需要先加载并扩展 Day.js：","level":4},{"id":"/tags/frontend/dayjs#常用功能示例","title":"常用功能示例","titles":["Day.js","安装 Day.js"],"content":"","level":3},{"id":"/tags/frontend/dayjs#计算日期间隔","title":"计算日期间隔","titles":["Day.js","安装 Day.js","常用功能示例"],"content":"计算两个日期之间的间隔天数、月数或年数。","level":4},{"id":"/tags/frontend/dayjs#转换日期格式","title":"转换日期格式","titles":["Day.js","安装 Day.js","常用功能示例"],"content":"将日期字符串从一种格式转换为另一种格式。","level":4},{"id":"/tags/frontend/dayjs#获取相对时间","title":"获取相对时间","titles":["Day.js","安装 Day.js","常用功能示例"],"content":"获取相对时间描述，例如 “2 天前” 或 “刚刚”。","level":4},{"id":"/tags/frontend/dayjs#处理时区","title":"处理时区","titles":["Day.js","安装 Day.js","常用功能示例"],"content":"使用 Day.js 处理时区需要引入    插件和    插件：然后在代码中使用：","level":4},{"id":"/tags/frontend/dayjs#总结","title":"总结","titles":["Day.js","安装 Day.js"],"content":"Day.js 是一个轻量级、高性能的日期处理库，其 API 与 Moment.js 类似，便于迁移和使用。通过丰富的插件支持，Day.js 可以灵活地扩展功能，以满足各种日期和时间处理需求。如果你正在寻找一个小体积、快速的日期处理库，Day.js 是一个值得考虑的选择。","level":3},{"id":"/tags/frontend/electron#electron","title":"Electron","titles":[],"content":"Electron 是一个使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序框架。它具有以下主要特点：跨平台性 ：Electron 允许开发者使用 Web 技术（如 HTML、CSS 和 JavaScript）构建跨平台的桌面应用程序，这些应用程序可以支持 Windows、Mac 和 Linux 操作系统。   开源与免费 ：Electron 是一个开源项目，开发者可以免费使用并在 Github 上查看其源代码。   功能强大 ：Electron 提供了丰富的 API 和工具，包括文件系统、网络通信、原生窗口、系统对话框等，这些功能使得开发者能够构建出具有各种复杂功能的桌面应用程序。   易用性 ：Electron 使用 Node.js 运行时环境，这使得开发者可以轻松地使用 npm 包管理工具和常见的 Web 开发工具来构建应用程序。   社区支持 ：Electron 拥有庞大的开发者社区，这个社区提供了丰富的文档和资源，可以帮助开发者更好地学习和解决开发过程中遇到的问题。此外，Electron 还有一些技术亮点，如增加了对 ESM（ECMAScript 模块）的支持，Chromium 和 V8 引擎的更新，以及对原生能力的跨平台支持等。这些功能进一步提升了 Electron 的实用性和性能。Electron 的历史可以追溯到 Atom Shell 项目，该项目最初是为了构建 GitHub 上的可编程文本编辑器 Atom 而开发的。随后，Atom Shell 被重命名为 Electron，并得到了广泛的关注和采用。总的来说，Electron 是一个功能强大、易用且具有广泛社区支持的跨平台桌面应用程序框架，它使得开发者能够使用 Web 技术构建出具有丰富功能和优秀性能的桌面应用程序。","level":2},{"id":"/tags/frontend/eslint#eslint","title":"ESLint","titles":[],"content":"ESLint 是一个开源的 JavaScript 代码检查工具，它的目标是提供一个插件化的 JavaScript 代码检测工具，以发现并修复 JavaScript 代码中的问题。ESLint 的主要作用包括统一代码风格规则，如缩进空格数、变量和函数名的命名方式等；减少错误，如规定必须使用  进行相等比较，变量在使用前必须被声明等；提高代码质量，例如设定函数条件分支、参数和代码块嵌套的最大数量等；以及其他一些功能，如禁用  以提高用户体验。ESLint 的特点包括默认规则包含所有 JSLint、JSHint 中存在的规则，易于迁移；规则可配置性高，可以设置“警告”或“错误”两个错误等级，或者直接禁用；包含代码风格检测的规则；支持插件扩展和自定义规则。使用 ESLint 时，首先需要进行全局安装，然后生成配置文件  ，并根据规则文档编辑该文件以进行自定义配置。总的来说，ESLint 是一个强大而灵活的代码检查工具，它能够帮助开发者发现并修复代码中的问题，统一代码风格，提高代码质量，从而提升开发效率和代码的可维护性。","level":2},{"id":"/tags/frontend/iconify#iconify","title":"Iconify","titles":[],"content":"Iconify 是一个全面的图标解决方案，它提供了一个庞大的图标库，并支持多种前端框架和语言。这个图标集和图标管理工具旨在简化开发者在项目中引入和管理图标的流程，通过轻量级的 API 和模块化的设计，为现代 Web 应用带来高效且可定制的图标体验。Iconify 包含数以万计的高质量 SVG 图标，这些图标来自于多个知名图标集，如 Material Design Icons、Font Awesome 等。所有图标都已转换为 JSON 格式，方便快速加载和渲染。它支持多种格式（如 SVG、PNG、React、Vue 等）的图标，并提供了简单易用的 API 和插件，使图标的添加和管理变得更加便捷。用户可以根据自己的需求搜索和选择需要的图标，然后将其集成到自己的项目中使用。Iconify 不仅支持通过 HTTP 请求获取需要的图标数据，还提供了 CDN 服务，允许开发者直接在 HTML 中引用图标，无需额外安装或下载资源。此外，Iconify 还提供了一个在线生成器，允许用户根据需求自定义 SVG 图标的颜色、大小和样式，生成个性化图标代码，便于在项目中直接使用。在开发体验方面，Iconify 通过内联显示图标、Hover 预览以及代码片段功能，使代码文件更加专业且易于理解。其智能提示功能可以在输入相应的图标名时立即提供，帮助开发者快速选择并插入图标。而预览效果功能则允许开发者在鼠标悬停在图标代码上时查看，无需离开当前编辑环境就能检查图标是否符合预期。Iconify 的轻量级设计使其只加载需要的图标，减少不必要的资源占用，而高性能则基于 SVG，支持响应式设计，保证在不同设备上的清晰度。此外，它还具备灵活性，支持自定义颜色、尺寸、旋转等 CSS 属性，并且图标库不断更新，确保用户能够获取最新、最流行的图标。总的来说，Iconify 是一个功能强大、灵活且易于使用的图标解决方案，无论是对于需要快速集成图标到项目的开发者，还是对于追求高度定制化的设计师，都是一个理想的选择。","level":2},{"id":"/tags/frontend/jquery#jquery","title":"jQuery","titles":[],"content":"jQuery 是一个快速、小巧、功能丰富的 JavaScript 库，它极大简化了 HTML 文档遍历和操作、事件处理、动画效果以及 Ajax 交互。自 2006 年由 John Resig 创建以来，jQuery 已成为最流行的 JavaScript 库之一，被广泛应用于各种 web 开发项目中。以下是对 jQuery 的详细介绍：","level":2},{"id":"/tags/frontend/jquery#主要特点和功能","title":"主要特点和功能","titles":["jQuery"],"content":"DOM 操作 ：\njQuery 提供了简单而强大的方法来选择和操作 DOM 元素。它支持 CSS 选择器，允许开发人员轻松地查找和操作网页中的元素。     事件处理 ：\njQuery 提供了跨浏览器的事件处理方法，简化了事件绑定和事件处理。     Ajax 支持 ：\njQuery 提供了简洁的 Ajax 方法，方便与服务器进行异步通信，加载数据并更新网页内容。     动画和效果 ：\njQuery 提供了丰富的动画效果和方法，使得网页动画变得简单。     插件扩展 ：\njQuery 的插件机制允许开发人员创建可重用的代码模块，并扩展 jQuery 的功能。社区中有大量的 jQuery 插件可供使用。   跨浏览器兼容 ：\njQuery 处理了很多浏览器兼容性问题，使得代码可以在不同浏览器中一致运行。","level":3},{"id":"/tags/frontend/jquery#使用方法","title":"使用方法","titles":["jQuery"],"content":"引入 jQuery ：\n可以通过下载 jQuery 库并在 HTML 文件中引用，或者直接使用 CDN 引用。     基本用法 ：\njQuery 使用    符号作为简写，代表 jQuery 对象。通过这个对象，可以访问 jQuery 的各种方法和功能。","level":3},{"id":"/tags/frontend/jquery#常用操作示例","title":"常用操作示例","titles":["jQuery"],"content":"DOM 操作 ：     事件处理 ：     Ajax 请求 ：     动画效果 ：","level":3},{"id":"/tags/frontend/jquery#总结","title":"总结","titles":["jQuery"],"content":"jQuery 作为一个功能强大且易于使用的 JavaScript 库，通过简化 DOM 操作、事件处理、Ajax 请求和动画效果，大大提升了前端开发的效率和便捷性。尽管随着现代 JavaScript 和前端框架（如 React、Vue.js 和 Angular）的发展，jQuery 的使用逐渐减少，但它依然是许多项目中的重要工具，并在维护遗留代码和简单项目中发挥着关键作用。","level":3},{"id":"/tags/frontend/momentjs#momentjs","title":"Moment.js","titles":[],"content":"Moment.js 是一个强大的 JavaScript 库，用于解析、验证、操作和显示日期和时间。它提供了丰富的 API，使得日期和时间处理变得简单和直观。尽管 Moment.js 已经宣布进入维护模式，并建议使用替代库（如 Luxon 或 date-fns），它仍然在许多项目中广泛使用。以下是对 Moment.js 的详细介绍，包括其安装、基本用法和一些常见功能。","level":2},{"id":"/tags/frontend/momentjs#安装-momentjs","title":"安装 Moment.js","titles":["Moment.js"],"content":"","level":3},{"id":"/tags/frontend/momentjs#使用-npm-安装","title":"使用 npm 安装","titles":["Moment.js","安装 Moment.js"],"content":"","level":4},{"id":"/tags/frontend/momentjs#使用-yarn-安装","title":"使用 yarn 安装","titles":["Moment.js","安装 Moment.js"],"content":"","level":4},{"id":"/tags/frontend/momentjs#在浏览器中使用","title":"在浏览器中使用","titles":["Moment.js","安装 Moment.js"],"content":"通过 CDN 引入 Moment.js：","level":4},{"id":"/tags/frontend/momentjs#基本用法","title":"基本用法","titles":["Moment.js","安装 Moment.js"],"content":"","level":3},{"id":"/tags/frontend/momentjs#导入-momentjs","title":"导入 Moment.js","titles":["Moment.js","安装 Moment.js","基本用法"],"content":"在 Node.js 或使用模块化的前端项目中，可以这样导入 Moment.js：","level":4},{"id":"/tags/frontend/momentjs#创建日期对象","title":"创建日期对象","titles":["Moment.js","安装 Moment.js","基本用法"],"content":"使用 Moment.js 创建日期对象非常简单，可以使用当前日期、指定日期字符串、时间戳等多种方式创建。","level":4},{"id":"/tags/frontend/momentjs#格式化日期","title":"格式化日期","titles":["Moment.js","安装 Moment.js","基本用法"],"content":"Moment.js 提供了丰富的格式化选项，可以使用    方法将日期对象格式化为指定的字符串格式。","level":4},{"id":"/tags/frontend/momentjs#解析日期","title":"解析日期","titles":["Moment.js","安装 Moment.js","基本用法"],"content":"Moment.js 可以解析多种格式的日期字符串，并将其转换为日期对象。","level":4},{"id":"/tags/frontend/momentjs#操作日期","title":"操作日期","titles":["Moment.js","安装 Moment.js","基本用法"],"content":"Moment.js 提供了许多方法来操作日期对象，例如加减天数、月数、年数等。","level":4},{"id":"/tags/frontend/momentjs#比较日期","title":"比较日期","titles":["Moment.js","安装 Moment.js","基本用法"],"content":"Moment.js 提供了多种比较日期的方法，可以方便地进行日期比较。","level":4},{"id":"/tags/frontend/momentjs#处理时区","title":"处理时区","titles":["Moment.js","安装 Moment.js","基本用法"],"content":"Moment.js 还有一个扩展库   ，可以方便地处理时区。使用   ：","level":4},{"id":"/tags/frontend/momentjs#常用功能示例","title":"常用功能示例","titles":["Moment.js","安装 Moment.js"],"content":"","level":3},{"id":"/tags/frontend/momentjs#计算日期间隔","title":"计算日期间隔","titles":["Moment.js","安装 Moment.js","常用功能示例"],"content":"计算两个日期之间的间隔天数、月数或年数。","level":4},{"id":"/tags/frontend/momentjs#转换日期格式","title":"转换日期格式","titles":["Moment.js","安装 Moment.js","常用功能示例"],"content":"将日期字符串从一种格式转换为另一种格式。","level":4},{"id":"/tags/frontend/momentjs#获取相对时间","title":"获取相对时间","titles":["Moment.js","安装 Moment.js","常用功能示例"],"content":"获取相对时间描述，例如 “2 天前” 或 “刚刚”。","level":4},{"id":"/tags/frontend/momentjs#总结","title":"总结","titles":["Moment.js","安装 Moment.js"],"content":"Moment.js 是一个功能强大的日期处理库，虽然它已经进入维护模式，但其丰富的功能和简单的 API 仍然使它在许多项目中被广泛使用。通过本文介绍的安装方法、基本用法和常用功能示例，你可以轻松地在你的项目中集成和使用 Moment.js 来处理各种日期和时间需求。考虑到 Moment.js 的维护状态，如果你正在开始一个新项目，可能会考虑使用更现代的替代库如 Luxon 或 date-fns。","level":3},{"id":"/tags/frontend/nestjs#nestjs","title":"NestJS","titles":[],"content":"NestJS 是一个基于 TypeScript 和 Node.js 的后端框架，主要用于构建可维护且高效的服务器端应用程序。以下是 NestJS 的详细介绍：模块化架构 ：NestJS 采用了模块化的设计，将应用程序分割成多个可重用的模块。这种结构不仅使得代码的组织结构更加清晰，便于团队协作，还支持快速开发和测试。每个模块都可以独立开发、测试和维护，从而大大提高了代码的可扩展性和可维护性。   强大的依赖注入 ：NestJS 内置了依赖注入容器，这使得开发者可以轻松管理应用程序的各个组件之间的依赖关系。依赖注入不仅提高了代码的可测试性和可重用性，还使得代码更加灵活和易于维护。   支持多种服务器端技术 ：NestJS 可以与多种服务器端技术（如 Express、Fastify 等）无缝集成，这使得开发者可以根据自己的项目需求选择适合的技术栈。   TypeScript 支持 ：NestJS 主要使用 TypeScript 作为编程语言，这意味着开发者可以利用静态类型检查、强大的代码智能感知和更好的代码质量控制。同时，NestJS 也允许开发者使用纯 JavaScript 进行开发，从而提供了更大的灵活性。   高性能 I/O 处理 ：由于 Node.js 采用异步非阻塞 I/O 模型，NestJS 特别适合构建高并发、I/O 密集型应用，例如 API 服务、实时通信系统等。   前后端同构 ：对于使用 JavaScript 构建前端应用的团队来说，NestJS 可以实现前后端语言统一，便于共享代码和知识转移。此外，NestJS 还提供了一个开箱即用的应用程序体系结构，允许开发者及其团队创建高度可测试、可扩展、松散耦合且易于维护的应用程序。同时，它支持函数式编程和函数响应式编程，为开发者提供了更多的编程范式选择。总的来说，NestJS 是一个功能强大、灵活且易于使用的后端框架，适用于各种规模和复杂度的 Web 应用程序开发。无论是初创企业还是大型团队，NestJS 都能提供稳定、高效和可扩展的开发体验。","level":2},{"id":"/tags/frontend/nodejs#nodejs","title":"Nodejs","titles":[],"content":"Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，用于构建高性能的网络应用程序。以下是 Node.js 的一些关键特点：基于 JavaScript ：Node.js 使用 JavaScript 作为开发语言，使得前端开发者可以利用其熟悉的技能进行后端开发。   事件驱动 ：Node.js 基于事件驱动和非阻塞 I/O 模型，可以处理大量并发请求，提高应用程序的性能和响应速度。   单线程 ：Node.js 采用单线程模型，但通过事件循环和异步操作，可以实现高效的并发处理，避免了传统多线程编程的复杂性。   模块化 ：Node.js 支持模块化开发，可以通过   npm （Node Package Manager）安装和管理各种第三方模块，提高开发效率。   跨平台 ：Node.js 可以在多个操作系统上运行，包括 Windows、Linux、macOS 等，为开发者提供了跨平台的开发环境。   构建网络应用 ：Node.js 适用于构建各种网络应用，如 Web 服务器、API 服务器、实时通讯应用等，具有良好的性能表现。   后端开发 ：Node.js 可以用于构建后端服务和 RESTful API，与前端框架（如 React、Angular）配合使用，实现全栈开发。   社区支持 ：Node.js 拥有庞大的开发者社区和丰富的第三方库，为开发者提供了丰富的资源和支持。总的来说，Node.js 是一个强大且灵活的后端开发工具，通过其事件驱动、非阻塞 I/O 和模块化等特性，使得开发者能够构建高性能、可扩展的网络应用程序，并在前后端开发中实现更好的协作和一致性。Node.js 在现代 Web 开发中扮演着重要的角色。","level":2},{"id":"/tags/frontend/npm#npm","title":"npm","titles":[],"content":"npm（Node Package Manager）是 Node.js 的包管理工具，用于安装、管理和发布 JavaScript 包和依赖项。以下是 npm 的一些关键特点：包管理 ：npm 允许开发者从 npm 仓库中安装和管理各种 JavaScript 包和模块，包括工具库、框架、插件等。   依赖解析 ：npm 能够自动解析和安装项目所需的依赖项，构建项目时可以根据  文件中的依赖列表自动安装依赖。   版本管理 ：npm 允许开发者指定所需包的版本范围，可以使用语义化版本控制（Semantic Versioning）来管理包的版本。   脚本执行 ：npm 提供了  字段，可以在  中定义各种自定义脚本命令，如构建、测试、部署等。   全局安装 ：npm 允许将包全局安装，使得安装的包可以在命令行中直接调用，如构建工具、命令行工具等。   包发布 ：开发者可以使用 npm 将自己开发的包发布到 npm 仓库，供其他开发者使用和共享。   私有仓库 ：npm 还提供了私有仓库的功能，允许企业或个人在私有环境中管理和发布自己的包。   生态系统 ：npm 拥有庞大的生态系统，包含了数以千计的开源 JavaScript 包和工具，为开发者提供了丰富的资源和支持。总的来说，    是一个强大且广泛使用的 JavaScript 包管理工具，为开发者提供了便捷的包管理、依赖解析和脚本执行功能，是现代 JavaScript 开发中不可或缺的工具之一。","level":2},{"id":"/tags/frontend/nuxtjs#nuxt","title":"Nuxt","titles":[],"content":"Nuxtjs 是一个基于 Vue.js 的通用应用框架，用于快速构建现代化的 Web 应用程序。以下是 Nuxtjs 的一些关键特点：基于 Vue.js ：Nuxt.js 建立在 Vue.js 之上，提供了许多额外的功能和工具，使得 Vue.js 应用程序的开发更加高效和便捷。   服务端渲染 ：Nuxt.js 支持服务端渲染（SSR），可以在服务器端生成页面，提高首屏加载速度和 SEO 优化。   静态站点生成 ：Nuxt.js 支持静态站点生成（SSG），可以将 Vue.js 应用程序预渲染为静态 HTML 文件，提高性能和安全性。   自动路由 ：Nuxt.js 提供了自动生成路由的功能，根据项目目录结构自动创建路由配置，简化路由管理。   插件系统 ：Nuxt.js 具有丰富的插件系统，可以轻松集成第三方库和工具，扩展应用程序的功能。   模块化 ：Nuxt.js 采用模块化的方式组织代码，可以通过添加模块来扩展应用程序的功能，如 PWA、Axios 等。   一体化构建工具 ：Nuxt.js 集成了 Webpack、Babel 等构建工具，提供了现代化的开发环境和工作流程。   丰富的文档和社区 ：Nuxt.js 拥有完善的文档和活跃的社区，为开发者提供了丰富的资源和支持。总的来说，Nuxt.js 是一个功能强大且灵活的 Vue.js 应用框架，适用于构建各种类型的 Web 应用程序，包括单页面应用（SPA）、多页面应用（MPA）、静态站点等。其服务端渲染和静态站点生成功能使得开发者能够快速构建高性能、SEO 友好的 Web 应用。","level":2},{"id":"/tags/frontend/p5js#p5js","title":"p5js","titles":[],"content":"p5.js 是一个开源的 JavaScript 库，旨在通过简化 HTML5 Canvas 的操作，帮助艺术家、设计师、教育者和初学者更轻松地创建图形、交互和动画作品。p5.js 是 Processing 项目的 JavaScript 版本，它继承了 Processing 易于使用的理念，使得编程艺术和创意编码变得更加直观和有趣。","level":2},{"id":"/tags/frontend/p5js#主要特点和功能","title":"主要特点和功能","titles":["p5js"],"content":"简化的图形绘制 ：\np5.js 提供了一组易于使用的函数，用于绘制基本的图形和形状，如线条、矩形、椭圆、弧形等。它隐藏了复杂的 Canvas API，使得绘图变得简单。     丰富的交互功能 ：\np5.js 提供了大量的事件处理函数，使得处理用户交互（如鼠标、键盘）变得容易。     动画和实时更新 ：\n使用    和    函数，可以轻松创建动画。   函数会被连续调用，从而更新画面。     支持多媒体 ：\np5.js 支持加载和操作图像、视频、音频等多媒体内容，适用于创意多媒体项目。     扩展和插件 ：\np5.js 拥有大量的插件和扩展库，如 p5.sound、p5.dom 等，提供了更多的功能和特性。","level":3},{"id":"/tags/frontend/p5js#使用方法","title":"使用方法","titles":["p5js"],"content":"引入 p5.js ：\n可以通过 HTML 文件中的    标签引入 p5.js：     基本结构 ：\np5.js 程序通常包含    和    两个主要函数：    ：在程序开始时运行一次，用于初始化设置。   ：连续运行，用于绘制和更新画面。","level":3},{"id":"/tags/frontend/p5js#常用功能示例","title":"常用功能示例","titles":["p5js"],"content":"绘制基本形状 ：     处理用户输入 ：     加载和显示图像 ：","level":3},{"id":"/tags/frontend/p5js#总结","title":"总结","titles":["p5js"],"content":"p5.js 是一个强大且易于使用的 JavaScript 库，专为创意编程和艺术项目设计。它简化了图形绘制、交互处理和动画制作，使得即使是编程初学者也能快速上手并创作出丰富多彩的作品。通过其广泛的功能和社区支持，p5.js 成为创意编码领域的重要工具。","level":3},{"id":"/tags/frontend/pandacss#pandacss","title":"PandaCSS","titles":[],"content":"PandaCSS 是一个优秀的 CSS-in-JS 编译时框架，旨在简化样式管理并提供更好的开发体验。相比其他类似框架，PandaCSS 的配置更加简单，智能提示优秀，开发者体验也更好。同时，PandaCSS 吸收了许多 TailwindCSS 的优点，允许开发者自由配置主题与样式，其原子化的类名也使得自由组合更为便捷。PandaCSS 的设计灵感来源于可爱的熊猫，采用了一种简单的语法，使得开发人员能够以一种更直观和自然的方式编写样式。这使得 PandaCSS 成为写 UI 库的理想选择，并支持同步主题和类型安全样式以及自动完成功能。此外，PandaCSS 文档中也提到了其支持的框架，如 Next.js 等，这进一步展示了其广泛的应用场景和兼容性。同时，PandaCSS 还处理生成的 CSS 内容的去重，确保样式管理的高效性。总的来说，PandaCSS 是一个功能强大、易用且高效的 CSS-in-JS 框架，适合各种前端开发需求，特别是需要高效管理样式和提高开发体验的场景。","level":2},{"id":"/tags/frontend/pnpm#pnpm","title":"Pnpm","titles":[],"content":"Pnpm 是一种快速、高效且磁盘空间友好的包管理工具。它通过共享依赖来减少磁盘空间占用，并通过硬链接来加快安装速度。其特点主要包括：速度快 ：使用硬链接技术将依赖包直接链接到项目中，避免了复制文件所带来的性能损耗，同时也支持并行安装多个依赖包，从而大大提高了安装速度。   节约磁盘空间 ：由于共享依赖，不同项目之间可以共享相同版本的依赖包，大大减少了磁盘空间占用。   安全可靠 ：使用了类似于 npm 的安全机制，确保依赖包的完整性和安全性。   易于使用 ：提供了简洁的安装、卸载和使用文档，方便用户快速上手。","level":2},{"id":"/tags/frontend/postcss#postcss","title":"PostCSS","titles":[],"content":"PostCSS 是一款强大的 CSS 处理器，它的核心在于提供了一个平台，允许开发者通过插件来扩展 CSS 的功能。与传统的 CSS 预处理器（如 Sass 和 Less）不同，PostCSS 本身并不具备变量、嵌套、混合等功能，但它的插件系统使得这些功能都可以被添加进来。PostCSS 的工作原理主要是基于抽象语法树（AST）。它首先将 CSS 代码解析成 AST，然后允许开发者通过插件对 AST 进行修改和转换，最后再将修改后的 AST 重新生成 CSS 代码。这种机制使得 PostCSS 能够支持各种复杂的 CSS 转换操作，从而实现更高级的 CSS 功能。PostCSS 的插件生态系统是其核心优势之一。例如，Autoprefixer 插件可以自动将浏览器前缀添加到需要它们的 CSS 属性中；cssnano 插件可以用于压缩 CSS 代码；PreCSS 插件则支持 Sass/Less-like 语法等功能。开发者可以根据自己的项目需求选择合适的插件，或者编写自定义插件以满足特定需求。PostCSS 的灵活性和可扩展性是其另一个显著特点。由于它的功能完全依赖于插件实现，因此开发者可以根据自己的需求选择或编写插件，从而大大减少重复的代码量并提高开发效率。总的来说，PostCSS 是一个功能强大、灵活且可扩展的 CSS 处理器，适用于各种项目和团队。它提供了丰富的插件生态系统，使得开发者能够轻松地对 CSS 进行各种转换和优化操作，以满足不同的需求。","level":2},{"id":"/tags/frontend/prettier#prettier","title":"Prettier","titles":[],"content":"Prettier 是一个代码格式化工具，旨在通过解析代码并使用自己的规则来重新打印代码，以达到一致的代码风格。它的主要目标是减少开发人员在代码样式上的分歧，使代码更加整洁和易于阅读。Prettier 的主要特点如下：自动格式化 ：Prettier 能够自动调整代码的布局和格式，包括缩进、空格、换行符等，使其符合预设的样式规则。   配置简单 ：Prettier 的配置相对简单，通常通过    文件或    文件中的    字段进行配置。它提供了一系列可配置的选项，允许用户根据项目的需求定制代码样式。   集成方便 ：Prettier 提供了与多种编辑器和构建工具的集成，如 VS Code、WebStorm、ESLint 等。这意味着开发者可以在编写代码时实时查看格式化后的效果，并在保存文件时自动应用格式化规则。   与 ESLint 协同工作 ：虽然 Prettier 主要关注代码样式的格式化，而 ESLint 主要关注代码质量和错误检查，但两者可以协同工作。Prettier 可以作为 ESLint 的一个插件使用，确保在代码质量检查之前先进行格式化。   强大的社区支持 ：Prettier 拥有庞大的社区支持，不断有新的插件和配置选项被开发出来，以满足不同项目的需求。此外，Prettier 的文档和教程也非常丰富，方便开发者快速上手和深入了解。使用 Prettier 可以带来以下好处：统一的代码风格 ：通过强制应用一致的代码样式规则，Prettier 可以确保项目中的代码风格统一，提高代码的可读性和可维护性。   减少手动调整 ：开发者无需手动调整代码样式，可以专注于实现功能，提高开发效率。   易于协作 ：一致的代码风格使得团队成员之间的协作更加顺畅，减少了因代码样式不同而引起的冲突。总之，Prettier 是一个强大而灵活的代码格式化工具，它能够帮助开发者快速、方便地实现一致的代码风格，提高代码质量和开发效率。","level":2},{"id":"/tags/frontend/react#react","title":"React","titles":[],"content":"React 是一个用于构建用户界面的 JavaScript 库，起源于 Facebook 的内部项目。该项目最初是为了解决 Facebook 对市场上所有 JavaScript MVC 框架的不满，并用于架设 Instagram 的网站。React 于 2011 年首次亮相，首次用于 Facebook 的 Newsfeed，并在次年应用于 Instagram。最终在 2013 年 5 月，React 在美国 JSConf 大会上正式开源。React 的核心思想是将用户界面拆分成独立的组件，每个组件具有自己的状态和属性。这种组件化的开发方式使得代码更加模块化和可重用，同时也更易于维护和测试。React 还使用了虚拟 DOM 技术来优化页面渲染性能，通过与实际 DOM 进行比较来确定需要更新的部分，从而只更新实际 DOM 中的变化部分，减少了不必要的 DOM 操作，提高了性能。React 主要用于构建 UI，它允许在应用中传递多种类型的参数，如声明式代码，这些代码可以帮助开发者渲染出 UI，也可以传递静态的 HTML DOM 元素、动态变量，甚至是可交互的应用组件。React 还使用单向数据流来管理组件之间的数据传递，使得组件之间的关系更加清晰可控，便于跟踪和调试。React 的生态系统也非常庞大，随着 Redux、React Router 等社区项目的出现，React 的应用场景得到了极大的扩展。此外，React 团队还不断对框架进行改进和更新，如引入 Fiber 架构和 Hooks 等特性，使得 React 在性能、开发体验以及新特性引入等方面都保持了领先地位。React 的应用场景非常广泛，它可以用于构建单页面应用、多页面应用，也可以将静态网站转变为动态网站。由于其强大的功能和灵活的架构，React 已经成为了前端开发领域的重要工具之一。总的来说，React 是一个功能强大、灵活且易于使用的 JavaScript 库，适用于构建各种复杂的用户界面。如需更多信息，建议查阅 React 的官方文档或相关教程。","level":2},{"id":"/tags/frontend/tailwindcss#tailwind-css","title":"Tailwind CSS","titles":[],"content":"Tailwind CSS 是一个实用的 CSS 框架，它提供了一组预定义的样式类，可以帮助开发者快速构建现代化的网页界面。以下是 Tailwind CSS 的一些关键特点：原子类 ：Tailwind CSS 采用原子类的方式，每个类都代表一个具体的样式属性，如  、  ，使得样式定义更直观和灵活。   定制化 ：Tailwind CSS 允许开发者通过配置文件自定义颜色、字体、间距等样式属性，定制化程度高。   响应式设计 ：Tailwind CSS 提供了一套响应式设计的类，可以根据不同的屏幕尺寸应用不同的样式，实现页面的自适应布局。   工具类 ：Tailwind CSS 提供了丰富的工具类，如文本样式、背景样式、边框样式等，可以快速实现各种样式效果。   易于学习 ：Tailwind CSS 的类名基本上都是直观的，开发者无需记忆复杂的类名，只需根据需要选择合适的类即可。   性能优化 ：Tailwind CSS 通过 PurgeCSS 等工具可以自动删除未使用的样式，减小 CSS 文件大小，提升性能。   社区支持 ：Tailwind CSS 拥有活跃的社区和文档，提供了丰富的资源和教程，方便开发者学习和使用。总的来说，Tailwind CSS 是一个功能强大且易于定制的 CSS 框架，适用于快速构建现代化的网页界面。它的原子类和响应式设计特性使得开发者能够快速实现各种样式效果，提高开发效率。","level":2},{"id":"/tags/frontend/vite#vite","title":"Vite","titles":[],"content":"Vite 是一款面向现代浏览器的轻量级、快速的前端开发工具。其核心基于 ECMAScript 标准原生模块系统（ES Modules）实现，提供了全新的开发体验。Vite 的主要特性是 Bundleless，即按需加载。当某个模块被 import 时，Vite 会动态地加载它，这种机制减少了加载文件的体积，缩短了加载时长，从而实现了真正的按需加载。Vite 由 Vue.js 框架的创建者 Evan You 创建，因此，它对 Vue 项目具有特别的友好性。不过，这并不意味着 Vite 只能用于 Vue 项目，它同样可以很好地支持其他前端框架和库。在开发环境中，Vite 运行一个服务器，通过 ES 模块动态编译和提供任何所需的依赖项。这种方法使得 Vite 在服务器启动和代码更新期间需要处理的代码量大大减少，从而实现了超快的启动时间和热模块更换。相比其他工具如 webpack、Rollup 或 Parcel，Vite 的启动时间可以减少十倍。总的来说，Vite 是一款非常现代化的前端开发工具，它的快速和轻量级特性使得前端开发变得更加高效和便捷。无论是对于新手还是经验丰富的开发者，Vite 都提供了出色的开发体验和工具集，是现代前端开发的理想选择。","level":2},{"id":"/tags/frontend/vue#vue","title":"Vue","titles":[],"content":"Vuejs 是一款流行的 JavaScript 框架，用于构建用户界面和单页面应用程序。以下是 Vuejs 的一些关键特点：响应式数据绑定 ：Vue.js 采用双向数据绑定机制，使得数据的变化能够自动反映在视图上，简化了开发过程。   组件化开发 ：Vue.js 鼓励组件化开发，将页面拆分为多个独立可复用的组件，提高了代码的可维护性和复用性。   虚拟 DOM ：Vue.js 使用虚拟 DOM 技术，通过比较虚拟 DOM 树的差异来高效更新真实 DOM，提升性能。   指令 ：Vue.js 提供丰富的指令，如  、  、  等，用于简化 DOM 操作和数据绑定。   过渡和动画 ：Vue.js 内置了过渡和动画系统，可以轻松实现页面元素的动画效果。   路由管理 ：Vue.js 配备了 Vue Router 插件，用于实现前端路由管理，支持路由嵌套、动态路由等功能。   状态管理 ：Vue.js 提供了 Vuex 插件，用于集中管理应用的状态，实现组件间的状态共享。总的来说，Vue.js 是一款灵活、高效的前端框架，适用于构建现代化的交互式 Web 应用程序。其简洁的 API 设计和丰富的生态系统使得开发者能够快速构建功能丰富、响应迅速的 Web 应用。","level":2},{"id":"/tags/frontend/vueuse#vueuse","title":"VueUse","titles":[],"content":"是一个网站，提供了 Vue.js 生态系统中常用的一些功能性函数和组合的集合，旨在帮助开发者更高效地构建 Vue.js 应用程序。https://vueuse.org该网站提供了各种常用的 Vue.js 功能性函数和组合，如状态管理、副作用处理、DOM 操作、表单处理、路由管理等，以及一些常见的工具函数和实用组合，帮助开发者简化开发流程，提高开发效率。通过  ，开发者可以查阅文档、示例代码和使用说明，了解如何使用这些功能性函数和组合，以及如何在 Vue.js 应用中集成和应用它们，从而加速开发过程，提升代码质量和可维护性。","level":2},{"id":"/tags/frontend/yarn#yarn","title":"Yarn","titles":[],"content":"","level":2},{"id":"/tags/frontend/yarn#介绍","title":"介绍 ：","titles":["Yarn"],"content":"Yarn 是另一种资源协调者，也是一种高效的包管理工具。其特点包括：速度超快 ：Yarn 缓存了每个下载过的包，因此再次使用时无需重复下载。同时，它利用并行下载以最大化资源利用率，使得安装速度更快。   超级安全 ：在执行代码之前，Yarn 会通过算法校验每个安装包的完整性，确保包的安全性。   超级可靠 ：使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异地工作。Pnpm 和 Yarn 都是针对传统包管理工具（如 npm）在安装和更新依赖包时面临的性能和磁盘空间挑战而设计的优化工具。它们都在不同的方面提供了改进，使得包管理更加高效、快速和安全。在选择使用哪个工具时，可以根据项目的具体需求和个人偏好进行决定。","level":3},{"id":"/tags/langs/csharp#c","title":"C#","titles":[],"content":"C#（C Sharp）是由微软开发的一种面向对象的编程语言，主要用于开发 Windows 应用程序、Web 应用程序和游戏开发。以下是 C#的一些关键特点：面向对象 ：C#是一种面向对象的编程语言，支持类、对象、继承、多态等面向对象的特性，使得代码结构清晰和易于维护。   类型安全 ：C#是一种类型安全的语言，编译器会在编译时检查类型错误，提高代码的可靠性和稳定性。   托管代码 ：C#运行在.NET Framework 或.NET Core 等托管环境中，提供了垃圾回收、异常处理等功能，简化了内存管理和资源释放。   跨平台开发 ：随着.NET Core 的推出，C#可以用于跨平台开发，支持在 Windows、Linux 和 macOS 等操作系统上运行。   丰富的库和框架 ：C#拥有丰富的类库和框架，如.NET Framework、ASP.NET、Unity 等，提供了丰富的功能和工具支持。   异步编程 ：C#提供了异步编程模型，通过 async 和 await 关键字实现异步操作，提高程序的性能和响应性。   LINQ ：C#引入了语言集成查询（LINQ）功能，使得数据查询和操作更加简洁和灵活。   Windows 应用开发 ：C#是开发 Windows 桌面应用程序的首选语言，支持 Windows Forms 和 WPF 等框架。   Web 开发 ：C#可以用于开发 Web 应用程序，如 ASP.NET 框架提供了强大的 Web 开发功能。总的来说，C#是一种功能强大且灵活的编程语言，适用于各种类型的应用开发，包括桌面应用、Web 应用、游戏开发等。其丰富的特性和工具使得开发者能够快速构建高质量的应用程序，并在不同平台上实现应用程序的部署和运行。","level":2},{"id":"/tags/langs/dart#dart","title":"Dart","titles":[],"content":"Dart 是一种编程语言，具有广泛的应用场景，包括 Web 开发、移动应用开发、桌面应用开发以及服务器端开发等。在 Web 开发中，Dart 常与 Flutter 框架结合使用，以实现高效、快速且跨平台的开发体验。在移动应用开发领域，Dart 尤其受欢迎，其性能优势和简洁的语法使得开发者能够更轻松地构建高质量的移动应用。Dart 语言具有强类型编程的特性，一旦确定类型，则不可改变变量类型，编译时会进行语法检查。尽管如此，它也允许弱类型语言式的编程，如果需要明确说明不需要任何类型，可以使用特殊类型 dynamic。Dart 还支持泛型，如 List（整数列表）或 List（任何类型的对象列表）。此外，Dart 语言也提供了一些特殊的功能和用法。例如，Dart 没有关键字 public、protected 和 private，如果标识符以下划线(_)开头，则它相对于库是私有的。这使得代码的组织和管理更为灵活和方便。在工具和应用方面，Dart 具有丰富的库和框架支持，如用于构建 Web 服务器的 Aqueduct 和 Shelf 库。同时，学习 Dart 也往往与 Flutter 框架的学习紧密结合，因为 Flutter 使用 Dart 作为其主要的编程语言。因此，对于想要学习 Dart 的开发者来说，掌握 Flutter 也是非常重要的一部分。总的来说，Dart 是一种功能强大且灵活的编程语言，适用于各种应用场景。无论是构建高效的 Web 应用，还是开发跨平台的移动应用，Dart 都能提供优秀的解决方案。","level":2},{"id":"/tags/langs/golang#go","title":"Go","titles":[],"content":"Go ，通常称为   Golang ，是一门由 Google 开发的开源编程语言。Go 的设计目标是提供一种简单、快速、高效的编程体验，特别适合构建并发、高性能的系统软件。以下是 Go 语言的主要特点和应用场景的详细介绍：","level":2},{"id":"/tags/langs/golang#主要特点","title":"主要特点","titles":["Go"],"content":"简洁和易学 ：Go 的语法简单直观，减少了语言特性的复杂性，使得开发者可以快速上手和编写清晰的代码。   高效和性能优越 ：Go 具有优秀的编译速度和执行效率，通过并发模型（goroutine）和原生支持的并发编程来实现高效的并发处理。   并发支持 ：Go 内置了轻量级的 goroutine 和通道（channel），简化了并发编程，使得开发者可以更容易地编写并发和并行程序。   内置工具支持 ：Go 工具链包含了代码格式化、依赖管理、测试等工具，使得开发流程更加统一和高效。   静态类型和类型推导 ：Go 是一种静态类型语言，但也支持类型推导（type inference），减少了类型声明的繁琐性，提高了代码的可读性和简洁性。   跨平台支持 ：Go 支持多种操作系统，包括 Linux、Windows、Mac OS 等，可以在不同平台上进行开发和部署。   内存管理 ：Go 具有自动垃圾回收（Garbage Collection），减少了开发者对内存管理的手动干预，提高了程序的健壮性和稳定性。   丰富的标准库 ：Go 提供了丰富的标准库，涵盖了网络通信、文本处理、加密解密、图像处理等多个领域，支持快速开发和扩展。","level":3},{"id":"/tags/langs/golang#应用场景","title":"应用场景","titles":["Go"],"content":"后端服务和微服务 ：Go 由于其并发模型和高性能特性，适合构建后端服务、API 服务和微服务架构，如 Docker 和 Kubernetes 的部分组件就是使用 Go 编写的。   网络应用和服务器端开发 ：Go 可以用于构建高并发的网络应用和服务器，如 Web 应用、HTTP 服务等。   系统工具和命令行应用 ：由于编译速度快、执行效率高，Go 适合用于开发系统工具和命令行应用程序。   分布式系统和云平台 ：Go 在分布式系统和云平台开发中具有广泛应用，如处理分布式任务、大规模数据处理等。   网络通信和高性能数据处理 ：Go 的并发模型和性能优势使其成为处理大规模数据、高性能网络通信的理想选择。   游戏开发和嵌入式系统 ：Go 也可以用于游戏开发领域和嵌入式系统中，支持快速开发和高效运行。","level":3},{"id":"/tags/langs/golang#发展与社区","title":"发展与社区","titles":["Go"],"content":"2007 年 ：Go 的设计开始于 Google，随后于   2009 年  首次公开发布。   至今 ：Go 在开发社区中有着活跃的支持和发展，不断推出新的版本和改进，吸引了越来越多的开发者。","level":3},{"id":"/tags/langs/golang#总结","title":"总结","titles":["Go"],"content":"Go 是一门现代化、高效的编程语言，以其简洁的语法、强大的并发模型和优秀的性能特性而受到广泛欢迎。它适用于构建各种类型的应用程序，从网络服务到分布式系统，从云平台到嵌入式系统，都展示了其在不同领域的灵活和强大。对于追求高效、简洁和高性能的开发者来说，Go 是一个极具吸引力的选择。","level":3},{"id":"/tags/langs/java#java","title":"Java","titles":[],"content":"Java 是一种面向对象的编程语言，由 Sun Microsystems 的 James Gosling 等人于 1995 年推出。Java 具有跨平台、简单、稳定、安全等特性，在全球范围内得到了广泛应用。以下是对 Java 的详细介绍：","level":2},{"id":"/tags/langs/java#_1-跨平台性","title":"1. 跨平台性","titles":["Java"],"content":"Java 的最大特点之一是其跨平台能力，通常称为“编写一次，到处运行”（Write Once, Run Anywhere，简称 WORA）。这得益于 Java 虚拟机（Java Virtual Machine，JVM），它将 Java 编译后的字节码（bytecode）转换为特定平台上的机器码，从而实现了跨平台运行。","level":3},{"id":"/tags/langs/java#_2-面向对象","title":"2. 面向对象","titles":["Java"],"content":"Java 是一种纯粹的面向对象编程语言，强调对象的概念和重用。主要的面向对象特性包括：封装（Encapsulation）：  将数据和行为封装在对象中，保护数据不被外界随意修改。   继承（Inheritance）：  通过继承机制，实现代码重用和扩展。   多态（Polymorphism）：  同一操作在不同对象上的不同表现。","level":3},{"id":"/tags/langs/java#_3-简单和易用","title":"3. 简单和易用","titles":["Java"],"content":"Java 摒弃了 C++ 中复杂的特性（如指针、多重继承等），并提供了丰富的标准库（Java Standard Library），使得开发人员可以专注于业务逻辑而不是底层实现。","level":3},{"id":"/tags/langs/java#_4-安全性","title":"4. 安全性","titles":["Java"],"content":"Java 在设计时考虑了安全性，特别是在网络环境中的应用。Java 提供了多层次的安全机制，包括字节码验证、类加载器和安全管理器。","level":3},{"id":"/tags/langs/java#_5-高性能","title":"5. 高性能","titles":["Java"],"content":"尽管 Java 是解释执行的语言，但通过即时编译技术（Just-In-Time Compilation，JIT），Java 的运行性能得到了极大的提升。此外，Java 也支持多线程编程，能够充分利用多核处理器的性能。","level":3},{"id":"/tags/langs/java#_6-丰富的标准库","title":"6. 丰富的标准库","titles":["Java"],"content":"Java 提供了丰富的标准库，涵盖了数据结构、算法、网络编程、数据库连接、图形用户界面等各个方面。这些库极大地方便了开发人员的工作，提高了开发效率。","level":3},{"id":"/tags/langs/java#_7-应用领域","title":"7. 应用领域","titles":["Java"],"content":"Java 广泛应用于各种软件开发领域，包括但不限于：企业级应用：  如 Java EE（Java Enterprise Edition）用于构建大型企业级应用。   移动应用：  如 Android 应用开发主要使用 Java 语言。   Web 应用：  使用 Java 的 Spring、Struts 等框架开发动态 Web 应用。   大数据处理：  如 Hadoop、Apache Spark 等大数据框架使用 Java 开发。   嵌入式系统：  Java 也用于一些嵌入式系统的开发。","level":3},{"id":"/tags/langs/java#_8-生态系统","title":"8. 生态系统","titles":["Java"],"content":"Java 拥有庞大的生态系统和活跃的社区。开源框架和工具如 Spring、Hibernate、Apache Maven、Gradle 等极大地丰富了 Java 的功能，促进了 Java 的发展。","level":3},{"id":"/tags/langs/java#_9-发展历史","title":"9. 发展历史","titles":["Java"],"content":"1995 年：  Java 1.0 发布。   1998 年：  Java 2 (J2SE 1.2) 发布，引入了 Swing 库、集合框架等。   2004 年：  Java 5.0 发布，引入了泛型、增强型 for 循环等重要特性。   2011 年：  Oracle 收购 Sun Microsystems 后，发布了 Java 7。   2014 年：  Java 8 发布，引入了 Lambda 表达式、Stream API 等现代特性。   2017 年及以后：  Java 9、10、11 等版本陆续发布，引入了模块化系统、局部变量类型推断等特性。","level":3},{"id":"/tags/langs/java#总结","title":"总结","titles":["Java"],"content":"Java 作为一种成熟的编程语言，凭借其跨平台、面向对象、简单、安全、高性能等优点，成为了许多开发者的首选工具。无论是在企业级开发、移动开发、Web 开发还是大数据处理领域，Java 都发挥着重要作用。","level":3},{"id":"/tags/langs/js#javascript","title":"Javascript","titles":[],"content":"JavaScript 是一种高级的、解释型的编程语言，用于在网页上实现交互式的功能和动态效果。以下是 JavaScript 的一些关键特点：客户端脚本语言 ：JavaScript 通常在浏览器中运行，用于处理用户交互、动态内容更新和页面行为控制。   跨平台 ：JavaScript 是一种跨平台的语言，可以在各种操作系统和设备上运行，包括桌面、移动设备和服务器端。   动态类型 ：JavaScript 是一种动态类型语言，变量的类型在运行时确定，使得开发更加灵活和简洁。   事件驱动 ：JavaScript 基于事件驱动模型，可以响应用户的操作和页面事件，实现交互式的用户体验。   DOM 操作 ：JavaScript 可以操作文档对象模型（DOM），实现对页面元素的增删改查，动态更新页面内容。   函数式编程 ：JavaScript 支持函数式编程范式，函数是一等公民，可以作为参数传递和返回值，使得代码更具表现力和灵活性。   第三方库和框架 ：JavaScript 拥有丰富的第三方库和框架，如 React、Vue.js、Angular 等，用于简化开发、提高效率和扩展功能。   异步编程 ：JavaScript 通过回调函数、Promise、async/await 等机制实现异步编程，处理网络请求、定时任务等操作。总的来说，JavaScript 是一种强大且灵活的编程语言，广泛应用于 Web 开发、移动应用开发、游戏开发等领域。其动态特性、事件驱动模型和丰富的生态系统使得 JavaScript 成为现代 Web 开发中不可或缺的一部分。","level":2},{"id":"/tags/langs/python#python","title":"Python","titles":[],"content":"Python  是一种高级编程语言，于 1991 年由 Guido van Rossum 创造并开源发布。Python 设计简洁、易读且功能强大，广泛用于软件开发、数据分析、人工智能、科学计算、Web 开发等领域。以下是 Python 的主要特点和应用场景的详细介绍：","level":2},{"id":"/tags/langs/python#主要特点","title":"主要特点","titles":["Python"],"content":"简单易学 ：Python 设计优雅，语法简洁清晰，使得初学者能够快速上手，同时也适合专业开发人员进行复杂项目的开发。   高级语言 ：Python 提供了丰富的高级数据结构，支持面向对象、函数式和结构化编程风格，使得代码更易于理解和维护。   跨平台 ：Python 可以在几乎所有主流操作系统上运行，包括 Windows、Linux、Mac OS 等，具有良好的跨平台性。   开源和社区支持 ：Python 是开源的，拥有庞大的社区支持和活跃的开发者社区，提供了丰富的第三方库和工具，可以扩展其功能。   动态类型和自动内存管理 ：Python 是动态类型语言，具有自动内存管理机制（垃圾回收），减少了开发者的工作量和错误的可能性。   丰富的标准库 ：Python 内置了大量的标准库，涵盖了文件操作、网络通信、数据处理、GUI 开发等多个领域，可以快速构建各种应用。   支持多种编程范式 ：Python 支持面向对象编程（OOP）、函数式编程（FP）、命令式编程等多种编程范式，灵活适应不同的开发需求。   广泛的应用领域 ：Python 在软件开发、Web 开发（如 Django、Flask）、数据科学（如 NumPy、Pandas）、人工智能（如 TensorFlow、PyTorch）、自动化测试、游戏开发等领域都有广泛的应用。","level":3},{"id":"/tags/langs/python#应用场景","title":"应用场景","titles":["Python"],"content":"Web 开发 ：Python 的 Web 框架（如 Django、Flask）使其成为构建高效、稳定的 Web 应用和 API 的理想选择。   数据科学和人工智能 ：Python 在数据分析（如 Pandas、Matplotlib）、机器学习（如 Scikit-learn）、深度学习（如 TensorFlow、PyTorch）等领域占据重要地位。   科学计算和数值计算 ：Python 提供了丰富的科学计算库（如 NumPy、SciPy），支持复杂的数学计算和模拟。   自动化和脚本编写 ：由于语法简洁和易读性，Python 在自动化脚本编写、系统管理和任务调度中广泛应用。   游戏开发 ：Python 在游戏开发中用于编写游戏逻辑、工具开发和游戏引擎的扩展。   教育和培训 ：Python 作为一门容易学习的语言，被广泛应用于学术教育和编程培训。","level":3},{"id":"/tags/langs/python#总结","title":"总结","titles":["Python"],"content":"Python 作为一种简洁、高效、易学的编程语言，具有广泛的应用领域和强大的社区支持，在软件开发、数据科学、人工智能等多个领域都有重要的地位。其简单的语法结构和丰富的生态系统，使得 Python 成为开发者首选的编程语言之一，推动了各种创新和技术进步。","level":3},{"id":"/tags/langs/regex#regex","title":"Regex","titles":[],"content":"Regex，全称 Regular Expression，中文称为正则表达式，是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”）。它是计算机科学的一个概念，用于对字符串操作的一种逻辑公式，即用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串，通常被用来检索、替换那些符合某个模式（规则）的文本。正则表达式在文本处理中发挥着重要的作用，包括模式匹配、数据验证、文本提取等多种任务。例如，它可以用于搜索文本中的特定模式，如电子邮件地址、URL、电话号码或日期；也可以用于验证输入数据，确保用户的输入遵循特定格式；还可以用于从文本中提取特定信息，如从字符串中提取所有数字或解析 CSV 文件等结构化数据。正则表达式在不同的编程语言中有着不同的实现方式，但基本上都支持各种元字符和修饰符来创建复杂的模式匹配规则。通过学习和掌握正则表达式的语法和用法，可以大大提高文本处理的效率和准确性。请注意，正则表达式的具体语法和用法可能因编程语言和上下文的不同而有所差异。因此，在使用正则表达式时，建议查阅相关编程语言的文档或参考资源，以了解具体的语法规则和用法示例。下面分别展示了如何在 C#、JavaScript 和 Dart 中使用正则表达式（Regex）进行字符串匹配和替换的示例代码。C#  在 C# 中，正则表达式通过    命名空间中的    类来使用。     JavaScript  在 JavaScript 中，正则表达式通过    对象或直接使用正则表达式字面量来使用。     Dart  在 Dart 中，正则表达式通过    类来使用。这三个例子展示了如何在不同的编程语言中使用正则表达式来检查字符串匹配、查找匹配项以及进行替换操作。","level":2},{"id":"/tags/langs/sql#sql","title":"SQL","titles":[],"content":"SQL，全称 Structured Query Language，即结构化查询语言，是用于与关系数据库进行通信的标准语言。SQL 是关系数据库管理系统的核心，用于执行各种数据库操作，如数据定义、数据查询、数据更新、数据删除等。SQL 语言具有如下特点：综合统一 ：SQL 能够处理数据库的定义、操作和控制，这意味着可以使用同一种语言来创建表结构、插入、查询、更新数据，以及设置访问权限和安全性控制。   高度非过程化 ：用户只需提出“做什么”，而无需指明“怎么做”，便可得到所需的信息。   面向集合的操作方式 ：SQL 采用集合操作方式，不仅查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合。   语言简洁，易学易用 ：SQL 功能强大，但语言简洁，语法简单，好学好用。   数据统计方便直观 ：SQL 提供了丰富的聚合函数，使得数据的统计和汇总变得方便和直观。SQL 语句主要可以分为数据操作语言（DML）和数据定义语言（DDL）两大类。DML 用于查询和修改数据，包括 SELECT、INSERT、UPDATE 和 DELETE 等语句；DDL 则用于定义或改变表结构，如 CREATE、ALTER 和 DROP 等语句。SQL 语言广泛应用于各种关系数据库管理系统，如 Microsoft SQL Server、MySQL、PostgreSQL、MariaDB 和 Oracle 等。","level":2},{"id":"/tags/langs/ts#typescript","title":"TypeScript","titles":[],"content":"TypeScript 是一种由微软开发的编程语言，它是 JavaScript 的一个超集，并添加了静态类型、类、接口和模块等特性。TypeScript 代码在编译时会转换为纯 JavaScript 代码，这样它就可以在任何支持 JavaScript 的环境中运行，比如浏览器或 Node.js。TypeScript 的主要优势包括：静态类型 ：TypeScript 允许你为变量、函数参数和返回值指定类型，这样编译器可以在编译时捕获类型错误，从而减少了运行时错误的可能性。   强大的 IDE 支持 ：由于 TypeScript 的静态类型特性，它能够与现代的集成开发环境（IDE）和代码编辑器无缝集成，提供诸如自动补全、类型检查、重构等强大的功能。   面向对象编程 ：TypeScript 支持类、接口、继承等面向对象编程的概念，使得代码更加组织化和可维护。   逐步迁移 ：由于 TypeScript 是 JavaScript 的超集，你可以逐渐将现有的 JavaScript 代码迁移到 TypeScript，而无需重写整个项目。   更好的可读性 ：TypeScript 提供了更明确的语法和更强大的类型系统，使得代码更加易于阅读和理解。   大型项目的支持 ：TypeScript 的模块化特性使得它在构建大型项目时特别有用，你可以将代码拆分成多个模块或文件，每个模块都有其自己的作用域和命名空间。   社区支持 ：TypeScript 有一个活跃的社区和大量的库和框架支持，比如 Angular、React、Vue 等前端框架都有官方的 TypeScript 支持。要使用 TypeScript，你需要安装 TypeScript 编译器（  ），然后编写    文件。当你运行 TypeScript 编译器时，它会将    文件转换为    文件，然后你就可以像使用普通的 JavaScript 代码一样使用它们了。","level":2},{"id":"/tags/mobile/flutter#flutter","title":"Flutter","titles":[],"content":"Flutter 是由 Google 开发的跨平台移动应用开发框架，可以用来构建高性能、美观且流畅的移动应用。以下是 Flutter 的一些关键特点：跨平台开发 ：Flutter 允许开发者使用单一代码库构建同时运行在 iOS 和 Android 平台上的应用程序，减少了开发和维护成本。   快速开发 ：Flutter 提供了丰富的组件库和热重载功能，使得开发者能够快速迭代和实时查看应用程序的变化。   自绘引擎 ：Flutter 使用自绘引擎（Skia）进行渲染，可以实现高性能的动画和流畅的用户体验。   响应式框架 ：Flutter 采用响应式框架，通过 Widget 树的方式构建用户界面，使得界面的构建和更新更加灵活和高效。   丰富的 UI 组件 ：Flutter 提供了丰富的现成 UI 组件，开发者可以快速构建各种复杂的用户界面，同时也支持自定义 UI 组件。   原生性能 ：Flutter 应用程序编译为原生代码，具有接近原生应用的性能表现，同时也支持访问平台特定的 API 和功能。   开放源代码 ：Flutter 是一个开源项目，拥有活跃的社区和丰富的第三方库，为开发者提供了丰富的资源和支持。总的来说，Flutter 是一个强大且现代化的移动应用开发框架，通过其跨平台特性、快速开发能力和优秀的性能表现，使得开发者能够轻松构建高质量的移动应用，并且在不同平台上实现一致的用户体验。","level":2},{"id":"/tags/mobile/ionic#ionic","title":"Ionic","titles":[],"content":"Ionic 是一个强大的 HTML5 应用程序开发框架，主要用于构建高性能、高质量的移动应用程序。它基于 Web 技术，如 HTML、CSS 和 JavaScript，并集成了如 Angular、React 和 Vue.js 等前端框架，使得开发者能够使用熟悉的 Web 开发技术来创建类似于原生应用体验的移动应用。Ionic 的主要特点包括：跨平台性能 ：Ionic 具有出色的跨平台性能，可以在不同的移动设备上流畅运行，实现一次编写，多处运行的效果。   原生应用体验 ：尽管 Ionic 使用 Web 技术构建应用，但它能够提供与原生应用相似的用户体验，包括流畅的界面交互和快速的响应速度。   丰富的 UI 组件 ：Ionic 提供了大量可定制的 UI 组件，帮助开发者快速构建美观且实用的应用界面。   强大的命令行工具 ：Ionic 提供了命令行工具，可以简化应用的开发、调试和部署过程。   与 Angular 的紧密集成 ：Ionic 与 AngularJS 框架紧密结合，开发者可以利用 AngularJS 的特性和优势来增强 Ionic 应用的功能和性能。总的来说，Ionic 是一个功能强大、易于使用的移动应用开发框架，特别适合那些希望使用 Web 技术来构建高性能移动应用的开发者。然而，需要注意的是，Ionic 主要关注于移动应用的 UI 和交互开发，对于复杂的后端逻辑或特定于平台的原生功能，可能还需要结合其他技术或工具来实现。","level":2},{"id":"/tags/mobile/miniprogram#miniprogram","title":"miniprogram","titles":[],"content":"微信小程序是一种无需下载安装即可使用的轻量级应用，由腾讯公司于 2017 年推出，嵌入在微信平台内。小程序旨在提供一种便捷的应用体验，用户可以通过微信直接访问和使用各种功能和服务，而不需要下载独立的应用。以下是对微信小程序的详细介绍，包括其关键特点、历史演变、开发和应用场景。","level":2},{"id":"/tags/mobile/miniprogram#关键特点","title":"关键特点","titles":["miniprogram"],"content":"无需安装 ：用户可以直接在微信中使用小程序，无需下载和安装独立的应用程序。   轻量化 ：小程序体积小，加载速度快，适合各种网络环境。   便捷入口 ：通过扫描二维码、搜索、好友分享、公众号关联等多种方式访问小程序。   丰富功能 ：支持多种功能，包括电商、服务预订、资讯阅读、社交互动等。   跨平台 ：适用于 iOS 和 Android 系统，用户体验一致。   低开发成本 ：开发者可以通过微信提供的开发工具和 API 快速创建和发布小程序。","level":3},{"id":"/tags/mobile/miniprogram#历史演变","title":"历史演变","titles":["miniprogram"],"content":"","level":3},{"id":"/tags/mobile/miniprogram#起源和早期发展","title":"起源和早期发展","titles":["miniprogram","历史演变"],"content":"2017 年 1 月 ：微信小程序正式上线，首批小程序覆盖了购物、出行、社交等多个领域。   2017 年 3 月 ：微信开放小程序的二维码扫描功能，用户可以通过扫描二维码直接打开小程序。","level":4},{"id":"/tags/mobile/miniprogram#重要里程碑","title":"重要里程碑","titles":["miniprogram","历史演变"],"content":"2017 年 12 月 ：小程序开放与公众号关联，用户可以通过公众号访问相关小程序。   2018 年 ：小程序支持分享到微信聊天和朋友圈，进一步扩大了用户访问入口。   2019 年 ：微信小程序日活跃用户数突破 3 亿，成为微信生态系统的重要组成部分。   2020 年 ：微信推出小程序直播功能，推动电商和直播的深度结合。","level":4},{"id":"/tags/mobile/miniprogram#开发工具和技术","title":"开发工具和技术","titles":["miniprogram","历史演变"],"content":"微信开发者工具 ：提供集成开发环境，支持小程序的创建、调试和发布。   WXML ：微信标记语言，用于构建小程序的用户界面。   WXSS ：微信样式表，用于描述小程序的样式和布局。   JavaScript ：用于小程序的逻辑编写，处理用户交互和数据。   API 接口 ：微信提供了丰富的 API 接口，包括用户信息、支付、地理位置、文件操作等。","level":3},{"id":"/tags/mobile/miniprogram#应用场景","title":"应用场景","titles":["miniprogram","历史演变"],"content":"电商 ：如京东、拼多多的微信小程序，提供商品浏览、购买和支付功能。   服务预订 ：如美团、携程的微信小程序，用户可以预订酒店、机票、餐厅等服务。   资讯阅读 ：如腾讯新闻、今日头条的微信小程序，提供新闻资讯的浏览和订阅。   社交互动 ：如摩拜单车、滴滴出行的微信小程序，提供出行和共享服务。   小游戏 ：如跳一跳、斗地主等微信小游戏，提供娱乐和社交互动。","level":3},{"id":"/tags/mobile/miniprogram#总结","title":"总结","titles":["miniprogram","历史演变"],"content":"微信小程序通过轻量化、便捷的特性，为用户提供了丰富的应用场景和体验，同时降低了开发者的开发成本和难度。作为微信生态系统的重要组成部分，小程序已经在电商、服务预订、资讯阅读、社交互动等多个领域取得了广泛应用。随着功能的不断丰富和优化，微信小程序在未来将继续发挥其重要作用，推动移动互联网应用的发展。","level":3},{"id":"/tags/mobile/react-native#react-native","title":"React Native","titles":[],"content":"React Native 是 Facebook 于 2015 年 4 月开源的跨平台移动应用开发框架，是 Facebook 早先开源的 JS 框架 React 在原生移动应用平台的衍生产物。React Native 使用 Javascript 语言、类似于 HTML 的 JSX 以及 CSS 来开发移动应用，使得熟悉 Web 前端开发的技术人员能够轻松地进入移动应用开发领域。React Native 的主要特性和优势包括：跨平台开发 ：React Native 支持 iOS 和安卓两大主流移动平台，允许开发者使用相同的代码库创建多平台应用，实现“一次编写，多处运行”的开发效率。   原生的 UI 组件和体验 ：React Native 提供了对原生 UI 组件的访问，使得开发者能够利用这些组件创建出与原生应用相似的外观和体验。   异步执行 ：React Native 中的 JavaScript 应用代码和原生平台之间的操作采用异步执行模式，这有助于优化应用的性能和响应速度。   高效的社区支持 ：React Native 拥有庞大的社区，这意味着开发者可以获得大量的组件和库，以及来自其他开发者的支持和帮助。React Native 不仅适用于移动应用程序开发，还可以用于混合应用程序开发、跨平台桌面应用程序开发、游戏开发以及物联网应用程序开发等领域。通过使用 React Native，开发者可以充分利用其跨平台特性和高效的开发流程，快速构建出功能丰富、性能优越的移动应用。请注意，尽管 React Native 带来了诸多便利，但在某些情况下，它可能不是最佳选择。例如，对于需要高度定制化或深度集成原生功能的应用，原生开发可能更为合适。因此，在选择使用 React Native 时，需要根据项目的具体需求和目标进行权衡。总的来说，React Native 为移动应用开发提供了一种高效、灵活且强大的解决方案，使得开发者能够更快地构建出优质的移动应用，满足不断变化的市场需求。","level":2},{"id":"/tags/mobile/uniapp#uniapp","title":"UniApp","titles":[],"content":"UniApp 是一个基于 Vue.js 的跨平台应用开发框架，可以用于快速开发同时运行在多个平台（包括 iOS、Android、Web 等）的应用程序。以下是 UniApp 的一些关键特点：跨平台开发 ：UniApp 支持一次编写，多端运行，开发者可以使用同一套代码 base 开发 iOS、Android、Web 等多个平台的应用。   基于 Vue.js ：UniApp 基于 Vue.js 框架，开发者可以使用 Vue.js 的语法和特性来构建应用程序，降低学习成本。   组件化开发 ：UniApp 采用组件化开发模式，提供了丰富的组件库和 API，使得开发者能够快速构建复杂的应用界面。   原生能力 ：UniApp 支持调用原生 API 和插件，可以实现与设备硬件（如相机、地理位置、传感器等）交互的功能。   性能优化 ：UniApp 通过优化渲染机制和性能调优，提供了流畅的用户体验和高性能的应用程序。   打包发布 ：UniApp 提供了丰富的打包发布功能，可以将应用打包为 iOS、Android、H5 等格式，并发布到各个应用商店和平台。   生态系统 ：UniApp 拥有活跃的社区和丰富的插件市场，为开发者提供了丰富的资源和支持。总的来说，UniApp 是一个强大且灵活的跨平台应用开发框架，通过其跨平台特性、Vue.js 基础和丰富的组件库，使得开发者能够快速构建高质量的跨平台应用，降低开发成本，提高开发效率。UniApp 在移动应用开发领域具有广泛的应用和影响力。","level":2},{"id":"/tags/os/android#android","title":"Android","titles":[],"content":"Android 是由 Google 开发的移动操作系统，主要用于智能手机和平板电脑等移动设备。以下是 Android 的一些关键特点：开放源代码 ：Android 是基于 Linux 内核的开源操作系统，允许开发者自由定制和修改系统，促进了开发者社区的发展。   应用生态系统 ：Android 拥有庞大的应用生态系统，用户可以通过 Google Play 商店下载和安装各种应用程序，满足各种需求。   多样化设备 ：Android 系统适用于各种设备类型和厂商，包括智能手机、平板电脑、智能手表、智能电视等，提供了多样化的选择。   定制化 ：Android 系统允许设备制造商对系统进行定制和优化，使得不同品牌的设备具有独特的用户界面和功能。   多任务处理 ：Android 系统支持多任务处理，用户可以同时运行多个应用程序，并在应用之间快速切换，提高了工作效率。   通知系统 ：Android 系统具有强大的通知系统，用户可以及时收到来自应用程序的通知消息，方便管理和响应。   Google 服务 ：Android 系统与 Google 服务紧密集成，包括 Gmail、Google Maps、Google Drive 等，为用户提供了丰富的功能和服务。   安全性 ：Android 系统不断加强安全性措施，包括应用权限管理、应用签名、安全更新等，保护用户数据和隐私安全。总的来说，Android 作为全球最流行的移动操作系统之一，为用户提供了丰富的功能和服务，为开发者提供了广阔的应用开发平台，同时也为设备制造商提供了灵活的定制化选择，成为移动设备领域的重要一员。","level":2},{"id":"/tags/os/centos#centos","title":"CentOS","titles":[],"content":"CentOS (Community ENTerprise Operating System) 是一个免费的、开源的操作系统，它是基于 Red Hat Enterprise Linux (RHEL) 的源代码构建的。CentOS 提供了 RHEL 的许多特性和稳定性，但不包括商业支持，使其成为许多企业和开发者的首选。以下是对 CentOS 的详细介绍，包括其关键特点、历史演变和主要版本。","level":2},{"id":"/tags/os/centos#关键特点","title":"关键特点","titles":["CentOS"],"content":"源自 RHEL ：CentOS 基于 RHEL 的源代码构建，因此具有与 RHEL 相同的稳定性和兼容性。   免费和开源 ：CentOS 是完全免费的，任何人都可以下载、使用和修改其源代码。   长生命周期 ：每个 CentOS 版本都有一个长达 10 年的支持周期，提供长期的安全更新和维护。   稳定性 ：适用于服务器和企业环境，提供高可靠性和稳定性。   软件兼容性 ：与 RHEL 兼容的二进制文件，使得在 RHEL 上开发的软件可以无缝运行在 CentOS 上。   广泛的社区支持 ：拥有一个活跃的用户和开发者社区，提供丰富的资源和帮助。","level":3},{"id":"/tags/os/centos#历史演变","title":"历史演变","titles":["CentOS"],"content":"","level":3},{"id":"/tags/os/centos#起源和早期发展","title":"起源和早期发展","titles":["CentOS","历史演变"],"content":"2004 ：CentOS 项目由 Gregory Kurtzer 启动，首个版本 CentOS 3.1 基于 RHEL 3 源代码发布。   2006 ：CentOS 4 发布，基于 RHEL 4，进一步巩固了其在企业服务器市场的地位。","level":4},{"id":"/tags/os/centos#重要里程碑","title":"重要里程碑","titles":["CentOS","历史演变"],"content":"2007 ：CentOS 5 发布，基于 RHEL 5，增强了虚拟化支持和安全特性。   2011 ：CentOS 6 发布，基于 RHEL 6，引入了更强大的性能和稳定性改进。   2014 ：CentOS 项目与 Red Hat 合作，成为 Red Hat 的官方社区版。CentOS 7 发布，基于 RHEL 7，引入了 systemd、XFS 文件系统等新特性。","level":4},{"id":"/tags/os/centos#最新版本","title":"最新版本","titles":["CentOS","历史演变"],"content":"2019 ：CentOS 8 发布，基于 RHEL 8，包含新的应用流 (AppStream) 存储库，改进了容器支持和性能。   2020 ：宣布 CentOS 8 将在 2021 年底结束支持，并引入 CentOS Stream 作为未来的开发模式，提供一个滚动更新的发布版本，定位于 RHEL 的上游开发版本。","level":4},{"id":"/tags/os/centos#主要版本","title":"主要版本","titles":["CentOS","历史演变"],"content":"CentOS 3 ：最早的 CentOS 版本，基于 RHEL 3。   CentOS 4 ：引入了 SELinux 和更好的硬件支持。   CentOS 5 ：增强了虚拟化和安全特性。   CentOS 6 ：引入了新的功能和性能改进，支持更长的生命周期。   CentOS 7 ：大幅更新，包括 systemd、XFS 文件系统和 Docker 支持。   CentOS 8 ：最新的稳定版本，提供了最新的技术和改进。   CentOS Stream ：一个滚动更新的版本，位于 Fedora 和 RHEL 之间，作为 RHEL 的上游开发版本。","level":3},{"id":"/tags/os/centos#主要功能和组件","title":"主要功能和组件","titles":["CentOS","历史演变"],"content":"YUM 包管理器 ：用于安装、更新和管理软件包。   systemd ：系统和服务管理器，取代了传统的 init 系统。   SELinux ：强制访问控制安全系统，增强了系统安全性。   KVM 和 QEMU ：用于虚拟化支持，提供高性能的虚拟机管理。   XFS 文件系统 ：默认文件系统，提供高性能和可扩展性。   Docker 和 Podman ：容器技术支持，简化了应用部署和管理。","level":3},{"id":"/tags/os/centos#总结","title":"总结","titles":["CentOS","历史演变"],"content":"CentOS 是一个功能强大、稳定且免费的操作系统，广泛应用于服务器和企业环境。通过基于 RHEL 源代码构建，CentOS 提供了与 RHEL 相同的稳定性和兼容性，但没有商业支持，使其成为许多预算有限的企业和开发者的理想选择。随着 CentOS Stream 的引入，CentOS 项目继续在开源社区中发挥重要作用，推动 Linux 生态系统的发展和创新。","level":3},{"id":"/tags/os/harmonyos#harmonyos","title":"HarmonyOS","titles":[],"content":"HarmonyOS（鸿蒙操作系统）是由华为公司开发的跨平台操作系统，旨在提供统一的操作系统体验，支持多种设备类型，包括智能手机、平板电脑、智能家居设备、车载系统等。HarmonyOS 强调分布式架构和生态系统的一体化，旨在实现设备之间的无缝协同工作。https://www.harmonyos.com/","level":2},{"id":"/tags/os/harmonyos#关键特点","title":"关键特点","titles":["HarmonyOS"],"content":"分布式架构 ：HarmonyOS 采用分布式架构设计，支持多设备协同和资源共享，实现跨设备的无缝体验。   统一生态系统 ：通过一个操作系统覆盖多种设备类型，减少开发者的开发难度，提高应用的兼容性和一致性。   高性能和低时延 ：HarmonyOS 提供了高效的任务调度和进程管理，保证系统的高性能和低时延。   安全性 ：采用多层次的安全防护机制，保护用户数据和隐私。   开源 ：HarmonyOS 是一个开源项目，开发者可以自由查看和修改其源代码。","level":3},{"id":"/tags/os/harmonyos#历史演变","title":"历史演变","titles":["HarmonyOS"],"content":"","level":3},{"id":"/tags/os/harmonyos#起源和早期发展","title":"起源和早期发展","titles":["HarmonyOS","历史演变"],"content":"2019 年 ：华为正式发布 HarmonyOS 1.0，最初主要用于智能电视和物联网设备。   2020 年 ：HarmonyOS 2.0 发布，扩展支持智能手机、平板电脑和智能手表。","level":4},{"id":"/tags/os/harmonyos#重要里程碑","title":"重要里程碑","titles":["HarmonyOS","历史演变"],"content":"2021 年 ：华为推出 HarmonyOS 2.0 公测版本，涵盖更多设备类型，并在多个华为设备上进行推广。   2022 年 ：HarmonyOS 在中国市场的设备数量迅速增长，成为华为主要的操作系统平台之一。","level":4},{"id":"/tags/os/harmonyos#主要版本","title":"主要版本","titles":["HarmonyOS","历史演变"],"content":"HarmonyOS 1.0 ：初始版本，主要面向智能电视和物联网设备。   HarmonyOS 2.0 ：扩展支持智能手机、平板电脑、智能手表等设备，推出分布式能力和多设备协同。   HarmonyOS 3.0 ：进一步优化性能和稳定性，增强跨设备协同和生态系统建设。","level":3},{"id":"/tags/os/harmonyos#主要功能和组件","title":"主要功能和组件","titles":["HarmonyOS","历史演变"],"content":"分布式软总线 ：实现设备之间的无缝连接和资源共享，使多个设备像一个设备一样协同工作。   分布式数据管理 ：提供跨设备的数据同步和共享，保证数据的一致性和实时性。   分布式任务调度 ：优化任务分配和调度，提高系统资源的利用率和响应速度。   Ark Compiler ：一种多语言统一编译器，支持多种编程语言，提高应用的执行效率。   多端开发框架 ：为开发者提供一次开发、多端部署的能力，减少开发时间和成本。","level":3},{"id":"/tags/os/harmonyos#应用场景","title":"应用场景","titles":["HarmonyOS","历史演变"],"content":"智能手机和平板电脑 ：提供流畅的用户体验和强大的应用生态系统。   智能家居 ：实现家居设备的智能互联和协同控制，如智能音箱、智能灯泡、智能冰箱等。   车载系统 ：提供智能车载娱乐和导航系统，实现汽车与其他设备的互联互通。   物联网设备 ：支持各种物联网设备的接入和管理，提高设备之间的互操作性。","level":3},{"id":"/tags/os/harmonyos#总结","title":"总结","titles":["HarmonyOS","历史演变"],"content":"HarmonyOS 是一个创新的操作系统，旨在通过分布式架构和统一生态系统，实现设备之间的无缝协同工作。凭借其高性能、低时延和高安全性，HarmonyOS 为用户提供了一个全新的智能设备体验。随着华为在全球市场的推广和应用，HarmonyOS 有望成为未来智能设备的主要操作系统之一。","level":3},{"id":"/tags/os/ios#ios","title":"iOS","titles":[],"content":"iOS 是由苹果公司开发的移动操作系统，专门用于 iPhone、iPad、iPod Touch 等设备。以下是 iOS 的一些关键特点：用户界面 ：iOS 拥有直观、流畅的用户界面，采用触摸屏幕和多点触控技术，提供优秀的用户体验。   App Store ：iOS 设备可以通过 App Store 下载和安装各种应用程序，包括游戏、社交、生产力工具等，丰富了设备的功能和应用场景。   安全性 ：iOS 具有较高的安全性，包括数据加密、应用沙箱、面部识别（Face ID）等功能，保护用户数据和隐私。   性能 ：iOS 设备通常具有优秀的性能表现，搭载苹果自研的 A 系列芯片，提供流畅的操作和快速的响应速度。   生态系统 ：iOS 与其他苹果设备和服务（如 Mac、Apple Watch、iCloud 等）紧密集成，形成了完整的生态系统，实现设备间的无缝连接和数据共享。   更新支持 ：苹果定期发布 iOS 系统更新，包括新功能、性能优化和安全补丁，保持设备的稳定性和安全性。   开发者支持 ：iOS 开发者可以使用 Xcode 开发工具和 Swift/Objective-C 编程语言开发应用程序，通过 App Store 发布和分发应用。   生活方式 ：iOS 设备支持各种生活方式应用，如健康追踪、支付服务（Apple Pay）、智能家居控制（HomeKit）等，提升用户生活品质。总的来说，iOS 作为一个成熟、稳定且功能丰富的移动操作系统，为用户提供了优质的用户体验和开发者友好的开发环境，成为全球最受欢迎的移动操作系统之一。","level":2},{"id":"/tags/os/linux#linux","title":"Linux","titles":[],"content":"Linux 是一个开源的、类 Unix 的操作系统内核，由 Linus Torvalds 于 1991 年首次发布。由于其开源性质和高度的灵活性，Linux 已成为世界上最广泛使用的操作系统之一，尤其在服务器、超级计算机和嵌入式系统领域。以下是对 Linux 的详细介绍，包括其关键特点、历史演变和主要发行版。","level":2},{"id":"/tags/os/linux#关键特点","title":"关键特点","titles":["Linux"],"content":"开源和自由 ：Linux 的源代码是公开的，任何人都可以查看、修改和分发。大部分 Linux 发行版是免费的。   高度定制化 ：用户可以根据自己的需求定制操作系统，从内核配置到用户界面。   稳定性和安全性 ：由于其多用户、多任务的设计，Linux 被认为是非常稳定和安全的操作系统。   广泛的硬件支持 ：Linux 支持从桌面电脑到服务器、移动设备和嵌入式系统的各种硬件平台。   社区支持 ：庞大的全球社区为 Linux 提供持续的支持和开发，快速响应安全问题和软件更新。   强大的命令行工具 ：Linux 提供了一套强大的命令行工具和脚本语言，使得系统管理和自动化任务非常高效。","level":3},{"id":"/tags/os/linux#历史演变","title":"历史演变","titles":["Linux"],"content":"","level":3},{"id":"/tags/os/linux#早期发展","title":"早期发展","titles":["Linux","历史演变"],"content":"1991 ：Linus Torvalds 发布了 Linux 内核的第一个版本。   1992 ：Linux 内核首次发布在 GNU 通用公共许可证 (GPL) 下，使得它成为开源软件。","level":4},{"id":"/tags/os/linux#重要里程碑","title":"重要里程碑","titles":["Linux","历史演变"],"content":"1993 ：Debian 项目启动，成为最早和最重要的 Linux 发行版之一。   1994 ：Red Hat Linux 发布，为商业化的 Linux 发行版铺平了道路。   1996 ：Linux 内核版本 2.0 发布，引入了多处理器支持。   2001 ：Linux 内核版本 2.4 发布，增加了对 USB 设备和更大内存的支持。   2003 ：Red Hat 进入企业市场，推出 Red Hat Enterprise Linux (RHEL)。   2004 ：Ubuntu 发行版发布，专注于用户友好性和桌面环境。","level":4},{"id":"/tags/os/linux#主要发行版","title":"主要发行版","titles":["Linux","历史演变"],"content":"Linux 有许多不同的发行版（也称为 \"distros\"），每个发行版都针对不同的用户需求和使用场景。以下是一些主要的 Linux 发行版：","level":3},{"id":"/tags/os/linux#debian-系","title":"Debian 系","titles":["Linux","历史演变","主要发行版"],"content":"Debian ：一个高度稳定和自由的发行版，广泛用于服务器和桌面。   Ubuntu ：基于 Debian 的发行版，以用户友好和易用性为目标，非常适合桌面用户和初学者。   Linux Mint ：基于 Ubuntu，提供了一些额外的定制和工具，使得它非常适合桌面使用。","level":4},{"id":"/tags/os/linux#red-hat-系","title":"Red Hat 系","titles":["Linux","历史演变","主要发行版"],"content":"Red Hat Enterprise Linux (RHEL) ：面向企业的商业发行版，提供长期支持和企业级服务。   CentOS ：基于 RHEL 的社区支持版本，提供 RHEL 的功能但不附带商业支持。   Fedora ：由 Red Hat 赞助，专注于最新技术和软件，是 RHEL 的测试平台。","level":4},{"id":"/tags/os/linux#其他主要发行版","title":"其他主要发行版","titles":["Linux","历史演变","主要发行版"],"content":"Arch Linux ：一个轻量级且高度可定制的发行版，面向高级用户，采用滚动更新模式。   openSUSE ：由 SUSE 赞助，提供稳定版 (Leap) 和滚动更新版 (Tumbleweed)。   Gentoo ：一个源代码发行版，允许用户从源代码编译和安装所有软件，提供最大的灵活性和优化。","level":4},{"id":"/tags/os/linux#主要功能和组件","title":"主要功能和组件","titles":["Linux","历史演变"],"content":"内核 (Kernel) ：Linux 操作系统的核心，管理硬件和软件资源。   包管理系统 ：如 APT (Debian/Ubuntu)、YUM (RHEL/CentOS)、Pacman (Arch)，用于安装、更新和管理软件包。   桌面环境 ：如 GNOME、KDE、Xfce，提供图形用户界面和用户体验。   文件系统 ：支持多种文件系统，如 ext4、Btrfs、XFS，用于数据存储和管理。   命令行界面 (CLI) ：如 Bash、Zsh，提供强大的命令行工具和脚本语言。","level":3},{"id":"/tags/os/linux#总结","title":"总结","titles":["Linux","历史演变"],"content":"Linux 是一个功能强大、灵活且安全的操作系统，广泛应用于从个人电脑到企业服务器和嵌入式设备的各种场景。凭借其开源和社区驱动的开发模式，Linux 不断发展和创新，成为许多用户和组织的首选操作系统。","level":3},{"id":"/tags/os/macos#macos","title":"macOS","titles":[],"content":"macOS 是苹果公司开发的图形用户界面操作系统，专为其 Macintosh 计算机系列设计和开发。macOS 是世界上最先进和用户友好的操作系统之一，以其流畅的用户体验、强大的功能和高度的安全性而著称。以下是对 macOS 的详细介绍，包括其关键特点、历史演变和主要版本。","level":2},{"id":"/tags/os/macos#关键特点","title":"关键特点","titles":["macOS"],"content":"图形用户界面 ：macOS 以其简洁、美观和直观的用户界面著称，用户可以通过点击和拖动来操作系统。   集成性 ：与苹果的硬件和其他软件生态系统（如 iPhone、iPad、Apple Watch）高度集成，提供无缝的跨设备体验。   安全性 ：macOS 提供了多层次的安全机制，包括 Gatekeeper、FileVault、Sandboxing 和定期的安全更新，以保护用户数据和隐私。   强大的应用程序 ：内置了多种高效的应用程序，如 Safari 浏览器、Mail 邮件客户端、Photos 照片管理、iMovie 视频编辑和 GarageBand 音乐创作等。   Continuity 功能 ：允许用户在不同的 Apple 设备之间无缝切换，例如通过 Handoff 功能在 Mac 上继续在 iPhone 上开始的任务。   高效的文件管理 ：通过 Finder 文件管理器，可以方便地浏览、组织和管理文件。","level":3},{"id":"/tags/os/macos#主要功能和组件","title":"主要功能和组件","titles":["macOS"],"content":"Finder ：用于文件浏览和管理的核心应用。   Spotlight ：全局搜索工具，可以快速查找文件、应用和其他内容。   Safari ：高效的网页浏览器，专为 macOS 优化。   Mail ：功能强大的邮件客户端。   iCloud ：提供云存储和同步服务，使用户可以在多设备间无缝访问文件和数据。   Time Machine ：内置的备份工具，提供自动备份和恢复功能。   Handoff ：允许用户在不同的 Apple 设备之间无缝切换任务。","level":3},{"id":"/tags/os/macos#总结","title":"总结","titles":["macOS"],"content":"macOS 是一个功能强大且用户友好的操作系统，通过与 Apple 设备和服务的深度集成，提供了无缝的用户体验。凭借其卓越的设计、安全性和高效的应用程序，macOS 成为许多专业用户和个人用户的首选操作系统。","level":3},{"id":"/tags/os/ubuntu#ubuntu","title":"Ubuntu","titles":[],"content":"Ubuntu 是一个基于 Debian 的开源操作系统，由 Canonical Ltd. 及其社区开发者共同维护。自 2004 年首次发布以来，Ubuntu 已成为最流行的 Linux 发行版之一，广泛应用于个人电脑、服务器、云计算和物联网等领域。以下是对 Ubuntu 的详细介绍，包括其关键特点、历史演变和主要版本。","level":2},{"id":"/tags/os/ubuntu#关键特点","title":"关键特点","titles":["Ubuntu"],"content":"用户友好 ：Ubuntu 提供了一个简洁易用的界面，适合新手和经验丰富的用户。   开源和免费 ：Ubuntu 是完全免费的，任何人都可以下载、使用和修改。   定期更新 ：Ubuntu 每六个月发布一个新的稳定版本，每两年发布一个长期支持版本 (LTS)，提供五年的安全更新和维护。   广泛的社区支持 ：拥有一个庞大且活跃的社区，提供丰富的资源、帮助和第三方软件。   强大的软件库 ：通过 APT 包管理系统和 Ubuntu 软件中心，可以轻松安装和管理成千上万的软件包。   安全性 ：内置多种安全功能，如防火墙、自动安全更新和用户权限管理。","level":3},{"id":"/tags/os/ubuntu#历史演变","title":"历史演变","titles":["Ubuntu"],"content":"","level":3},{"id":"/tags/os/ubuntu#起源和早期发展","title":"起源和早期发展","titles":["Ubuntu","历史演变"],"content":"2004 ：Ubuntu 4.10 (Warty Warthog) 是第一个版本，由 Mark Shuttleworth 和 Canonical Ltd. 发布。它基于 Debian，旨在提供一个易于使用且定期更新的 Linux 发行版。","level":4},{"id":"/tags/os/ubuntu#重要里程碑","title":"重要里程碑","titles":["Ubuntu","历史演变"],"content":"2006 ：Ubuntu 6.06 LTS (Dapper Drake) 是第一个长期支持 (LTS) 版本，提供了三年的桌面支持和五年的服务器支持。   2010 ：Ubuntu 10.04 LTS (Lucid Lynx) 推出了 Unity 桌面环境，旨在提供一个现代化的用户界面。   2014 ：Ubuntu 14.04 LTS (Trusty Tahr) 强调了对新硬件和云计算的支持，进一步提升了性能和稳定性。","level":4},{"id":"/tags/os/ubuntu#最新发展","title":"最新发展","titles":["Ubuntu","历史演变"],"content":"2017 ：Ubuntu 17.10 (Artful Aardvark) 切换回 GNOME 桌面环境，取代了 Unity。   2018 ：Ubuntu 18.04 LTS (Bionic Beaver) 是一个长期支持版本，引入了许多性能改进和新特性，如新的安装器和更好的硬件支持。   2020 ：Ubuntu 20.04 LTS (Focal Fossa) 提供了改进的安全功能、新的主题和更好的硬件支持。   2022 ：Ubuntu 22.04 LTS (Jammy Jellyfish) 发布，继续提供五年的长期支持，增强了对云计算和容器技术的支持。","level":4},{"id":"/tags/os/ubuntu#主要版本","title":"主要版本","titles":["Ubuntu","历史演变"],"content":"Ubuntu Desktop ：适用于个人计算机，提供一个完整的图形用户界面和丰富的桌面应用。   Ubuntu Server ：适用于服务器环境，优化了性能和稳定性，广泛用于企业和数据中心。   Ubuntu Cloud ：专为云计算设计，提供了与 OpenStack 和 Kubernetes 的无缝集成。   Ubuntu Core ：一种面向物联网设备的精简版 Ubuntu，基于 snap 包管理系统，提供更高的安全性和可管理性。   Ubuntu Kylin ：专门面向中国市场的 Ubuntu 版本，提供本地化的用户界面和应用程序。","level":3},{"id":"/tags/os/ubuntu#主要功能和组件","title":"主要功能和组件","titles":["Ubuntu","历史演变"],"content":"GNOME 桌面环境 ：提供一个现代化、用户友好的图形用户界面。   APT 包管理系统 ：用于安装、更新和管理软件包，支持丰富的软件库。   Ubuntu 软件中心 ：一个图形化的应用商店，使用户可以轻松浏览、安装和管理应用程序。   Snap 包管理系统 ：一种新的软件包格式，提供更好的隔离性和独立性，简化了软件的分发和更新。   UFW 防火墙 ：一个简单易用的防火墙配置工具，增强了系统安全性。   Live Patching ：允许在不重启系统的情况下应用内核安全补丁，提高了系统的可用性。","level":3},{"id":"/tags/os/ubuntu#总结","title":"总结","titles":["Ubuntu","历史演变"],"content":"Ubuntu 是一个功能强大、用户友好且广泛应用的 Linux 发行版。通过定期更新和长期支持版本，Ubuntu 提供了一个稳定、安全且易于使用的平台，适用于个人用户、企业和开发者。凭借其强大的社区支持和丰富的软件库，Ubuntu 成为许多用户进入 Linux 世界的首选。","level":3},{"id":"/tags/os/windows#microsoft-windows","title":"Microsoft Windows","titles":[],"content":"Microsoft Windows 是由微软公司开发的一系列图形用户界面的操作系统。自 1985 年发布首个版本以来，Windows 已经成为全球最广泛使用的操作系统之一，覆盖了个人计算机、服务器和移动设备。以下是一些关于 Microsoft Windows 的关键特点、历史演变以及主要版本的介绍。","level":2},{"id":"/tags/os/windows#关键特点","title":"关键特点","titles":["Microsoft Windows"],"content":"图形用户界面 (GUI) ：Windows 以其易用的图形用户界面著称，使得用户可以通过鼠标和键盘直观地与计算机进行交互。   多任务处理 ：支持同时运行多个应用程序，提高工作效率。   硬件兼容性 ：与大多数计算机硬件和外部设备兼容，包括打印机、扫描仪、摄像头等。   丰富的应用生态系统 ：提供了丰富的应用程序和软件，涵盖从生产力工具到娱乐应用。   安全性 ：包含内置的防火墙、反病毒软件和定期的安全更新，以保护用户数据和系统安全。","level":3},{"id":"/tags/os/windows#历史演变","title":"历史演变","titles":["Microsoft Windows"],"content":"","level":3},{"id":"/tags/os/windows#早期版本","title":"早期版本","titles":["Microsoft Windows","历史演变"],"content":"Windows 1.0 (1985) ：首次引入图形用户界面，提供基本的窗口、菜单和对话框功能。   Windows 3.x (1990-1992) ：显著改进了图形界面，增加了程序管理器和文件管理器，广受欢迎。","level":4},{"id":"/tags/os/windows#经典版本","title":"经典版本","titles":["Microsoft Windows","历史演变"],"content":"Windows 95 (1995) ：引入了开始菜单、任务栏和“即插即用”硬件支持，成为一个里程碑。   Windows 98 (1998) ：进一步改进了用户界面和硬件支持，增强了互联网功能。   Windows ME (2000) ：作为 Windows 9x 系列的最后一个版本，注重多媒体和家庭用户。","level":4},{"id":"/tags/os/windows#nt-系列","title":"NT 系列","titles":["Microsoft Windows","历史演变"],"content":"Windows NT 4.0 (1996) ：面向企业用户，提供更高的稳定性和安全性。   Windows 2000 (2000) ：整合了 Windows 98 和 Windows NT 的优点，面向企业和专业用户。","level":4},{"id":"/tags/os/windows#现代版本","title":"现代版本","titles":["Microsoft Windows","历史演变"],"content":"Windows XP (2001) ：结合了 Windows 2000 的稳定性和 Windows ME 的易用性，广受欢迎且长期支持。   Windows Vista (2006) ：引入了新的用户界面 Aero 和改进的安全特性，但因性能问题受到一些批评。   Windows 7 (2009) ：改进了用户界面和性能，广受好评。   Windows 8 (2012) ：引入了开始屏幕和触摸优化，但用户反响不一。   Windows 8.1 (2013) ：改进了 Windows 8 的一些问题，重新引入了开始按钮。","level":4},{"id":"/tags/os/windows#最新版本","title":"最新版本","titles":["Microsoft Windows","历史演变"],"content":"Windows 10 (2015) ：提供了一个统一的平台，适用于各种设备，包括桌面、平板电脑和智能手机。具有连续更新和改进的安全特性。   Windows 11 (2021) ：引入了全新的用户界面设计、更好的多任务处理和增强的性能，专注于现代硬件支持和生产力提升。","level":4},{"id":"/tags/os/windows#主要功能和组件","title":"主要功能和组件","titles":["Microsoft Windows","历史演变"],"content":"文件资源管理器 ：用于浏览和管理文件和文件夹。   控制面板和设置应用 ：提供系统配置和管理功能。   任务管理器 ：用于监控和管理系统资源和正在运行的进程。   Windows Defender ：内置的反病毒和反恶意软件工具。   Windows Store ：提供了统一的应用程序下载和更新平台。","level":3},{"id":"/tags/os/windows#总结","title":"总结","titles":["Microsoft Windows","历史演变"],"content":"Microsoft Windows 是一个功能丰富且广泛使用的操作系统，为各种用户提供了强大的工具和灵活的使用体验。通过不断的创新和改进，Windows 系统在个人计算和企业环境中都占据了重要地位。","level":3},{"id":"/tags/others/vvll#vvllnet","title":"VVLL.net","titles":[],"content":"当然可以。以下是对 \"Vast Value Learn Lab\"（vvll.net）的详细解释，有助于记忆和推广：","level":2},{"id":"/tags/others/vvll#名称解释","title":"名称解释","titles":["VVLL.net"],"content":"Vast Value Learn Lab (vvll.net)  由四个部分组成，每个部分都有其独特的含义：Vast（广阔的） ：意味着这个平台拥有广泛的资源和内容，适用于各种不同的学习需求和兴趣。无论你是初学者还是专家，都可以在这里找到你需要的学习资料。   Value（有价值的） ：强调平台提供的资源都是高质量且有价值的。学习者可以通过这些资源获得实用的知识和技能，真正受益于他们的学习投入。   Learn（学习） ：核心理念是学习，平台致力于帮助学习者提升知识和技能，促进终身学习和个人成长。   Lab（实验室） ：象征着探索和实验的精神。学习不仅仅是获取知识，更是通过实验和实践来深入理解和应用这些知识。","level":3},{"id":"/tags/others/vvll#记忆要点","title":"记忆要点","titles":["VVLL.net"],"content":"广泛的资源 ：记住 \"Vast\"，它代表了资源的丰富性和多样性，无论你需要什么样的学习内容，这里都有。   有价值的内容 ：\"Value\" 提醒我们，这个平台的内容是高质量的，对学习者来说非常有用和实际。   专注于学习 ：\"Learn\" 是核心，平台的主要目标是促进学习和知识传播。   实验和探索 ：\"Lab\" 强调了通过实验和实践来加深理解的理念。","level":3},{"id":"/tags/textformats/h5#html5","title":"HTML5","titles":[],"content":"HTML5 是最新的 HTML 标准，用于构建 Web 页面和应用程序。以下是 HTML5 的一些关键特点：语义化标记 ：HTML5 引入了许多新的语义化元素（如  、  、  等），使得页面结构更清晰、易于理解和维护。   多媒体支持 ：HTML5 提供了内置的多媒体元素（如  、  ），使得在网页中嵌入音频和视频变得更加简单。   Canvas 和 SVG ：HTML5 引入了  元素和 SVG（Scalable Vector Graphics）标准，使得在网页中绘制图形和动画变得更加灵活和强大。   表单增强 ：HTML5 引入了新的表单元素（如  、  等）和属性（如  、  ），提升了表单的交互性和用户体验。   本地存储 ：HTML5 提供了本地存储 API（如 Web Storage 和 IndexedDB），使得在浏览器中存储数据变得更加方便和高效。   Web Workers ：HTML5 引入了 Web Workers API，允许在后台运行脚本，提高了网页的性能和响应速度。   响应式设计 ：HTML5 支持响应式设计，使得网页能够根据不同设备的屏幕尺寸和分辨率进行自适应布局。   离线应用 ：HTML5 提供了离线 Web 应用程序（Offline Web Applications）的支持，使得用户可以在离线状态下访问应用程序。总的来说，HTML5 是一个强大且灵活的标准，为开发者提供了丰富的功能和工具，使得构建现代化、交互式的 Web 页面和应用程序变得更加容易和高效。","level":2},{"id":"/tags/textformats/html#html","title":"HTML","titles":[],"content":"HTML（HyperText Markup Language）是一种用于创建网页结构的标记语言。以下是 HTML 的一些关键特点：标记结构 ：HTML 使用标签（Tag）来描述文档的结构，每个标签用于表示不同的元素（如标题、段落、链接等）。   语义化 ：HTML 具有语义化的特点，通过合适的标签和属性来描述文档的含义和结构，使得页面更具可读性和可访问性。   超链接 ：HTML 中的超链接（Hyperlink）用于在不同页面之间建立链接关系，通过  标签和 href 属性实现。   图像嵌入 ：HTML 支持在页面中嵌入图像，通过  标签和 src 属性来引用图片资源。   表单 ：HTML 提供了表单元素（如  、  、  等）和属性，用于创建交互式的表单，收集用户输入数据。   列表 ：HTML 支持有序列表（  ）、无序列表（  ）和定义列表（  ），用于展示项目列表和定义列表。   嵌入多媒体 ：HTML 支持嵌入多媒体内容，如音频、视频和嵌入式内容，通过  、  等标签实现。   元数据 ：HTML 中的元数据（Metadata）用于描述文档的信息，如标题、字符编码、关键字等，通过  标签设置。总的来说，HTML 是构建 Web 页面的基础，通过合适的标签和属性描述页面结构和内容，使得页面具有良好的结构化和语义化，为用户提供良好的浏览体验。","level":2},{"id":"/tags/textformats/json#json","title":"JSON","titles":[],"content":"JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，常用于前后端数据传输和配置文件。以下是 JSON 的一些特点：易读性 ：JSON 采用类似于 JavaScript 对象的键值对结构，易于阅读和编写。   轻量级 ：JSON 数据格式简洁且紧凑，适合在网络传输中使用，不会占用过多的带宽。   数据类型 ：JSON 支持基本数据类型（字符串、数字、布尔值、null）、对象和数组，可以表示复杂的数据结构。   跨语言 ：JSON 是一种语言无关的数据格式，几乎所有编程语言都支持 JSON 的解析和生成。   易于解析 ：JSON 数据可以通过内置的 JSON 解析器快速解析为对象或数组，便于在程序中进行操作。   扩展性 ：JSON 支持嵌套结构和数组，可以表示各种复杂的数据关系。   常见应用 ：JSON 常用于 Web 开发中的 API 数据传输、配置文件、日志记录等场景。示例 JSON 数据：总的来说，JSON 是一种简单、通用且易于理解的数据格式，广泛应用于各种领域，特别是在 Web 开发中扮演着重要的角色。","level":2},{"id":"/tags/textformats/json5#json5","title":"JSON5","titles":[],"content":"JSON5 是 JSON 的一种扩展格式，旨在提供更人性化和灵活的 JSON 编写和阅读体验。它保留了 JSON 的语法特性，同时引入了一些额外的功能和语法糖，使得 JSON5 更适合于复杂数据结构的表示和维护。","level":2},{"id":"/tags/textformats/json5#主要特点和功能","title":"主要特点和功能","titles":["JSON5"],"content":"更灵活的语法 ：\nJSON5 支持 JSON 中不允许的一些语法，如支持在对象和数组的末尾添加逗号，以及支持注释（单行注释    和多行注释   ）。   更丰富的数据类型 ：\nJSON5 支持 JSON 中未定义的一些数据类型，如字符串可以使用单引号    包裹，可以包含 JavaScript 的特殊字符（如反斜杠   ）而不需要转义。   支持对象键的引号省略 ：\n在 JSON5 中，对象的键名可以不强制使用双引号括起来，除非键名包含特殊字符或不符合标识符的命名规则。   支持正则表达式字面量 ：\nJSON5 允许在对象中使用正则表达式字面量，这在原生的 JSON 中是不支持的。   跨平台和易读性 ：\nJSON5 与标准 JSON 兼容，可以在现有的 JSON 解析器中使用，同时也更易读和编写，使得人们在处理和编辑 JSON 数据时更加高效。","level":3},{"id":"/tags/textformats/json5#使用方法","title":"使用方法","titles":["JSON5"],"content":"JSON5 的语法相对于标准的 JSON 来说更加灵活，但需要注意以下几点：语法规范 ：JSON5 的语法规范可以在其官方网站（  https://json5.org/）上查看和学习。   解析器支持 ：大部分现代编程语言都有对 JSON5 的解析支持，例如 JavaScript 中可以使用    方法来解析 JSON5 格式的数据。   工具支持 ：有许多在线工具和编辑器支持 JSON5 格式，能够帮助用户验证和格式化 JSON5 数据。","level":3},{"id":"/tags/textformats/json5#应用场景","title":"应用场景","titles":["JSON5"],"content":"JSON5 主要适用于需要在 JSON 的基础上提供更多语法灵活性和可读性的场景，例如：配置文件 ：使用 JSON5 编写和维护复杂的配置文件，能够更方便地添加注释和结尾逗号。   数据交换 ：在数据交换和通信中，JSON5 可以更好地支持复杂数据结构和数据类型的表示。   JavaScript 应用 ：特别是在与 JavaScript 紧密集成的应用程序中，JSON5 的特性可以更自然地与 JavaScript 对象和数组进行交互。","level":3},{"id":"/tags/textformats/json5#总结","title":"总结","titles":["JSON5"],"content":"JSON5 是 JSON 的一种扩展格式，通过引入更多的语法和功能，使得 JSON 数据的编写和阅读更加灵活和方便。它保留了 JSON 的兼容性和简洁性，同时提供了额外的特性，适用于需要更复杂数据结构和更人性化编写风格的应用场景。","level":3},{"id":"/tags/textformats/md#markdown","title":"Markdown","titles":[],"content":"Markdown 是一种轻量级的标记语言，设计初衷是简化 HTML 的书写。它通过使用易读易写的纯文本格式，能够快速将内容转换为结构化的 HTML 文档，因此被广泛应用于撰写博客、文档、笔记、论坛帖子、电子邮件甚至是静态网站的内容。","level":2},{"id":"/tags/textformats/md#主要特点和语法","title":"主要特点和语法","titles":["Markdown"],"content":"简洁和易读性 ：\nMarkdown 的语法非常简洁直观，使得用户可以快速上手，不需要复杂的编程知识。例如，使用    表示标题，   或    表示斜体或粗体文本。   纯文本格式 ：\nMarkdown 是纯文本格式，因此可以在任何文本编辑器中编写，不受特定软件的限制。   与 HTML 兼容 ：\nMarkdown 可以直接嵌入 HTML 标记，可以利用 HTML 的强大功能来增强文档的表现力。   语法简单明了 ：\nMarkdown 的语法基本上可以分为以下几类：   标题：使用    表示一级标题到六级标题。  段落和换行：使用空行分隔段落，行末加两个空格表示强制换行。  列表：使用   、   或    开头表示无序列表，使用数字加    表示有序列表。  强调和格式：使用    或    表示斜体，使用    或    表示粗体，使用反引号 ` 表示代码块。  链接和图片：使用    表示链接，使用    表示图片。   扩展功能 ：\nMarkdown 支持多种扩展语法，例如：   表格：使用    和    表示表格。  任务列表：使用    或    表示任务列表。","level":3},{"id":"/tags/textformats/md#应用场景","title":"应用场景","titles":["Markdown"],"content":"博客和静态网站 ：\n许多博客平台和静态网站生成器（如 Jekyll、Hugo）都支持 Markdown 格式，用户可以使用 Markdown 编写和发布内容。   技术文档 ：\n开发者经常使用 Markdown 编写项目文档、API 文档和 README 文件，GitHub 等代码托管平台也广泛支持 Markdown 格式。   笔记和文档 ：\n个人用户可以使用 Markdown 格式来撰写笔记、学习记录和个人文档，保持文档的整洁和结构化。   电子邮件 ：\n有些邮件客户端和服务商支持 Markdown 格式，用户可以在邮件中使用 Markdown 来排版和格式化内容。   论坛和社交媒体 ：\n一些论坛和社交平台允许用户使用 Markdown 格式来发布帖子和评论，使得内容更易读和美观。","level":3},{"id":"/tags/textformats/md#总结","title":"总结","titles":["Markdown"],"content":"Markdown 作为一种轻量级的标记语言，不仅简化了 HTML 的书写，还具有简洁、易读、扩展性强等优点，使其在各种场景下都有广泛的应用。无论是开发者、写作人员还是个人用户，Markdown 都能提供简便快捷、高效美观的文本编辑和发布体验。","level":3},{"id":"/tags/textformats/mermaid#mermaid","title":"Mermaid","titles":[],"content":"Mermaid 是一个用于描述和绘制流程图、序列图、甘特图等图表的开源工具。它使用简单的文本描述语言，支持多种常见的图表类型，并能够将这些描述转换成可视化图形，以帮助用户更清晰地表达和展示复杂的数据流程和关系。","level":2},{"id":"/tags/textformats/mermaid#主要特点和功能","title":"主要特点和功能","titles":["Mermaid"],"content":"文本描述语言 ：\nMermaid 使用简单的文本描述语言来定义图表，使得用户可以快速创建和编辑复杂的流程图、序列图和其他类型的图表。   多种图表类型 ：\nMermaid 支持多种常见的图表类型，包括但不限于：   流程图（Flowchart）  序列图（Sequence Diagram）  甘特图（Gantt Chart）  类图（Class Diagram）  状态图（State Diagram）  链接数据图（Entity Relationship Diagram）   轻量化和集成 ：\nMermaid 是一个轻量级的工具，易于集成到各种应用和网页中。它可以直接嵌入到 Markdown、HTML 和其他文档中，并支持动态更新和调整。   跨平台和开源 ：\nMermaid 是开源的工具，支持跨平台使用，可以在 Windows、macOS 和 Linux 等操作系统上运行。   自定义样式和布局 ：\n用户可以通过自定义选项和配置文件调整图表的样式、布局和外观，以满足不同需求和设计风格。","level":3},{"id":"/tags/textformats/mermaid#使用方法","title":"使用方法","titles":["Mermaid"],"content":"安装和集成 ：\nMermaid 可以通过 npm 包管理工具进行安装，或者直接在浏览器端使用。详细的安装和使用说明可以在 Mermaid 的官方网站   https://mermaid-js.github.io/mermaid/#/  上找到。   语法示例 ：\n下面是一个简单的 Mermaid 流程图的示例：    这段代码表示一个简单的流程图，节点 A 指向节点 B 和节点 C，节点 B 和节点 C 再分别指向节点 D。   在线编辑器 ：\nMermaid 提供了一个在线编辑器   https://mermaid-js.github.io/mermaid-live-editor/  ，可以实时预览和编辑 Mermaid 图表，帮助用户快速调试和生成图表。","level":3},{"id":"/tags/textformats/mermaid#应用场景","title":"应用场景","titles":["Mermaid"],"content":"软件开发 ：开发团队可以使用 Mermaid 来绘制和共享架构图、流程图和序列图，帮助团队成员理解和协作。   项目管理 ：项目管理人员可以利用 Mermaid 创建和管理甘特图，跟踪项目进度和资源分配。   教育和培训 ：教育工作者可以利用 Mermaid 制作教学资料，图解复杂概念和流程。   文档编写 ：技术文档撰写者可以通过 Mermaid 在文档中插入可视化的图表，提高文档的表现力和可理解性。","level":3},{"id":"/tags/textformats/mermaid#总结","title":"总结","titles":["Mermaid"],"content":"Mermaid 是一个功能强大且易于使用的图表绘制工具，适用于多种场景下的流程图、序列图和甘特图等需求。它通过简单的文本描述语言和丰富的图表类型，帮助用户快速创建和展示复杂的数据流程和关系，是软件开发、项目管理和教育培训等领域中的有力工具。","level":3},{"id":"/tags/textformats/xml#xml","title":"XML","titles":[],"content":"XML（Extensible Markup Language）即可扩展标记语言，它是 SGML（Standard Generalized Markup Language，标准通用标记语言）的一个子集，通过简化 SGML 形成。XML 是从 1995 年开始有其雏形，并在 1998 年二月被发布为 W3C 的标准（XML1.0）。XML 的主要特点包括：可扩展性 ：XML 允许用户自定义标记来描述数据，这使得 XML 具有极大的灵活性，能够适应各种应用需求。   自描述性 ：XML 具有自描述性，能够定义特定的文档模式以检验 XML 文档是否满足特定要求。这使得 XML 文档易于阅读，同时也支持多种异构计算系统对 XML 的处理。   简洁性 ：虽然 XML 源自 SGML，但它只使用了 SGML 的 20%的复杂性，却保留了 80%的功能，这使得 XML 更加简洁易用。   数据的描述与显示相分离 ：在 XML 中，需要显示的数据可以独立地存放在 XML 文档中，而 HTML 文件则负责调用这些 XML 数据文档。这种特性使得 XML 在数据交换和共享方面具有显著优势。XML 的用途非常广泛，它不仅可以用于存储数据，例如 web 应用程序中的各种配置文件（如 web.xml 和 bean.xml），还可以实现数据的分离和交换。此外，XML 还能实现数据共享，通过纯文本文件的方式，提供一种与软件和硬件无关的共享数据方法。在解析 XML 时，可以使用诸如 SAX（Simple API for XML）这样的工具。SAX 采用事件驱动模式来解析数据，每次只在内存中加载 XML 文件的一小部分，因此即使处理大型 XML 文件，也不会占用过多内存，也不会存在内存溢出的问题。总的来说，XML 是一种强大而灵活的数据描述和交换工具，广泛应用于各种需要处理结构化数据的场景。如需更深入的了解 XML 的相关知识和应用，建议查阅专业的编程或软件开发相关书籍和资料。","level":2},{"id":"/tags/textformats/xsl#xsl","title":"XSL","titles":[],"content":"XSL（Extensible Stylesheet Language）是一种用于 XML 文档转换和呈现的语言。它由三个部分组成：","level":2},{"id":"/tags/textformats/xsl#_1-xsltxsl-transformations","title":"1. XSLT（XSL Transformations）","titles":["XSL"],"content":"XSLT 是 XSL 的一部分，用于将 XML 文档转换成其他格式，如 HTML、XML 或纯文本。XSLT 使用一种基于模板和模式匹配的声明性编程风格。","level":3},{"id":"/tags/textformats/xsl#主要特点和用途","title":"主要特点和用途：","titles":["XSL","1. XSLT（XSL Transformations）"],"content":"模板匹配和转换：  使用模板来匹配 XML 文档的元素，并生成输出结果。   XPath 表达式：  使用 XPath 语言来选择和操作 XML 文档中的节点。   变量和函数：  支持变量和函数的定义，增强了转换的灵活性和复用性。   递归处理和条件分支：  支持递归处理和条件分支，可以根据需要动态调整转换逻辑。","level":4},{"id":"/tags/textformats/xsl#_2-xpathxml-path-language","title":"2. XPath（XML Path Language）","titles":["XSL","1. XSLT（XSL Transformations）"],"content":"XPath 是 XSLT 的一部分，用于在 XML 文档中定位和选择节点。它提供了一组表达式，允许开发者通过路径或模式来访问 XML 文档的各个部分。","level":3},{"id":"/tags/textformats/xsl#主要特点和用途-1","title":"主要特点和用途：","titles":["XSL","1. XSLT（XSL Transformations）","2. XPath（XML Path Language）"],"content":"路径表达式：  使用路径表达式描述节点在文档中的位置，类似于文件系统路径。   谓词：  可以使用谓词来过滤节点，根据特定条件选择节点。   函数库：  提供了一系列内置函数，用于在 XPath 表达式中执行字符串操作、数学计算、日期处理等。   轴：  支持不同类型的轴，如子节点、父节点、兄弟节点等，扩展了节点选择的灵活性。","level":4},{"id":"/tags/textformats/xsl#_3-xsl-foxsl-formatting-objects","title":"3. XSL-FO（XSL Formatting Objects）","titles":["XSL","1. XSLT（XSL Transformations）"],"content":"XSL-FO 是 XSL 的另一部分，用于定义文档的格式化和排版规则，以便生成输出的打印或显示形式。XSL-FO 主要用于描述文档的外观和样式，如页面布局、文本格式、图像和表格等。","level":3},{"id":"/tags/textformats/xsl#主要特点和用途-2","title":"主要特点和用途：","titles":["XSL","1. XSLT（XSL Transformations）","3. XSL-FO（XSL Formatting Objects）"],"content":"页面序列和布局：  定义页面的顺序、页眉页脚、页面边距等布局属性。   块和行内对象：  描述文本块、图像、表格和其他对象的布局和样式。   属性和属性集：  使用属性和属性集来设置对象的格式、间距和对齐方式。   多语言支持：  提供多语言文本的处理和排版能力，支持不同语言和文化的排版需求。","level":4},{"id":"/tags/textformats/xsl#使用场景","title":"使用场景：","titles":["XSL","1. XSLT（XSL Transformations）"],"content":"数据转换和整合：  XSLT 用于将 XML 数据转换成不同格式，如 HTML 或其他 XML 结构，适用于数据交换和整合。   动态网页生成：  结合 XSLT 和 XPath 可以根据 XML 数据生成动态网页内容。   打印和报告生成：  使用 XSL-FO 可以生成具有复杂格式和布局要求的打印输出或电子报告。   数据查询和分析：  XPath 可用于查询和分析 XML 数据，从中提取有用信息或执行计算。总之，XSL 家族的语言提供了丰富的工具和技术，用于 XML 文档的转换、呈现和格式化，适用于各种应用场景，从简单的数据转换到复杂的文档排版和打印输出。","level":3},{"id":"/tags/textformats/yaml#yaml","title":"YAML","titles":[],"content":"YAML（YAML Ain't Markup Language）是一种人类可读的数据序列化格式，常用于配置文件和数据交换。以下是 YAML 的一些关键特点：易读性 ：YAML 使用缩进和换行来表示数据结构，具有良好的可读性，使得人类能够轻松理解和编辑 YAML 文件。   简洁性 ：YAML 使用简洁的语法和结构，相比于其他数据格式（如 JSON、XML），YAML 文件通常更加简洁和易于编写。   数据类型 ：YAML 支持多种数据类型，包括字符串、数字、布尔值、数组、对象等，使得可以表示复杂的数据结构。   注释 ：YAML 支持注释，可以在文件中添加注释来解释数据的含义和用途，提高了文件的可读性和可维护性。   扩展性 ：YAML 支持包含其他 YAML 文件、引用其他节点等功能，使得可以构建复杂的数据关系和结构。总的来说，YAML 是一种简洁、易读且功能丰富的数据序列化格式，适用于配置文件、数据交换和其他场景，为开发者提供了一种方便和直观的数据表示方式。","level":2},{"id":"/tags/tools/andorid-studio#android-studio","title":"Android Studio","titles":[],"content":"Android Studio 是谷歌官方推出的集成开发环境（IDE），专门用于开发基于 Android 平台的移动应用程序。它提供了丰富的工具和功能，帮助开发者快速构建、调试和发布高质量的 Android 应用。以下是对 Android Studio 的详细介绍，包括其主要特点、历史演变和关键功能。","level":2},{"id":"/tags/tools/andorid-studio#主要特点","title":"主要特点","titles":["Android Studio"],"content":"全面集成 ：Android Studio 集成了 Android SDK 工具集，提供了开发所需的一切工具，包括代码编辑器、调试器、性能分析工具等。   用户界面设计 ：内置了丰富的界面设计工具，如布局编辑器和主题编辑器，帮助开发者轻松设计和预览应用的用户界面。   调试和测试 ：提供强大的调试功能，支持单步调试、变量查看、内存分析等，帮助开发者快速定位和修复问题。   性能优化 ：集成了性能分析工具，如 Profiler，帮助开发者监控应用的 CPU、内存和网络使用情况，优化应用性能。   内置模拟器 ：Android Studio 自带了 Android 虚拟设备管理器（AVD Manager），可以创建和管理多个虚拟设备，用于在不同设备上测试应用。   集成版本控制 ：支持集成常见的版本控制系统，如 Git，方便开发者管理代码版本和团队协作。   模板和代码生成器 ：提供丰富的模板和代码片段，加快开发速度，同时支持自定义模板和插件扩展。   支持多语言 ：支持多种编程语言，包括 Java、Kotlin 和 C++，开发者可以根据自己的喜好和需求选择适合的语言进行开发。","level":3},{"id":"/tags/tools/andorid-studio#历史演变","title":"历史演变","titles":["Android Studio"],"content":"2013 年 ：谷歌推出了 Android Studio 的第一个稳定版本。   2014 年 ：Android Studio 取代了 Eclipse 成为官方推荐的 Android 开发工具。   至今 ：Android Studio 不断更新迭代，增加新功能和改进用户体验，如更快的构建速度、更强大的代码分析和更丰富的布局设计工具等。","level":3},{"id":"/tags/tools/andorid-studio#关键功能和组件","title":"关键功能和组件","titles":["Android Studio"],"content":"Gradle 构建系统 ：用于管理和构建 Android 应用项目，支持灵活的构建配置和依赖管理。   Android Emulator ：内置的 Android 虚拟设备管理器，用于在电脑上模拟不同型号和版本的 Android 设备。   Layout Editor ：可视化的布局编辑器，支持拖拽和放置 UI 元素，实时预览界面效果。   Profiler ：性能分析工具，用于监测和优化应用的 CPU、内存和网络使用情况。   Code Editor ：集成了强大的代码编辑器，支持代码自动补全、实时错误检查和代码重构等功能。   Device File Explorer ：文件资源管理器，用于浏览和管理连接的 Android 设备或模拟器上的文件。   Firebase Integration ：集成了 Firebase 平台，提供应用分析、用户认证、数据库和云存储等功能。   Instant Run ：支持快速部署和调试应用的新代码，加快开发迭代速度。","level":3},{"id":"/tags/tools/andorid-studio#应用场景","title":"应用场景","titles":["Android Studio"],"content":"Android Studio 主要用于开发各种类型的 Android 应用程序，包括但不限于：普通应用程序 ：如社交媒体应用、工具类应用、生活服务应用等。   游戏应用程序 ：如休闲游戏、竞技游戏等不同类型的游戏应用。   企业应用程序 ：如内部管理工具、企业资源管理软件等。   物联网应用程序 ：如智能家居控制、智能设备管理等。   教育应用程序 ：如在线学习平台、教育资源分享平台等。","level":3},{"id":"/tags/tools/andorid-studio#总结","title":"总结","titles":["Android Studio"],"content":"Android Studio 是开发 Android 应用程序的主要工具之一，提供了丰富的功能和工具，帮助开发者快速、高效地创建和管理应用。通过不断的更新和优化，Android Studio 提升了开发体验和开发效率，成为众多开发者首选的集成开发环境。","level":3},{"id":"/tags/tools/apisix#apisix","title":"APISIX","titles":[],"content":"Apache APISIX 是一个开源、高性能的 API 网关和微服务管理平台，旨在处理 API 请求的路由、认证、负载均衡、限流、监控等功能。它支持动态配置，能够满足高并发、高可用性的场景需求。以下是对 APISIX 的详细介绍：","level":2},{"id":"/tags/tools/apisix#apisix-的主要特点","title":"APISIX 的主要特点","titles":["APISIX"],"content":"高性能 ：\nAPISIX 基于 NGINX 和 LuaJIT 构建，能够提供高吞吐量和低延迟的 API 请求处理能力。其性能在众多 API 网关解决方案中表现优异。   动态配置 ：\nAPISIX 支持热更新配置，无需重启服务即可对路由、插件等进行动态修改。这使得系统更加灵活，能够快速响应业务需求的变化。   丰富的插件系统 ：\nAPISIX 提供了丰富的插件，可以实现认证、限流、日志、监控、缓存、变更请求和响应等功能。用户还可以根据需求开发自定义插件。   多协议支持 ：\n除了常见的 HTTP/HTTPS 协议，APISIX 还支持 TCP、UDP、gRPC、WebSocket 等协议，适用于多种应用场景。   强大的路由机制 ：\nAPISIX 支持多种路由匹配方式，包括精确匹配、前缀匹配、正则匹配、条件匹配等，能够灵活定义流量转发规则。   可扩展性 ：\n通过插件机制和 Lua 脚本，APISIX 具备极高的可扩展性。开发者可以轻松扩展功能以满足特定业务需求。   原生支持服务发现 ：\nAPISIX 支持与多种服务发现系统集成，如 Nacos、Consul、Eureka、Kubernetes 等，实现服务的自动注册和发现。   监控和可观测性 ：\nAPISIX 集成了 Prometheus、SkyWalking 等监控工具，提供丰富的监控指标和可观测性，帮助用户及时了解系统状态和性能瓶颈。","level":3},{"id":"/tags/tools/apisix#安装和使用","title":"安装和使用","titles":["APISIX"],"content":"","level":3},{"id":"/tags/tools/apisix#安装-apisix","title":"安装 APISIX","titles":["APISIX","安装和使用"],"content":"APISIX 支持多种安装方式，包括源码安装、Docker 安装和使用 Kubernetes Helm Chart 安装。以下是使用 Docker 安装的示例：","level":4},{"id":"/tags/tools/apisix#配置和管理-apisix","title":"配置和管理 APISIX","titles":["APISIX","安装和使用"],"content":"APISIX 提供了 Dashboard 和 Admin API 两种管理方式。以下是通过 Admin API 配置路由和插件的示例：","level":4},{"id":"/tags/tools/apisix#使用-dashboard","title":"使用 Dashboard","titles":["APISIX","安装和使用"],"content":"APISIX Dashboard 是一个基于 Web 的图形界面，用户可以通过该界面方便地进行配置管理。","level":4},{"id":"/tags/tools/apisix#应用场景","title":"应用场景","titles":["APISIX","安装和使用"],"content":"APISIX 适用于多种应用场景，包括但不限于：微服务架构 ：在微服务架构中充当 API 网关，管理和路由内部和外部的 API 请求。   安全和认证 ：通过插件实现 API 的认证和授权，保护后端服务的安全。   流量控制 ：对 API 请求进行限流、熔断等流量控制，保障服务稳定性。   数据缓存 ：缓存频繁访问的 API 响应，减少后端服务负载，提高响应速度。   日志和监控 ：集成日志和监控系统，实时监控 API 的使用情况和性能。","level":3},{"id":"/tags/tools/apisix#总结","title":"总结","titles":["APISIX","安装和使用"],"content":"Apache APISIX 是一个功能强大、性能优越的 API 网关，提供了丰富的功能和灵活的扩展性。它能够帮助企业高效地管理和监控 API 请求，确保服务的高可用性和安全性。通过其动态配置、插件系统和多协议支持，APISIX 可以适应各种复杂的应用场景，是一个值得考虑的 API 管理解决方案。","level":3},{"id":"/tags/tools/ffmpeg#ffmpeg","title":"FFmpeg","titles":[],"content":"FFmpeg 是一个开源的多媒体框架，可以用来记录、转换和流式传输音视频。它支持几乎所有的音视频格式，具有强大的功能和高度的灵活性，被广泛应用于各种多媒体处理任务。以下是对 FFmpeg 的一些关键特性和使用方法的介绍。","level":2},{"id":"/tags/tools/ffmpeg#关键特性","title":"关键特性","titles":["FFmpeg"],"content":"广泛的格式支持 ：支持几乎所有已知的音视频格式。   高效的编码和解码 ：内置了许多高效的编码器和解码器。   音视频处理 ：支持剪辑、合并、过滤、调节等多种操作。   多平台支持 ：可以在多种操作系统上运行，包括 Windows、macOS、Linux 等。   流式传输 ：支持实时音视频流的传输和接收。","level":3},{"id":"/tags/tools/ffmpeg#安装","title":"安装","titles":["FFmpeg"],"content":"可以通过多种方式安装 FFmpeg，具体取决于你的操作系统。以下是一些常见的安装方法：","level":3},{"id":"/tags/tools/ffmpeg#在-windows-上安装","title":"在 Windows 上安装","titles":["FFmpeg","安装"],"content":"下载 FFmpeg 的预编译二进制文件：\n   从   FFmpeg 官网  下载 Windows 版本的预编译包。  解压下载的压缩包，并将 bin 目录添加到系统的 PATH 环境变量中。","level":4},{"id":"/tags/tools/ffmpeg#在-macos-上安装","title":"在 macOS 上安装","titles":["FFmpeg","安装"],"content":"可以使用 Homebrew 来安装 FFmpeg：","level":4},{"id":"/tags/tools/ffmpeg#在-linux-上安装","title":"在 Linux 上安装","titles":["FFmpeg","安装"],"content":"可以使用包管理器来安装 FFmpeg，例如在 Debian/Ubuntu 上：","level":4},{"id":"/tags/tools/ffmpeg#基本用法","title":"基本用法","titles":["FFmpeg","安装"],"content":"以下是一些常见的 FFmpeg 命令示例：","level":3},{"id":"/tags/tools/ffmpeg#转换视频格式","title":"转换视频格式","titles":["FFmpeg","安装","基本用法"],"content":"将一个视频文件从 MP4 格式转换为 AVI 格式：","level":4},{"id":"/tags/tools/ffmpeg#提取音频","title":"提取音频","titles":["FFmpeg","安装","基本用法"],"content":"从视频文件中提取音频，并保存为 MP3 格式：","level":4},{"id":"/tags/tools/ffmpeg#视频剪辑","title":"视频剪辑","titles":["FFmpeg","安装","基本用法"],"content":"剪辑视频文件的前 30 秒：","level":4},{"id":"/tags/tools/ffmpeg#合并视频文件","title":"合并视频文件","titles":["FFmpeg","安装","基本用法"],"content":"将多个视频文件合并为一个文件：首先，创建一个文本文件，列出要合并的视频文件：然后使用以下命令进行合并：","level":4},{"id":"/tags/tools/ffmpeg#添加水印","title":"添加水印","titles":["FFmpeg","安装","基本用法"],"content":"在视频文件中添加水印：","level":4},{"id":"/tags/tools/ffmpeg#压缩视频","title":"压缩视频","titles":["FFmpeg","安装","基本用法"],"content":"压缩视频以减少文件大小：","level":4},{"id":"/tags/tools/ffmpeg#总结","title":"总结","titles":["FFmpeg","安装"],"content":"FFmpeg 是一个功能强大且灵活的多媒体处理工具，广泛应用于音视频转换、处理和流式传输等任务。通过命令行接口，用户可以进行多种复杂的多媒体处理操作，满足各种需求。","level":3},{"id":"/tags/tools/figma#figma","title":"Figma","titles":[],"content":"Figma 是一款向量图形编辑软件，同时也是一个基于云端的设计工具。它支持多种文件格式导入，如 Sketch、Photoshop 和 Illustrator 等，也能轻松导出到这些格式。通过 Figma，设计师们可以实时协作，共同编辑同一个项目，大大提高了协作效率。此外，它还具有智能自动布局功能，使设计师可以将部分设计工作交给软件，从而更流畅、更具可控性地进行设计。Figma 具有跨平台特性，支持 Mac、Windows 和 Linux 等多个操作系统，并提供了移动端 APP，使得设计师们可以在各种设备和平台上使用 Figma 进行设计工作。并且，它提供了云端存储功能，用户可以随时随地存取设计文件，无需担心数据丢失。Figma 由 Dylan Field 和 Evan Wallace 于 2012 年在布朗大学攻读计算机科学专业时开始研究。他们的初衷是让“任何人都能够通过在浏览器中创建免费、简单、有创意的工具来发挥创意”。经过多年的发展，Figma 已经成为设计领域的一款重要工具，并在 2022 年被 Adobe 以 200 亿美元（约 1413 亿人民币）收购。此外，Figma 还有一个概念是在玩具领域。Figma 是由 Max Factory 企划及开发，GOOD SMILE COMPANY 发售的可动式人物模型系列。这一系列的设计和开发主要由 MAX 渡辺和浅井真纪负责，模型具有丰富的细节和灵活的关节，使模型能够摆出各种姿势。同时，Figma 系列也分为日版和代理版，它们在发售区域和售后服务上有所不同。总的来说，Figma 在设计和玩具领域都有广泛的应用和认可，是一款功能强大、灵活且易于使用的工具。无论是设计师还是模型爱好者，都能从中找到适合自己的功能和乐趣。","level":2},{"id":"/tags/tools/git#git","title":"Git","titles":[],"content":"Git 是一种分布式版本控制系统，由 Linus Torvalds 于 2005 年创建，用于管理 Linux 内核开发。它被广泛应用于软件开发中，用来跟踪代码的变更，协作开发和管理项目历史记录。以下是对 Git 的详细介绍。","level":2},{"id":"/tags/tools/git#git-的特点","title":"Git 的特点","titles":["Git"],"content":"分布式 ：每个开发者的工作目录都是一个完整的版本库，不依赖于中央服务器。   性能高效 ：快速的分支和合并操作，支持大项目的高效管理。   数据完整性 ：所有的数据在存储前都会进行校验，确保数据的完整性。   非线性开发 ：强大的分支和合并能力，支持并行开发和代码整合。","level":3},{"id":"/tags/tools/git#git-的基本概念","title":"Git 的基本概念","titles":["Git"],"content":"仓库（Repository） ：一个包含所有文件及其历史版本的数据库。分为本地仓库和远程仓库。   工作目录（Working Directory） ：开发者实际工作的地方，包含了项目的当前文件。   暂存区（Staging Area） ：一个包含了下次提交文件的集合。   提交（Commit） ：将暂存区中的文件保存到仓库中，每次提交都会生成一个唯一的 SHA-1 校验和作为标识。","level":3},{"id":"/tags/tools/git#常用-git-命令","title":"常用 Git 命令","titles":["Git"],"content":"","level":3},{"id":"/tags/tools/git#配置","title":"配置","titles":["Git","常用 Git 命令"],"content":"","level":4},{"id":"/tags/tools/git#初始化仓库","title":"初始化仓库","titles":["Git","常用 Git 命令"],"content":"","level":4},{"id":"/tags/tools/git#克隆仓库","title":"克隆仓库","titles":["Git","常用 Git 命令"],"content":"","level":4},{"id":"/tags/tools/git#文件操作","title":"文件操作","titles":["Git","常用 Git 命令"],"content":"查看状态 ：     添加文件到暂存区 ：    添加所有文件：     提交更改 ：","level":4},{"id":"/tags/tools/git#分支操作","title":"分支操作","titles":["Git","常用 Git 命令"],"content":"创建新分支 ：     切换分支 ：     创建并切换到新分支 ：     合并分支 ：\n切换到目标分支（例如   ），然后执行：     删除分支 ：","level":4},{"id":"/tags/tools/git#远程操作","title":"远程操作","titles":["Git","常用 Git 命令"],"content":"查看远程仓库 ：     添加远程仓库 ：     推送到远程仓库 ：     从远程仓库拉取更新 ：","level":4},{"id":"/tags/tools/git#标签操作","title":"标签操作","titles":["Git","常用 Git 命令"],"content":"创建标签 ：     推送标签到远程仓库 ：","level":4},{"id":"/tags/tools/git#git-的工作流程","title":"Git 的工作流程","titles":["Git","常用 Git 命令"],"content":"克隆远程仓库 到本地：     创建新分支 并切换到新分支：     在新分支上进行开发 ，并将文件添加到暂存区：     提交更改 ：     推送分支到远程仓库 ：     创建合并请求 （Pull Request）进行代码审查和合并。","level":3},{"id":"/tags/tools/git#git-的优势","title":"Git 的优势","titles":["Git","常用 Git 命令"],"content":"强大的分支管理 ：支持轻量级分支和高效的分支操作。   分布式架构 ：每个开发者都拥有完整的代码库历史，支持离线操作。   高效的合并机制 ：自动合并能力强，减少冲突。   广泛的社区支持 ：大量的开源项目和工具支持。Git 是现代软件开发中不可或缺的工具，其强大的功能和灵活性使其成为开发者管理代码的首选。希望这个介绍能帮助你更好地理解和使用 Git。","level":3},{"id":"/tags/tools/github#github","title":"GitHub","titles":[],"content":"GitHub 是一个基于 Git 版本控制系统的代码托管平台，旨在帮助开发者协作、管理和分享代码。以下是 GitHub 的一些关键特点：版本控制 ：GitHub 提供了强大的 Git 版本控制功能，使开发者能够跟踪代码的变化、协作开发和管理代码历史。   代码托管 ：开发者可以在 GitHub 上创建仓库（Repository）来存储和管理代码，方便团队协作和代码共享。   协作工具 ：GitHub 提供了 Issues、Pull Requests、Projects 等协作工具，方便团队成员进行讨论、代码审查和项目管理。   部署服务 ：GitHub Pages 服务允许开发者将静态网站部署到 GitHub 上，提供免费的托管服务。   社交网络 ：GitHub 是一个开发者社交平台，开发者可以关注其他开发者、Star 项目、Fork 项目等，促进开发者之间的交流和学习。   持续集成 ：GitHub Actions 提供了持续集成和部署功能，开发者可以通过配置 Workflows 来自动化构建、测试和部署流程。   安全性 ：GitHub 提供了代码扫描、漏洞警报等安全功能，帮助开发者保障代码安全。总的来说，GitHub 是一个功能强大的代码托管平台，为开发者提供了丰富的工具和功能，帮助他们更高效地进行代码管理、协作和部署。GitHub 的广泛应用和活跃的开发者社区使其成为全球最受欢迎的代码托管平台之一。","level":2},{"id":"/tags/tools/gitlab#gitlab","title":"GitLab","titles":[],"content":"GitLab 是一个用于仓库管理系统的开源项目，使用 Git 作为代码管理工具，并在此基础上搭建起来的 Web 服务。它提供了一个用于仓库管理的 Web 服务，允许用户通过 Web 界面访问公开或私有的项目，并能够管理团队对仓库的访问权限。GitLab 的主要特点包括：版本控制 ：作为一个基于 Git 的平台，GitLab 提供了强大的版本控制功能，允许用户创建分支、合并代码以及处理冲突。   Code Review ：GitLab 提供一个功能强大的 Code Review 机制，允许团队讨论代码更改并且进行实时审查。这有助于捕获潜在的错误，并确保代码符合标准和最佳实践。   持续集成和部署（CI/CD） ：GitLab 支持自动化的构建、测试和部署流程，这有助于加快开发发布周期，并帮助团队更快地交付高品质应用程序。   安全性 ：GitLab 提供遥测、扫描和安全审计功能，可以帮助管理员发现开发人员可能会忽略的安全漏洞。   自托管 ：使用 GitLab，用户可以选择将其托管在本地基础架构上，也可以选择使用 GitLab 的云托管方案，或者其他托管方案。这使得 GitLab 成为任何规模和类型的企业的选择。GitLab 由乌克兰程序员 DmitriyZaporozhets 和 ValerySizov 开发，使用 Ruby 语言写成，后来部分用 Go 语言重写。它基于 MIT 代码发布协议，并且具有 wiki 和 issue 跟踪功能。GitLab 被广泛使用，并被许多知名组织如 IBM、Sony、NASA、Alibaba 等采用。此外，GitLab 还提供了丰富的功能和工具，如项目管理、问题跟踪、合并请求等，以帮助团队更好地协作和管理软件开发过程。它还支持与其他工具和服务的集成，如持续集成/持续部署工具、代码质量分析工具等，以满足团队的具体需求。总之，GitLab 是一个功能强大、灵活且易于使用的仓库管理系统，适用于各种规模和类型的团队和组织，用于管理代码、协作开发和提高开发效率。如需了解更多，可以访问 GitLab 的官网，获取更详细的信息和使用教程。","level":2},{"id":"/tags/tools/n8n#n8n","title":"n8n","titles":[],"content":"N8N 是一个开源的工作流自动化工具，旨在帮助用户通过可视化界面轻松创建、管理和自动化各种任务和流程。以下是对 N8N 的详细介绍：","level":2},{"id":"/tags/tools/n8n#n8n-的主要特点","title":"N8N 的主要特点","titles":["n8n"],"content":"开源和自托管 ：\nN8N 是完全开源的，用户可以免费使用并部署在自己的服务器上。这提供了高度的灵活性和控制，尤其对于那些关心数据隐私和安全的用户。   直观的可视化界面 ：\nN8N 提供了一个直观的图形用户界面，用户可以通过拖放方式轻松创建和管理工作流。每个工作流节点代表一个任务或操作，这使得复杂的自动化流程变得简单易懂。   丰富的节点类型 ：\nN8N 支持多种节点类型，包括常见的 HTTP 请求、文件操作、数据库查询、电子邮件发送等。此外，还支持集成各种第三方服务，如 Google Sheets、Slack、GitHub、Trello 等。   条件逻辑和控制流 ：\nN8N 支持在工作流中添加条件逻辑和控制流节点，使用户能够根据特定条件执行不同的操作。这使得工作流更加灵活和强大。   数据转换和处理 ：\nN8N 允许用户在工作流中对数据进行转换和处理。用户可以通过内置的函数和表达式编辑器对数据进行各种操作。   扩展性 ：\nN8N 支持通过自定义节点和插件扩展其功能。开发者可以根据需要编写自己的节点，集成特定的服务或实现特定的功能。","level":3},{"id":"/tags/tools/n8n#安装和使用","title":"安装和使用","titles":["n8n"],"content":"","level":3},{"id":"/tags/tools/n8n#安装-n8n","title":"安装 N8N","titles":["n8n","安装和使用"],"content":"N8N 可以通过多种方式进行安装，包括 Docker、npm 和直接运行代码。以下是使用 Docker 安装的示例：上述命令将启动 N8N，并在本地的 5678 端口上提供服务。","level":4},{"id":"/tags/tools/n8n#创建和管理工作流","title":"创建和管理工作流","titles":["n8n","安装和使用"],"content":"安装并启动 N8N 后，可以通过浏览器访问 N8N 的界面（默认地址为   ）。在界面中，用户可以创建新的工作流并添加各种节点。","level":4},{"id":"/tags/tools/n8n#示例工作流","title":"示例工作流","titles":["n8n","安装和使用","创建和管理工作流"],"content":"以下是一个简单的工作流示例，展示了从 HTTP 请求获取数据并发送到 Slack 的流程：HTTP 请求节点 ：\n配置一个 HTTP 请求节点，设置请求 URL 和方法。例如，GET 请求   。   数据处理节点 ：\n添加一个函数节点，对 HTTP 请求返回的数据进行处理。例如，提取特定字段或进行格式化。   Slack 通知节点 ：\n配置一个 Slack 节点，设置 Slack Webhook URL 和消息内容。将处理后的数据作为消息内容发送到 Slack。","level":5},{"id":"/tags/tools/n8n#应用场景","title":"应用场景","titles":["n8n","安装和使用"],"content":"N8N 适用于各种自动化需求，以下是一些常见的应用场景：数据同步 ：在不同系统或服务之间同步数据，如从数据库导出数据到 Google Sheets。   通知和报警 ：根据特定事件或条件发送通知和报警，如监控服务器状态并在异常时发送邮件或 Slack 消息。   任务自动化 ：自动化重复性任务，如每天定时备份数据库或清理日志文件。   集成和连接 ：连接和集成各种第三方服务，实现跨平台的数据流和操作，如从 Trello 卡片创建 GitHub Issue。","level":3},{"id":"/tags/tools/n8n#总结","title":"总结","titles":["n8n","安装和使用"],"content":"N8N 是一个功能强大且灵活的工作流自动化工具，通过其直观的可视化界面和丰富的节点类型，使用户能够轻松创建和管理复杂的自动化任务和流程。无论是个人用户还是企业团队，N8N 都可以帮助他们提高效率，减少手动操作，优化工作流程。由于其开源和自托管的特性，N8N 也特别适合那些对数据隐私和安全有较高要求的用户。","level":3},{"id":"/tags/tools/nginx#nginx","title":"Nginx","titles":[],"content":"Nginx （发音为\"engine-x\"）是一个高性能的开源的 HTTP 和反向代理服务器，以及一个邮件代理服务器。它最初由俄罗斯的程序员 Igor Sysoev 开发，并于 2004 年首次公开发布。Nginx 因其稳定性、丰富的功能集、简单的配置和低资源消耗而广受欢迎，成为许多网站和互联网应用的首选服务器软件之一。","level":2},{"id":"/tags/tools/nginx#主要特点和功能","title":"主要特点和功能","titles":["Nginx"],"content":"高性能 ：Nginx 以其出色的性能著称，能够处理大量并发连接，高效地分发网络流量，适用于高负载的网站和应用。   反向代理 ：作为反向代理服务器，Nginx 可以将客户端请求转发到多个后端服务器，实现负载均衡和高可用性。   HTTP 服务器 ：Nginx 可以作为静态内容的 HTTP 服务器，处理静态文件的请求，并支持虚拟主机配置、URL 重写等功能。   反向代理缓存 ：支持反向代理缓存，可以缓存后端服务器的响应，加速对常见请求的处理，减轻后端服务器的负载。   SSL/TLS 支持 ：Nginx 可以作为 HTTPS 服务器提供安全的加密连接，并支持 SSL/TLS 协议的配置和优化。   动态模块 ：支持动态模块加载，可以通过第三方模块扩展功能，如 Lua 脚本处理、HTTP/2 支持等。   日志记录 ：支持详细的访问日志记录，可以记录客户端请求的各种信息，便于分析和监控。   虚拟主机支持 ：可以配置多个虚拟主机，使得同一台服务器可以托管多个不同域名的网站。   邮件代理 ：除了 HTTP 服务器功能，Nginx 还可以作为邮件代理服务器（IMAP/POP3/SMTP 代理）处理邮件服务。","level":3},{"id":"/tags/tools/nginx#应用场景","title":"应用场景","titles":["Nginx"],"content":"Web 服务器 ：用作 HTTP 服务器，提供静态文件服务、动态内容代理和负载均衡。   反向代理 ：将客户端请求转发到多个后端服务器，实现负载均衡和高可用性。   缓存服务器 ：作为反向代理缓存，加速对静态内容和动态内容的访问。   负载均衡 ：分发请求到多个服务器，提高整体系统的性能和可靠性。   安全代理 ：作为 HTTPS 服务器提供安全的加密连接，保护数据传输的安全性。   媒体流服务器 ：处理和分发音视频内容，支持 RTMP 和 HTTP 流媒体服务。","level":3},{"id":"/tags/tools/nginx#总结","title":"总结","titles":["Nginx"],"content":"Nginx 是一个功能强大、高性能的开源服务器软件，适用于处理高流量的网站和应用，同时具备反向代理、负载均衡、缓存、安全代理等多种功能。其简单的配置语法和低资源消耗使得它成为许多开发者和运维人员的首选，特别适用于构建高性能和可扩展的网络服务。","level":3},{"id":"/tags/tools/pandoc#pandoc","title":"Pandoc","titles":[],"content":"Pandoc 是一个开源的文档转换工具，被广泛认为是最强大的文档转换工具之一。它支持多种文档格式之间的转换，使得用户可以轻松地在不同的文档格式之间进行转换。Pandoc 是用 Haskell 语言编写的，并且可以在多种操作系统上运行，包括 Windows、macOS 和 Linux。","level":2},{"id":"/tags/tools/pandoc#主要特点","title":"主要特点","titles":["Pandoc"],"content":"多格式支持 ：    输入格式 ：Markdown、LaTeX、HTML、DOCX、ODT、EPUB 等。   输出格式 ：PDF、HTML、DOCX、ODT、EPUB、LaTeX、Markdown 等。   强大的 Markdown 支持 ：Pandoc 支持多种 Markdown 扩展，并且可以处理复杂的文档结构，如表格、脚注、内联代码块等。   模板系统 ：Pandoc 提供了一套模板系统，用户可以自定义输出格式的样式。例如，可以通过自定义 LaTeX 模板来生成具有特定格式的 PDF 文档。   过滤器 ：Pandoc 支持使用 Lua 脚本编写过滤器，允许用户在转换过程中对文档进行额外的处理和修改。   跨平台 ：Pandoc 可以在 Windows、macOS 和 Linux 上运行，并且可以通过命令行接口进行调用。","level":3},{"id":"/tags/tools/pandoc#安装-pandoc","title":"安装 Pandoc","titles":["Pandoc"],"content":"你可以通过多种方式安装 Pandoc：使用包管理器 （例如 Homebrew、apt-get、chocolatey）：   在 macOS 上使用 Homebrew：\n    在 Ubuntu 上使用 apt-get：\n    在 Windows 上使用 chocolatey：\n     从官方发布页面下载 ：你可以从 Pandoc 的   官方发布页面  下载适用于你的操作系统的预编译二进制文件。","level":3},{"id":"/tags/tools/pandoc#使用-pandoc","title":"使用 Pandoc","titles":["Pandoc"],"content":"Pandoc 的基本使用方法是通过命令行接口。以下是一些常见的使用示例：将 Markdown 转换为 HTML ：     将 Markdown 转换为 PDF ：     将 DOCX 转换为 Markdown ：     使用自定义模板生成 PDF ：     使用过滤器进行额外处理 ：","level":3},{"id":"/tags/tools/pandoc#示例","title":"示例","titles":["Pandoc"],"content":"以下是一个简单的示例，展示如何将 Markdown 文档转换为 HTML：创建一个 Markdown 文件   ，内容如下：    使用 Pandoc 将其转换为 HTML：生成的    文件将包含转换后的 HTML 内容。","level":3},{"id":"/tags/tools/pandoc#结论","title":"结论","titles":["Pandoc"],"content":"Pandoc 是一个非常强大的工具，适用于需要在各种文档格式之间进行转换的用户。它支持丰富的输入和输出格式，并且提供了强大的自定义功能和扩展能力。无论是用于简单的文档转换还是复杂的文档生成流程，Pandoc 都是一个非常有用的工具。","level":3},{"id":"/tags/tools/postman#postman","title":"Postman","titles":[],"content":"Postman 是一个接口测试工具，它在做接口测试时相当于一个客户端。它可以模拟用户发起的各类 HTTP 请求（如 GET、POST、DELETE、PUT 等），并将请求数据发送至服务端，从而获取对应的响应结果。这些响应结果可以被用来验证响应中的数据是否和预期值相匹配，从而确保开发人员能够及时处理接口中的 bug，进而保证产品上线之后的稳定性和安全性。Postman 的主要功能不仅限于此，它还支持环境变量的使用，使得在不同环境下进行测试变得更为便捷。同时，Postman 还提供了丰富的集合和请求管理功能，以及强大的测试脚本功能，使得接口测试更加全面和高效。在使用 Postman 时，用户可以通过其直观的界面来构建和发送 HTTP 请求，并查看响应结果。此外，Postman 还支持导入和导出测试数据，以及与其他团队协作完成测试任务。总的来说，Postman 是一个功能强大、易于使用的接口测试工具，适用于各种规模和复杂度的项目。它能够帮助开发团队提高测试效率，减少 bug 数量，从而提升产品的质量和用户体验。","level":2},{"id":"/tags/tools/redis-desktop#redis-desktop-manager","title":"Redis Desktop Manager","titles":[],"content":"Redis Desktop Manager（RDM）是一个用于管理 Redis 数据库的桌面客户端应用程序。它提供了图形用户界面（GUI），使用户可以方便地连接、操作和管理 Redis 实例，而无需使用命令行界面（CLI）。以下是对 Redis Desktop Manager 的详细介绍：","level":2},{"id":"/tags/tools/redis-desktop#主要特点和功能","title":"主要特点和功能","titles":["Redis Desktop Manager"],"content":"多平台支持 ：\nRedis Desktop Manager 提供了适用于 Windows、Mac OS 和 Linux 的客户端应用程序，支持跨平台使用。   连接管理 ：\n用户可以通过 Redis Desktop Manager 轻松地管理多个 Redis 数据库实例的连接。它支持基本的连接信息配置，如主机地址、端口号、认证密码等。   数据库操作 ：    数据浏览和编辑 ：通过 GUI 界面查看 Redis 中存储的数据结构（如字符串、列表、哈希表等），支持数据的编辑和更新操作。   键管理 ：可以查看和管理 Redis 中的键（keys），包括删除键、重命名键等操作。   数据导入导出 ：支持数据的导入和导出，方便用户在不同的 Redis 实例之间迁移数据或备份数据。   性能监控和统计 ：\nRedis Desktop Manager 提供了实时的性能监控和统计信息，包括连接状态、内存使用情况、命令执行情况等，帮助用户监控和优化 Redis 数据库的性能。   脚本执行 ：\n支持用户通过 Lua 脚本执行复杂的 Redis 操作，如事务、批量操作等，提升了数据处理的灵活性和效率。   插件和扩展 ：\nRedis Desktop Manager 提供了插件系统，允许用户根据需要扩展和定制功能，增强应用的适用性和用户体验。   安全性和权限管理 ：\n支持通过密码或者其他认证方式连接到 Redis 数据库，并且可以限制用户对数据库的操作权限，保障数据的安全性。","level":3},{"id":"/tags/tools/redis-desktop#使用场景","title":"使用场景","titles":["Redis Desktop Manager"],"content":"开发者和运维人员 ：用于开发和测试过程中的 Redis 数据库管理，提供便捷的数据查看和操作。   系统管理员 ：用于监控和管理生产环境中的 Redis 数据库，进行性能优化和故障排除。   数据分析师和应用程序员 ：用于处理和分析 Redis 中的数据，支持数据的导入导出和快速查询。","level":3},{"id":"/tags/tools/redis-desktop#总结","title":"总结","titles":["Redis Desktop Manager"],"content":"Redis Desktop Manager 是一个功能丰富的 Redis 客户端应用程序，通过提供直观的 GUI 界面和丰富的管理功能，简化了 Redis 数据库的连接、操作和管理过程。它适用于各种使用场景，帮助用户提高 Redis 数据库的使用效率和管理效果。","level":3},{"id":"/tags/tools/sublimetext#sublime-text","title":"Sublime Text","titles":[],"content":"Sublime Text 是一个功能强大的文本编辑器和代码编辑器，具有简洁的界面、丰富的插件和强大的功能，使得用户可以高效地编写、测试和调试代码。以下是对 Sublime Text 的详细介绍：首先，Sublime Text 支持多种编程语言的语法高亮，并具备优秀的代码自动完成功能。这意味着在编写代码时，Sublime Text 能够智能地预测和推荐接下来可能要输入的代码，从而大大提高编写代码的效率。此外，它还支持代码片段（Snippet）功能，可以将常用的代码片段保存起来，在需要时随时调用，进一步提升了编码效率。其次，Sublime Text 还支持 VIM 模式，用户可以使用 Vim 模式下的多数命令，这对于习惯使用 Vim 的用户来说无疑是一个极大的便利。同时，它还支持宏功能，用户可以将一系列操作录制下来，并在需要时重复执行这些操作，从而极大地简化了重复性的工作。在扩展性方面，Sublime Text 也表现得相当出色。它具有良好的扩展能力和完全开放的用户自定义配置，用户可以通过安装插件来扩展其功能，无论是语法高亮、自动完成、代码片段、文件管理等功能，都可以通过插件实现。这使得 Sublime Text 能够满足各种不同类型用户的需求。此外，Sublime Text 还支持强大的多行选择和多行编辑功能，以及即时文件切换和多重选择功能，这些功能都极大地提高了用户的操作效率和便利性。同时，它还支持多种布局和代码缩略图，用户可以通过滑动条方便地观察当前窗口在文件中的位置。最后，Sublime Text 是一个跨平台的编辑器，同时支持 Windows、Linux、Mac OS X 等操作系统，这使得用户可以在不同的操作系统上无缝地使用它。总的来说，Sublime Text 是一款非常优秀的文本编辑器和代码编辑器，具有强大的功能和良好的扩展性，适用于各种不同类型的用户。无论是初学者还是经验丰富的开发者，都可以通过使用 Sublime Text 来提高编码效率和代码质量。","level":2},{"id":"/tags/tools/typora#typora","title":"Typora","titles":[],"content":"Typora 是一款功能强大的跨平台 Markdown 编辑器，它以其简洁的界面和丰富的功能受到广大用户的喜爱。Typora 不仅支持基本的 Markdown 编辑功能，还提供了实时预览、多种主题和导出格式选项等特性，使得撰写和管理 Markdown 文档变得更加高效和愉悦。","level":2},{"id":"/tags/tools/typora#主要特点和功能","title":"主要特点和功能","titles":["Typora"],"content":"所见即所得编辑 ：\nTypora 提供了实时预览功能，即在编辑 Markdown 文本时，右侧即时显示渲染后的效果，用户可以直观地查看最终显示效果，无需切换视图。   全面的 Markdown 支持 ：\nTypora 支持标准的 Markdown 语法，包括标题、段落、列表、引用、代码块、表格、链接等，用户可以方便地使用这些语法来撰写文档。   智能功能和快捷键 ：\nTypora 提供了许多智能功能和快捷键，如自动补全、快速插入表格、链接、图片等，使得编辑过程更加高效。   多种主题和界面样式 ：\nTypora 提供了多种内置主题，用户可以根据个人喜好选择合适的主题，同时也支持自定义主题，满足不同用户的视觉需求。   导出多种格式 ：\nTypora 支持将 Markdown 文档导出为多种格式，包括 HTML、PDF、Word、纯文本等，用户可以根据需求选择合适的导出格式。   图表和数学公式支持 ：\nTypora 支持插入图表和数学公式，用户可以使用 Markdown 扩展语法（如 LaTeX 公式）轻松插入数学公式和复杂的图表。   跨平台和同步 ：\nTypora 可以在 Windows、macOS 和 Linux 系统上运行，并支持云同步功能，如 Dropbox 和 Google Drive，用户可以方便地在不同设备间同步和访问文档。   代码块高亮 ：\nTypora 支持对代码块进行语法高亮显示，提高代码可读性和理解性。","level":3},{"id":"/tags/tools/typora#使用方法","title":"使用方法","titles":["Typora"],"content":"安装和启动 ：\n用户可以从 Typora 官网（  https://typora.io/）下载适用于自己操作系统的安装包，安装完成后即可启动  Typora。   编辑和预览 ：\n在 Typora 编辑界面中，左侧为 Markdown 文本编辑区域，右侧为实时预览区域，用户可以即时查看编辑后的文档效果。   导出文档 ：\n在编辑完成后，用户可以通过菜单或快捷键选择导出格式，将 Markdown 文档导出为 HTML、PDF 或其他格式。   自定义设置 ：\nTypora 允许用户自定义界面风格、主题和快捷键，以及其他编辑器的偏好设置，使得用户体验更加个性化。","level":3},{"id":"/tags/tools/typora#应用场景","title":"应用场景","titles":["Typora"],"content":"技术文档和博客 ：\n开发者和写作人员可以使用 Typora 编写和管理技术文档、博客文章等。   学术写作 ：\n学术界的研究人员和学生可以利用 Typora 编写论文、笔记和学术报告，支持数学公式的插入使其尤为适用。   团队协作 ：\n团队成员可以使用 Typora 共同编辑 Markdown 文档，并通过云同步功能实现文档的共享和访问。   个人笔记 ：\n个人用户可以使用 Typora 记录和管理日常笔记，通过标签、目录等功能进行组织和管理。","level":3},{"id":"/tags/tools/typora#总结","title":"总结","titles":["Typora"],"content":"Typora 是一款优秀的 Markdown 编辑器，结合其所见即所得的编辑模式、丰富的功能和跨平台支持，使得它成为许多用户首选的 Markdown 编辑工具。无论是写作、编辑、技术文档制作还是学术写作，Typora 都能提供高效、直观且愉悦的写作体验。","level":3},{"id":"/tags/tools/vs#visual-studio","title":"Visual Studio","titles":[],"content":"Visual Studio 是由微软推出的集成开发环境（IDE），用于开发各种类型的应用程序，包括桌面应用、Web 应用、移动应用等。以下是 Visual Studio 的一些关键特点：多语言支持 ：Visual Studio 支持多种编程语言，如 C#, C++, JavaScript, Python 等，适用于各种开发场景。   强大的调试工具 ：Visual Studio 提供了强大的调试工具，包括断点调试、变量监视、堆栈跟踪等功能，帮助开发者快速定位和解决问题。   集成开发环境 ：Visual Studio 是一个集成的开发环境，提供了代码编辑器、调试器、编译器、版本控制等工具，简化了开发流程。   丰富的插件支持 ：Visual Studio 拥有丰富的插件市场，开发者可以根据需要安装各种插件，扩展 IDE 的功能和特性。   团队协作 ：Visual Studio 提供了团队协作和版本控制工具，如 Azure DevOps、Git 等，方便团队成员协作开发和管理项目。   跨平台开发 ：Visual Studio 支持跨平台开发，可以开发 Windows、iOS、Android 等不同平台的应用程序，提供了多平台的开发支持。   移动应用开发 ：Visual Studio 提供了用于移动应用开发的工具和模板，如 Xamarin，使得开发者能够快速构建跨平台移动应用。   云集成 ：Visual Studio 与 Azure 云服务紧密集成，提供了丰富的云服务和工具，支持开发者构建云原生应用和部署到云端。总的来说，Visual Studio 是一款功能强大且全面的集成开发环","level":2},{"id":"/tags/tools/vscode#vscode","title":"VSCode","titles":[],"content":"Visual Studio Code（简称 VSCode）是由微软开发的免费开源跨平台代码编辑器。它具有丰富的功能和扩展生态系统，适用于多种编程语言和技术栈。一些主要特点包括：轻量级编辑器 ：VSCode 是一款轻量级但功能强大的编辑器，具有快速启动时间和响应性能。   跨平台支持 ：VSCode 可在 Windows、macOS 和 Linux 上运行，提供一致的用户体验。   丰富的功能 ：包括智能代码补全、调试功能、Git 集成、内置终端、任务运行器等，提高开发效率。   强大的扩展生态系统 ：VSCode 拥有丰富的扩展库，用户可以根据需要安装各种插件，定制编辑器功能。   集成终端 ：VSCode 内置终端，可以在编辑器中直接运行命令和脚本，无需切换到外部终端。   多语言支持 ：支持多种编程语言，提供语法高亮、代码片段、代码导航等功能。总的来说，Visual Studio Code 是一款功能丰富、灵活可扩展的现代化代码编辑器，适用于各种开发场景和技术栈。","level":2},{"id":"/tags/tools/webpack#webpack","title":"Webpack","titles":[],"content":"Webpack 是一种前端资源构建（打包）工具，它主要用于将前端的各种资源文件（如 JS、CSS、图片等）打包成浏览器可识别的格式。Webpack 通过静态分析模块的依赖关系，将项目所需的每个模块映射到对应的依赖图中，并生成一个或多个 bundle。Webpack 的主要特点包括：模块化 ：它天生支持代码分割和模块化，使得开发者可以更方便地管理和组织代码。   Tree Shaking ：在 Webpack 2.0 及更高版本中，加入了 Tree Shaking 功能，用于提取公共代码并去除无用的代码，从而优化最终生成的 bundle。   Loader 和 插件 ：Webpack 具有强大的 Loader 和插件机制，使得它能够处理各种类型的文件，并支持各种扩展功能。例如，可以使用 Loader 来处理 CSS、图片等资源文件，使用插件来优化打包结果或实现其他自定义功能。   异步 IO 和多级缓存 ：Webpack 使用异步 IO 和多级缓存，提高了打包效率和性能。   友好的开发体验 ：Webpack 提供了开发服务器和热更新功能，使得开发者在开发过程中可以实时预览和调试代码，无需手动刷新浏览器。此外，Webpack 还支持代码压缩混淆、处理 js 兼容问题、性能优化等功能，使得前端项目在打包构建后能够更好地适应不同的运行环境和浏览器。总的来说，Webpack 是一个功能强大、灵活且易于扩展的前端构建工具，它已经成为绝大多数企业中前端项目打包构建的首选工具。通过使用 Webpack，开发者可以更高效地管理前端资源，提高项目的可维护性和性能。","level":2}]